
[//]: # (Chunk to run MC-2 metacell construction for a discrete -pbmcs- dataset)

```{r, include=FALSE}
# include this section if your child (nested) .Rmd has plot output. This make sure that plot is saved in correct location and displayed in rendered book. Mb not the best solution, but it works :) 
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

In this section, we construct metacells using [Metacell-2 (MC2)](https://github.com/tanaylab/metacells). The code is adapted from the [author's tutorial](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html). For more information on the method, please refer to the section 1 of chapter 2. 

#### Importing python packages {-}

To run Metacell-2, the following python packages need to be imported: 

```{python import-mc2, eval = FALSE}
import os
import numpy as np
import pandas as pd
import anndata as ad
import scanpy as sc
import matplotlib.pyplot as plt
import seaborn as sns
import metacells as mc
```

```{python mc2-QC-imports, eval = FALSE}
import sys
sys.path.append('./mc_QC/')
import mc_QC
```
If you don't have these packages installed, please refer to the section 2 of chapter 1.

```{python mc2-parameters, eval = TRUE, echo = FALSE}
MC_tool = "MC2"

# Here we can modify dataset 
proj_name = ["cell_lines", "3k_pbmc"][1]

annotation_label = {'cell_lines':'cell_line',
                   '3k_pbmc':'louvain'}[proj_name] # name of annotation field (obs)
```

### Data loading 
We will run Metacell-2 (MC2) on a single-cell dataset composed of XX peripheral blood mononuclear cells (PBMCs). Please follow the section 4 from Chapter 1 to retrieve these data from the scanpy package and save the data in the following file: "data/3k_pbmc/singlecell_anndata_filtered.h5ad".
```{r load-data, child='./functional_chunks/load_anndata.Rmd'}
```
```{python load-data-noEval, eval = FALSE, echo = TRUE}
MC_tool = "MC2"
proj_name = "3k_pbmc"
ad = sc.read(os.path.join("data", proj_name, "singlecell_anndata_filtered.h5ad"))
```

We initialize the name of the anndata (in the unstructured annotations) object using the `mc.ut.set_name()` function from the MC2 package.

```{python}
mc.ut.set_name(ad, proj_name)
```

### Filtering steps 
MC2 requires that standard filtering steps such as doublet filtering is performed outside of the MC2 framework. 
In addition to standard data filtering steps, the MC2 package proposes functions to filter the single-cell data at the gene and at the cell level (See [original vignette](https://tanaylab.github.io/metacells-vignettes/one-pass.html)). 
At the gene level, the filtering steps consist in excluding genes based on biological knowledge (*e.g.* mitochrondrial genes) as well as based on their expression levels. 
The latter genes include genes with zero expression or low expression levels and "bursty lonely genes" (*i.e.*, genes with high expression levels but no correlation with any other gene). 
At the cell level, filtering is performed based on cells UMI counts.

#### Gene filtering {-}

In section XX form Chapter XX, we pre-processed the raw scRNA-Seq data and excluded genes with low expression as well as mitochondrial genes. 
In the following code chunk, we exclude additional genes using the `mc.pl.exclude_genes()`function from the MC2 package. 
Based on the authors vignette, we provide a minimal list of genes to exclude, *i.e.*, sex-specific and non-coding genes. To complete this list of genes, an iterative approach can be used following the guidelines of the MC2 authors in a [second vignette](https://tanaylab.github.io/metacells-vignettes/iterative.html).
The `mc.pl.exclude_genes()`function will filter out: i) the known-to-be-excluded genes defined by the user as gene names or gene names patterns (`EXCLUDED_GENE_NAMES` and `EXCLUDED_GENE_PATTERNS` parameters respectively), 
and ii) the "bursty lonely genes". 

```{python mc2-gene-filtering, collapse = TRUE, result = 'hold'}
EXCLUDED_GENE_NAMES = ["XIST", "MALAT1", "NEAT1"] 
EXCLUDED_GENE_PATTERNS = ['MT-.*']

mc.pl.exclude_genes(
    ad,
    excluded_gene_names=EXCLUDED_GENE_NAMES, 
    excluded_gene_patterns=EXCLUDED_GENE_PATTERNS,
    random_seed=123456,
)

```

#### Cell filtering based on UMIs counts {-}

In the MC2 framework, cells with very low and very high UMI content will be filtered out (`PROPERLY_SAMPLED_MIN_CELL_TOTAL`, `PROPERLY_SAMPLED_MAX_CELL_TOTAL` variables defining thresholds in the next code chunk).  
Also, cell filtering based on UMI counts in excluded genes is also performed(`PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION` variable). 
Since our dataset has been pre-filtered, very lenient cutoffs will be used in this tutorial. 
The following code chunk defines these parameters. To adapt them to your datasets, we advise you to explore the distributions of total UMI counts and UMI counts in excluded genes, as recommended and described in the MC2 [original vignette](https://tanaylab.github.io/metacells-vignettes/one-pass.html).

```{python mc2-cell-filtering-parameters, warning = FALSE, collapse = TRUE, result = 'hold'}
PROPERLY_SAMPLED_MIN_CELL_TOTAL = 200 
PROPERLY_SAMPLED_MAX_CELL_TOTAL = 10000 
PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION = 0.25
```

The number of UMIs in excluded genes is computed using the `mc.tl.compute_excluded_gene_umis()` function and cells are filtered out using the `mc.pl.exclude_cells()` function.
Additional cells can be filtered out by adding a cell description columns in the `obs` data frame in the anndata oject. This annotation should be a boolean indicating whether the cell should filtered out or not. 
The name of this column should be provided to the `mc.pl.exclude_cells()` function via the `additional_cells_masks` parameter. 

```{python mc2-cells-filtering, result='hold', collapse = TRUE}
mc.tl.compute_excluded_gene_umis(ad)

mc.pl.exclude_cells(
    ad,
    properly_sampled_min_cell_total=PROPERLY_SAMPLED_MIN_CELL_TOTAL,
    properly_sampled_max_cell_total=PROPERLY_SAMPLED_MAX_CELL_TOTAL,
    properly_sampled_max_excluded_genes_fraction=PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION # ,
    # additional_cells_masks=["|doublet_cell"]
)
```

After performing the two-step filtering (genes and cells), the "cleaned" data can be extracted using the `mc.pl.extract_clean_data()` function.

```{python mc-extract-clean-cells, result='hold', collapse = TRUE}
# Extract clean dataset (with filtered cells and genes)
ad = mc.pl.extract_clean_data(ad)
```


### Building metacells

#### Defining lateral genes {-}

To build metacells, we need to define lateral genes, which are genes with strong biological signal which is independent of cell-state, *e.g.* cell-cycle genes. 
These genes will be ignored for computing cells similarity and build metacells 
but will be considered to define outlier cells (*i.e.*, expression levels of lateral genes should be consistent within metacells).
In the following chunk, we consider a minimal list of lateral genes including cell-cycle and ribosomal genes and mark them in the MC2 object using the `mc.pl.mark_lateral_genes()` function.

```{python mc-lateral-genes, result='hold', collapse = TRUE}

LATERAL_GENE_NAMES = [
    "AURKA", "MCM3", "MCM4", "MCM7", "MKI67", "PCNA", "RRM2", "SMC4", "TPX2",  # Cell-cycle
    "FOS", "HSP90AB1", "TXN",                                                  # Stress
]
LATERAL_GENE_PATTERNS = ["RP[LS].*"]  # Ribosomal

# This will mark as "lateral_gene" any genes that match the above, if they exist in the clean dataset.
mc.pl.mark_lateral_genes(
    ad,
    lateral_gene_names=LATERAL_GENE_NAMES,
    lateral_gene_patterns=LATERAL_GENE_PATTERNS,
)

```

Some genes have higher variances that expected which could lead to false positive outlier identification.
Users can mark those genes as *noisy genes* using the `mc.pl.mark_noisy_genes()` function. 
```{python mc-noisy-genes, result='hold', collapse = TRUE}

NOISY_GENE_NAMES = [
    "CCL3", "CCL4", "CCL5", "CXCL8", "DUSP1", "FOS", "G0S2", "HBB", "HIST1H4C", "IER2", "IGKC",
    "IGLC2", "JUN", "JUNB", "KLRB1", "MT2A", "RPS26", "RPS4Y1", "TRBC1", "TUBA1B", "TUBB"
]
# This will mark as "noisy_gene" any genes that match the above, if they exist in the clean dataset.
mc.pl.mark_noisy_genes(ad, noisy_gene_names=NOISY_GENE_NAMES)

```

To extend this list of lateral genes, users can use the `` function to identify genes that are highly correlated with the predefined lateral genes. 

#### Estimate target_metacell_size (gamma) {-}

By default, MC2 will build metacells with a size of 96 cells per metacells. 
Users can vary the `target_metacell_size` parameter to reach a desired graining level. 

```{python estimate-target-mc-size}
gamma   = 50 # graining level

target_metacell_size = round(ad.shape[0]/gamma)
target_metacell_size
```

#### Metacells identification using the divide and conquer approach {-}

The construction of metacells by MC2 is performed using the `mc.pl.divide_and_conquer_pipeline()` function.
Note that by default all cores of the system will be used for the metacells construction. 
To change this behavior and adapt the number of cores the MC2 authors propose to use the `mc.pl.guess_max_parallel_piles()` and `mc.pl.set_max_parallel_piles()` functions to adapt the number of processed in parallel depending on the available memory.

```{python mc2-divide-n-conquer, message=FALSE, warning=FALSE, result=FALSE}
max_parallel_piles = mc.pl.guess_max_parallel_piles(ad)
mc.pl.set_max_parallel_piles(max_parallel_piles)
mc.pl.divide_and_conquer_pipeline(
    ad,
    target_metacell_size = target_metacell_size,
    random_seed = 123456)

ad.obs.metacell.head
```

#### Retrieve aggregated metacell data {-}

The `mc.pl.divide_and_conquer_pipeline()` function associates each cell to a metacell or defines the cell as outlier. These assignments are found in the `obs` layer of the anndata object
The function `mc.pl.collect_metacells()` should be used to subsequently retrieve an anndata object containing the data at the metacells level instead of the single-cell level. 
This function will store in the `X` data matrix of the anndata object a matrix of gene fraction, *i.e.*, the sum of all gene levels in a metacell sums to 1
and it will store the total UMIs per gene per metacell in the layer `total_umis`. 

```{python mc2-aggregation, echo=TRUE}

mc_ad = mc.pl.collect_metacells(ad, name='metacells', random_seed = 123456)
mc_ad.shape
mc_ad.X.sum(axis=1)[:5] 
mc_ad.layers['total_umis']

```

**Comparing the obtained and requested graining level**

In the following code chunk, we estimate whether a deviation of the obtained gamma from the requested gamma is acceptable. If not, we suggest to increase or decrease the `target_metacell_size` parameter to approach the desired graining level.

```{r mc2-gamma-deviation, child='./functional_chunks/mc2_gamma_deviation.Rmd'}
```

### Visualize metacells

If single-cell annotations are available in the original single-cell anndata object. We can transfer these annotations to the metacell anndata object
using the `mc.tl.convey_obs_to_group()` function which will associate each metacell to the most frequent annotation (categorical) or averaged annotation (continuous) across the single-cells composing the metacell 
(use of the `mc.ut.most_frequent` and `np.mean` respectively in the `mode` paratemer). 
 
```{python mc2-annotation, result = FALSE}
# Assign a single value for each metacell based on the cells.
mc.tl.convey_obs_to_group(
    adata=ad, gdata=mc_ad,
    property_name="louvain", to_property_name="annotation",
    method=mc.ut.most_frequent  # This is the default, for categorical data
)

# Compute the fraction of cells with each possible value in each metacell:
mc.tl.convey_obs_fractions_to_group(  
    adata=ad, gdata=mc_ad,
    property_name="louvain", to_property_name="annotation"
)

```
 
The following code chunk adds a columns named `membership` and containing the single_cell assignments to the obs attribute in the anndata object containing the raw data. 
This annotation will be used in the mc_QC package to compute metacells quality metrics. We also save the single-cell metadata in the metacell anndata object.

```{python mc2-membership, result = FALSE}
# make a membership -- index of metacells to which single cells belong to 
ad.obs['membership'] = [int(i)+1 if i >= 0 else np.nan for i in ad.obs.metacell] 

## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object
mc_ad.uns = ad.uns.copy()
mc_ad.uns['sc.obs'] = ad.obs.copy()

# save the requested gamma
mc_ad.uns['gamma'] = gamma
```

####  Compute latent space for metacell QC {-}
To visualize the metacells, we can project the metacells on the single-cell UMAP representation. To run UMAP, we will generate in the next code chunk a lower-dimentional embedding of the data, so far not needed since the MC2 methods builds metacells from gene expression data and not from latent space. 
Also, note that some of the QC metrics (e.g., **compactness** and **separation**), that we will compute in the next section of this tutorial, are computed from this latent space. 

```{r mc2-latent-space, child = './functional_chunks/mc2_latent_space.Rmd'}
```
To visualize the metacell projection on the single-cell UMAP, we use the `mc_visualize` function from the `mc_QC`, this function was adapted from the `plot.plot_2D` included in the SEACells package.

```{python mc2-comp-umap, result = FALSE, warning = FALSE,}
mc_proj = mc_QC.mc_visualize(ad, key='X_umap', group_by_name='membership', colour_sc_name='louvain',  colour_mc_name='membership', colour_metacells=True, legend_sc=None, legend_mc=None)
mc_proj.show()
```

### Metacell QC

####  Compute purity, compactness and separation metrics {-}

```{r mc-qc, child = './functional_chunks/MC_QC.Rmd'}
```

##### Save output {-}

```{r mc2-save, child = './functional_chunks/save_mc_anndata.Rmd'}
```

```{python mc2-remove-variables, include = FALSE}
globals().pop('ad', None);
globals().pop('raw', None);
globals().pop('mc_ad', None);
globals().pop('mc_INV', None);
globals().pop('mc_INV_val', None);
globals().pop('compactness', None);
globals().pop('separation', None);
globals().pop('mc_purity', None);
globals().pop('membership', None);
globals().pop('mc_size', None);
globals().pop('mc_purity', None);
```



