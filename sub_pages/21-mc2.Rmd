
[//]: # (Chunk to run MC-2 metacell construction for a discrete -pbmcs- dataset)

```{r, include=FALSE}
# include this section if your child (nested) .Rmd has plot output. This make sure that plot is saved in correct location and displayed in rendered book. Mb not the best solution, but it works :) 
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

In this section, we construct metacells using [Metacell-2 (MC2)](https://github.com/tanaylab/metacells). The code is adapted from the [author's tutorial](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html). For more information on the method, please refer to the section 1 of chapter 2. 

#### Importing python packages {-}

To run Metacell-2, the following python packages need to be imported: 

```{python import-mc2, eval = FALSE}
import os
import numpy as np
import pandas as pd
import anndata as ad
import scanpy as sc
import matplotlib.pyplot as plt
import seaborn as sns
import metacells as mc
```

```{python mc2-QC-imports, eval = FALSE}
import sys
sys.path.append('./mc_QC/')
import mc_QC
```
If you don't have these packages installed, please refer to the section 2 of chapter 1.



```{python mc2-parameters, eval = TRUE, echo = FALSE}
MC_tool = "MC2"

# Here we can modify dataset 
proj_name = ["cell_lines", "3k_pbmc"][1]

annotation_label = {'cell_lines':'cell_line',
                   '3k_pbmc':'louvain'}[proj_name] # name of annotation field (obs)
```

### Data loading 
We will run Metacell-2 on a single-cell dataset composed of XX peripheral blood mononuclear cells (PBMCs). Please follow the section 4 from Chapter 1 to retrieve these data from the scanpy package and save the data in the following file: "data/3k_pbmc/singlecell_anndata_filtered.h5ad".
```{r load-data, child='./functional_chunks/load_anndata.Rmd'}
```
```{python load-data-noEval, eval = FALSE, echo = TRUE}
MC_tool = "MC2"
proj_name = "3k_pbmc"
ad = sc.read(os.path.join("data", proj_name, "singlecell_anndata_filtered.h5ad"))
```

We initialize the name of the anndata (in the unstructured annotations) object using the `ut.set_name` function from the Metacells package.

```{python}
mc.ut.set_name(ad, proj_name)
```

### Filtering steps 

Before building the metacells the Metacell-2 authors recommend to filter the single-cell data in two-steps (See [original vignette](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html)). 
A first filtering step consists in filtering genes based on biological knowledge (*e.g.* mitochrondrial genes) or based on their expression levels. The latter genes include genes with zero expression or low expression levels, "noisy lonely genes" (*i.e.*, genes with high expression levels but no correlation with any other gene). 
A second filtering step consists in filtering cells based on their UMI counts.

#### Gene filtering {-}

In section XX form Chapter XX, we pre-processed the raw scRNA-Seq data and excluded genes with low expression as well as mitochondrial genes. In the following code chunk, we identify additional genes to filter using the `analyze_clean_genes` and `pick_clean_genes` functions from the Metacells package, which returns three sets of genes: i) the known-to-be-excluded genes defined by the user as an array of gene names or gene names patterns, ii) the properly sampled genes, and iii) the "noisy lonely genes". 

```{python mc2-gene-filtering, collapse = TRUE, result = 'hold'}
excluded_gene_names = [] # for example, ['IGHMBP2', 'IGLL1', 'IGLL5', 'IGLON5', 'NEAT1', 'TMSB10', 'TMSB4X']
excluded_gene_patterns = ['MT-.*']
mc.pl.analyze_clean_genes(ad,
                          excluded_gene_names=excluded_gene_names,
                          excluded_gene_patterns=excluded_gene_patterns,
                          random_seed=123456)

mc.pl.pick_clean_genes(ad)
```

#### Cell filtering {-}

The first round of cell cleaning implies filtering out cell with very low and very hight UMI content (`properly_sampled_min_cell_total`, `properly_sampled_max_cell_total` parameters).  
The second round includes cell filtering based on UMI counts in excluded genes (`properly_sampled_max_excluded_genes_fraction` parameter). 
Since our dataset have been pre-filtered, very lenient cutoffs will be used in this tutorial (`properly_sampled_min_cell_total`, `properly_sampled_max_cell_total` and `properly_sampled_max_excluded_genes_fraction`) such that all the cells are kept for the metacell construction. 
The following code chunk defines these parameters. To adapt them to your datasets, we advise you to explore the distributions of total UMI counts and UMI counts in excluded genes, as recommended and descrided in the Metacell-2 [original vignette](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html).

```{python mc2-cell-filtering-parameters, warning = FALSE, collapse = TRUE, result = 'hold'}
### The first round of cell cleaning (high/low UMIs)
properly_sampled_min_cell_total = 200 
properly_sampled_max_cell_total = 10000 
## The second round of cell cleaning (content of excluded genes, e.g., mito-genes)
properly_sampled_max_excluded_genes_fraction = 0.25
```

The set of cells to be filtered is defined using the `analyze_clean_cells` and `pick_clean_cells` functions from the Metacell-2 package.

```{python mc2-cells-filtering, result='hold', collapse = TRUE}
mc.pl.analyze_clean_cells(
    ad,
    properly_sampled_min_cell_total = properly_sampled_min_cell_total,
    properly_sampled_max_cell_total = properly_sampled_max_cell_total,
    properly_sampled_max_excluded_genes_fraction = properly_sampled_max_excluded_genes_fraction
)
mc.pl.pick_clean_cells(ad)
```

After performing the two-step filtering (genes and cells), the "cleaned" data can be extracted using the `pl.extract_clean_data` prior to metacells construction.

```{python mc-extract-clean-cells, result='hold', collapse = TRUE}
# Extract clean dataset (with filtered cells and genes)
ad = mc.pl.extract_clean_data(ad)
```

### Building metacells

#### Estimate target_metacell_size (gamma) {-}

In contrast to the SuperCell and SEACells, Metacell-2 does not allow to explicitly obtain metacell data at a user-defined graining level. 
Instead, to vary the graining level, we have to vary the `target_metacell_size` parameter, that is `160000` by default. Here we provide a chunk to calibrate this value to reach a desired graining level. 
Please, increase or decrease the `scale` parameter if the obtained graining level (`gamma_obtained`) is lower or larger than the requested one (`gamma`).

```{python estimate-target-mc-size}
gamma   = 50 # graining level
print(f'The requested graining level is {gamma}, lets estimate the target_metacell_size that should result in such graining level.')

scale = 2 # increase or decrease if the obtained graining level (`gamma_obtained`) is significantly > or < then the requested one `gamma`

# estimated mean UMI content in downsampled data
total_umis_of_cells = mc.ut.get_o_numpy(ad, name='__x__', sum=True)
est_downsample_UMI = np.quantile(np.array(total_umis_of_cells), 0.05)

target_metacell_size = int(est_downsample_UMI * gamma * scale)
target_metacell_size
```

#### Aggregating metacells {-}

Metacell-2 uses its own feature selection approach (*i.e.*, selection of genes used to build metacells). 
Additionally, users can explicitly specify which features should be used by providing two arguments:  
i) `feature_gene_names`, *i.e.*, genes that have to be included and, ii) `forbidden_gene_names`, *i.e.*, genes that have to be excluded. 
Examples of forbidden are cell cycle genes which reflect true biological signal but could bias the metacells construction. The Metacell-2 [original vignette](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html) provides additional information to identify forbidden genes.
The previous arguments for feature selection are taken as input by the `pl.divide_and_conquer_pipeline` function which builds the metacells. 
Note that by default all cores of the system will be used for the metacells construction. More information are available on the [original vignette](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html) to change this behavior and adapt the number of cores (see `ut.set_processors_count`) or the number processed in parallel (see `pl.set_max_parallel_piles`).

```{python mc2-divide-n-conquer, message=FALSE, warning=FALSE, result=FALSE}
mc.pl.divide_and_conquer_pipeline(
    ad,
    #feature_gene_names   = feature_gene_names, # comment this line to allow Metacell2 selecting features
    #forbidden_gene_names = forbidden_gene_names, # comment this line to allow Metacell2 selecting features
    target_metacell_size = target_metacell_size,
    random_seed = 123456)

ad.obs.metacell.head
```

**Saving aggregated metacells in an `anndata` object for downstream analysis**

The `pl.divide_and_conquer_pipeline` function associate each cell to a metacell or defines the cell as outlier. These assignments are found in the `obs` layer of the anndata object
The function `pl.collect_metacells` should be used to subsequently retrieve an anndata object containing the data at the metacells level instead of the single-cell level. 

```{python mc2-aggregation, echo=TRUE}

mc_ad = mc.pl.collect_metacells(ad, name='metacells')
mc_ad.shape

```

**Comparing the obtained and requested graining level**

In the following code chunk, we estimate whether a deviation of the obtained gamma from the requested gamma is acceptable. If not, we suggest to increase or decrease the `scale` parameter to approach the desired graining level.

```{r mc2-gamma-deviation, child='./functional_chunks/mc2_gamma_deviation.Rmd'}
```

If the obtained graining level is not acceptable and you updated `scale` parameter according to the suggestion, do not forget to re-run chunk \@ref(chunk:mc2-divide-n-conquer) \@ref(aggregate-mc2).

### Visualize metacells

The following code chunk adds a columns named `membership` and containing the single_cell assignments to the obs attribute in the anndata object containing the raw data. 
This annotation will be used in the mc_QC package to compute metacells quality metrics. We also save the single-cell metadata in the metacell anndata object.

```{python mc2-membership, result = FALSE}
# make a membership -- index of metacells to which single cells belong to 
ad.obs['membership'] = [int(i)+1 if i >= 0 else np.nan for i in ad.obs.metacell] 

## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object
mc_ad.uns = ad.uns.copy()
mc_ad.uns['sc.obs'] = ad.obs.copy()

# save the requested gamma
mc_ad.uns['gamma'] = gamma
```

####  Compute latent space for metacell QC {-}
To visualize the metacells, we can project the metacells on the single-cell UMAP representation. To run UMAP, we will generate in the next code chunk a lower-dimentional embedding of the data, so far not needed since the MC2 methods builds metacells from gene expression data and not from latent space. 
Also, note that some of the QC metrics (e.g., **compactness** and **separation**), that we will compute in the next section of this tutorial, are computed from this latent space. 

```{r mc2-latent-space, child = './functional_chunks/mc2_latent_space.Rmd'}
```
To visualize the metacell projection on the single-cell UMAP, we use the `mc_visualize` function from the `mc_QC`, this function was adapted from the `plot.plot_2D` included in the SEACells package.

```{python mc2-comp-umap, result = FALSE, warning = FALSE,}
mc_proj = mc_QC.mc_visualize(ad, key='X_umap', group_by_name='membership', colour_sc_name='louvain',  colour_mc_name='membership', colour_metacells=True, legend_sc=None, legend_mc=None)
mc_proj.show()
```

### Metacell QC

####  Compute purity, compactness and separation metrics {-}

```{r mc-qc, child = './functional_chunks/MC_QC.Rmd'}
```

##### Save output {-}

```{r mc2-save, child = './functional_chunks/save_mc_anndata.Rmd'}
```

```{python mc2-remove-variables, include = FALSE}
globals().pop('ad', None);
globals().pop('raw', None);
globals().pop('mc_ad', None);
globals().pop('mc_INV', None);
globals().pop('mc_INV_val', None);
globals().pop('compactness', None);
globals().pop('separation', None);
globals().pop('mc_purity', None);
globals().pop('membership', None);
globals().pop('mc_size', None);
globals().pop('mc_purity', None);
```



