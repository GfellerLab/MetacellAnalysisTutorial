[{"path":"index.html","id":"this-tutorial","chapter":"This tutorial","heading":"This tutorial","text":"tutorial, describe different steps followed build metacells (Baran et al. 2019) single-cell data using three frameworks:\nSuperCell (Bilous et al. 2022) (tutorial 3.1), (ii) Metacells version 2 (MC2 (Ben-Kiki et al. 2022)) (tutorial 3.2), (iii) SEACells (Persad et al. 2023) (tutorial 3.3).also show obtain metacells running methods using command line tool provide part MetacellAnalysisToolkit (MCAT) github repository.\nrepository also contains MetacellAnalysisToolkit R package provides R functions compute QC\nmetrics visualization functions evaluate quality metacells.\nchapter ??, use MCAT build metacells continuous dataset CD34+ cells use R package visualize constructed metacells.\nchapter 4, describe use R package evaluate quality metacells.Finally, provide examples downstream analyses performed metacell level. analyses include clustering, differential analysis, data integration gene regulatory network analysis.","code":""},{"path":"requirements.html","id":"requirements","chapter":"1 Requirements","heading":"1 Requirements","text":"chapter describes obtain packages data needed reproduce analyses performed tutorial.","code":""},{"path":"requirements.html","id":"installations","chapter":"1 Requirements","heading":"1.1 Installations","text":"","code":""},{"path":"requirements.html","id":"using-conda-recommended","chapter":"1 Requirements","heading":"1.1.1 Using conda (recommended)","text":"build conda environment containing three metacell building tools used tutorial (SuperCell, MC2 SEACells),\nplease follow instructions provided README MetacellAnalysisToolkit github repository.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nuse_condaenv(conda_env)"},{"path":"requirements.html","id":"without-conda","chapter":"1 Requirements","heading":"1.1.2 Without conda","text":"don’t conda, can use following instructions:Set python virtual environment MC2 SEACells installed:R, install SuperCell package:run python function R, install reticulate:use python libraries installed virtual environment, define RETICULATE_PYTHON variable follow:","code":"pip install virtualenv\nvirtualenv my_env\nsource my_env/bin/activate\n\n# Installing SEACells\ngit clone https://github.com/dpeerlab/SEACells.git\ncd SEACells\npython setup.py install\ncd ..\npip install -r SEACells_requirements.txt\npip install ipywidgets\npip install jupyter\n\n# Install MC2\npip install git+https://github.com/tanaylab/metacells\nremotes::install_github(\"GfellerLab/SuperCell\", force = TRUE, upgrade = FALSE)\ninstall.packages('reticulate')echo 'RETICULATE_PYTHON=my_env/bin/python' > '.Renviron'"},{"path":"requirements.html","id":"PBMC-data","chapter":"1 Requirements","heading":"1.2 Retrieve a discrete dataset (PBMCs dataset)","text":"test metacell construction discrete dataset, retrieved 3k PBMCs scanpy datasets follows:data saved following file future analyses python (use SEACells MC2): “data/3k_pbmc/singlecell_anndata_filtered.h5ad”.data saved following file future analyses R (use SuperCell): “data/3k_pbmc/singlecell_seurat_filtered.rds”.","code":"import scanpy as sc \nimport os\n\nadata = sc.datasets.pbmc3k()\nadata_proc = sc.datasets.pbmc3k_processed()\n\nadata       = adata[adata_proc.obs_names].copy()\nadata.obs   = adata_proc.obs.copy()\nadata.uns   = adata_proc.uns.copy()\nadata.obsm  = adata_proc.obsm.copy()\nadata.obsp  = adata_proc.obsp.copy()\n\nadata.X = adata.X.astype(\"float32\")\nraw_ad = sc.AnnData(adata.X.copy())\nraw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names\nadata.raw = raw_addirectory = os.path.join(\"data\", \"3k_pbmc\")\n\nif not os.path.exists(directory):\n    os.makedirs(directory)\n  \nadata.write_h5ad(os.path.join(\"data\", \"3k_pbmc\", \"singlecell_anndata_filtered.h5ad\"))\nlibrary(reticulate)\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\nlibrary(anndata)\nadata <- anndata::read_h5ad(file.path(\"data/3k_pbmc/singlecell_anndata_filtered.h5ad\"))\n\nraw_counts <- Matrix::t(adata$raw$X)\ncolnames(raw_counts) <- rownames(adata$obs)\nrownames(raw_counts) <- rownames(adata$var)\n\npbmc <- CreateSeuratObject(counts = raw_counts, meta.data = adata$obs)\n#> Warning: Feature names cannot have underscores ('_'), replacing with dashes\n#> ('-')\nsaveRDS(pbmc, file = paste0(\"data/3k_pbmc/singlecell_seurat_filtered.rds\"))"},{"path":"requirements.html","id":"CD34-data","chapter":"1 Requirements","heading":"1.3 Retrieve a continuous dataset (CD34 dataset)","text":"test metacell construction discrete dataset, retrieved CD34 dataset provided (Persad et al. 2023):data saved following file future analyses python (use SEACells MC2): “data/CD34/singlecell_anndata_filtered.h5ad”.data saved following file future analyses R (use SuperCell): “data/CD34/singlecell_seurat_filtered.rds”.","code":"mkdir data/CD34\nwget -O data/CD34/cd34_multiome_rna.h5ad 'https://zenodo.org/record/6383269/files/cd34_multiome_rna.h5ad?download=1' import scanpy as sc \nimport os\n\nadata = sc.read(os.path.join(\"data\", \"CD34\", \"cd34_multiome_rna.h5ad\"))\nadata.X.sort_indices()\nraw_ad = sc.AnnData(adata.X.copy())\nraw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names\nadata.raw = raw_ad\n\nsc.pl.embedding(adata, 'X_umap', color='celltype')\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n#>   cax = scatter(directory = os.path.join(\"data\", \"cd34_multiome\")\n\nif not os.path.exists(directory):\n    os.makedirs(directory)\n    \nadata.write_h5ad(os.path.join(\"data\", \"CD34\", \"singlecell_anndata_filtered.h5ad\"))\nlibrary(reticulate)\nlibrary(Seurat)\nlibrary(anndata)\nadata <- anndata::read_h5ad(file.path(\"data/CD34/singlecell_anndata_filtered.h5ad\"))\n\nraw_counts <- Matrix::t(adata$raw$X)\ncolnames(raw_counts) <- rownames(adata$obs)\nrownames(raw_counts) <- rownames(adata$var)\n\ncd34 <- CreateSeuratObject(counts = raw_counts, meta.data = adata$obs)\nsaveRDS(cd34, file = file.path(\"data/CD34/singlecell_seurat_filtered.rds\"))"},{"path":"requirements.html","id":"HLCA-data","chapter":"1 Requirements","heading":"1.4 Retrieve the lung atlas dataset","text":"dataset used integration large number single-cell datasets level metacells (see section 7).\nConsidering, large size data download, don’t consider running integration analysis, can skip part tutorial.","code":""},{"path":"requirements.html","id":"downloading-the-atlas","chapter":"1 Requirements","heading":"1.4.1 Downloading the atlas","text":"illustrate metacells can used context single-cell data integration,\nused cell atlas human lung (core) available cellxgene.\ndownload data, please choose .h5ad option clicking download button core atlas (3 tissues, 584’944 cells).Save data data/HLCA/ directory.Please note may take time (~45 mins) file quite large (5.6 GB).","code":""},{"path":"requirements.html","id":"splitting-atlas-by-datasets","chapter":"1 Requirements","heading":"1.4.2 Splitting atlas by datasets","text":"use anndata read backed mode (saving lot memory) whole atlas write one h5ad file dataset.\ntake less 10 minutes.limited time feel free process subset dataset.","code":"\nt0.split <- Sys.time()\n\nlibrary(anndata)\nadata <- read_h5ad(\"data/HLCA/local.h5ad\",backed = \"r\")\nadata$var_names <- adata$var$feature_name # We will use gene short name for downstream analyses\ndatasets <- unique(adata$obs$dat)\n\n# If you are limited in time you can process on half of the datasets (uncomment th following line)\n# datasets <- datasets[1:7]\n\nprint(dim(adata))\n\nlapply(datasets,FUN =  function(x) {\n  dir.create(paste0(\"data/HLCA/datasets/\",x),recursive = T)\n  adata.dataset <- AnnData(X = adata[adata$obs$dataset == x]$raw$X,\n                           var = adata[adata$obs$dataset == x]$var,\n                           obs = adata[adata$obs$dataset == x]$obs)\n  #This will allow us to construct supervised metacell for each cell type in each sample later in the tutorial\n  adata.dataset$obs$ann <- as.character(adata.dataset$obs$ann_level_3)\n  # For cell without an annotation at the 3rd level we will use the second level of annotation\n  adata.dataset$obs$ann[adata.dataset$obs$ann_level_3 == 'None'] = as.character(adata.dataset$obs$ann_level_2[adata.dataset$obs$ann_level_3 == 'None'])\n  adata.dataset$obs$ann_sample <- paste0(adata.dataset$obs$ann,\"_\",adata.dataset$obs$sample)\n  \n  write_h5ad(adata.dataset,paste0(\"data/HLCA/datasets/\",x,\"/sc_adata.h5ad\"))\n}\n)\n\nremove(adata)\ngc()\n\ntf.split <- Sys.time()\ntf.split - t0.split"},{"path":"the-metacell-concept.html","id":"the-metacell-concept","chapter":"2 The metacell concept","heading":"2 The metacell concept","text":"Metacells correspond partitions single-cell data disjoint homogeneous groups highly similar cells followed aggregation profiles (Baran et al. 2019).\nconcept relies assumption variability within metacells corresponds technical noise biologically relevant heterogeneity.Using metacells enables users : () remove noise preserving enhancing biological signal sparse single-cell genomics data ,\n(ii) address computational challenges due large size data.metacell concept.Several studies built upon metacell concept. tutorial, consider three tools providing standalone metacell construction frameworks \ndescribe different steps followed build metacells using tools:\n() SuperCell (Bilous et al. 2022) (tutorial 3.1), (ii) Metacells version 2 (MC2 (Ben-Kiki et al. 2022)) (tutorial 3.2), (iii) SEACells (Persad et al. 2023) (tutorial 3.3).","code":""},{"path":"Metacell-construction-chapter.html","id":"Metacell-construction-chapter","chapter":"3 Constructing metacells","heading":"3 Constructing metacells","text":"chapter, demonstrate metacell construction using three different methods: SuperCell R, MetaCell-2 (MC2) SEACells Pyhton., first use dataset PBMCs study. dataset contains around 3K cells example dataset well defined cell types.\nexample continuous data, see chapter ??.","code":""},{"path":"Metacell-construction-chapter.html","id":"SuperCell-construction","chapter":"3 Constructing metacells","heading":"3.1 SuperCell (R)","text":"section, construct metacells using R package SuperCell.","code":""},{"path":"Metacell-construction-chapter.html","id":"method","chapter":"3 Constructing metacells","heading":"3.1.1 Method","text":"SuperCell method first reduces gene expression space using principal component analysis (PCA) computes euclidean distances based reduced space.\nUsing euclidean distances, single-cell kNN graph built metacells identified applying walktrap community detection algorithm.\nnumber metacells obtained can chosen user defining graining level parameter.code provided section adapted author’s github documentation.\ninformation method, please refer review (Review?) original paper (Bilous et al. 2022).","code":""},{"path":"Metacell-construction-chapter.html","id":"importing-r-packages","chapter":"3 Constructing metacells","heading":"Importing R packages","text":"run SuperCell, following R package needs imported:","code":"\nif(system.file(package='SuperCell') == \"\"){\n  remotes::install_github(\"GfellerLab/SuperCell\", force = TRUE, upgrade = FALSE)\n} \nlibrary(SuperCell)"},{"path":"Metacell-construction-chapter.html","id":"data-loading","chapter":"3 Constructing metacells","heading":"3.1.2 Data loading","text":"run SuperCell single-cell dataset composed 2638 peripheral blood mononuclear cells (PBMCs) available scanpy package.\nPlease follow section 1.2 retrieve data scanpy package, preprocess save data following file: “data/3k_pbmc/singlecell_seurat_filtered.rds”.","code":"\nprint(proj_name)\n#> [1] \"3k_pbmc\"\ncelltype_colors <- c(\n  \"CD14+ Monocytes\"    = \"#E69F00\",  # orange\n  \"B cells\"            = \"#56B4E9\",  # sky blue\n  \"CD4 T cells\"        = \"#009E73\",  # bluish green\n  \"NK cells\"           = \"#F0E442\",  # yellow\n  \"CD8 T cells\"        = \"#0072B2\",  # blue\n  \"FCGR3A+ Monocytes\"  = \"#D55E00\",  # vermillion\n  \"Dendritic cells\"    = \"#CC79A7\",  # reddish purple\n  \"Megakaryocytes\"     = \"#000000\"   # black\n)\nsc_data = readRDS(paste0(\"data/\", proj_name, \"/singlecell_seurat_filtered.rds\"))"},{"path":"Metacell-construction-chapter.html","id":"filtering-steps","chapter":"3 Constructing metacells","heading":"3.1.3 Filtering steps","text":"tutorial, data pre-filtered SuperCell require filtering steps.","code":""},{"path":"Metacell-construction-chapter.html","id":"building-metacells","chapter":"3 Constructing metacells","heading":"3.1.4 Building metacells","text":"Metacells construction using SuperCell requires one main input, .e. matrix log-normalized gene expression data used compute PCA subsequently build knn graph metacells identification.\nImportant optional inputs :\n() graining level (gamma parameter),\n(ii) number neighbors consider knn graph (k.knn parameter),\n(iii) number principal components use generate knn graph (n.pc parameter),\n(iv) number variable genes consider PCA (n.var.genes parameter).","code":""},{"path":"Metacell-construction-chapter.html","id":"data-pre-processing","chapter":"3 Constructing metacells","heading":"Data pre-processing","text":"SuperCell builds knn graph based Euclidean distances defined PCA space.\nPCA computation performed log-normalized gene expression data SCimplify SuperCell function.\nfollowing code chunk, use Seurat normalize visualize data:","code":"\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\nsc_data <- NormalizeData(sc_data, normalization.method = \"LogNormalize\")\nsc_data <- FindVariableFeatures(sc_data, nfeatures = 2000)\nsc_data <- ScaleData(sc_data)\n#> Centering and scaling data matrix\nsc_data <- RunPCA(sc_data, npcs = 50, verbose = F)\nsc_data <- RunUMAP(sc_data, reduction = \"pca\", dims = c(1:30), n.neighbors = 15, verbose = F)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\nUMAPPlot(sc_data, group.by = annotation_label, cols = celltype_colors)"},{"path":"Metacell-construction-chapter.html","id":"setting-up-supercell-parameters","chapter":"3 Constructing metacells","heading":"Setting up SuperCell parameters","text":"tutorial, run SuperCell using 30 first principal components resulting PCA.\nchose graining level 25 number neighbors 15 knn step.","code":"\ngamma = 10 # the requested graining level.\nk_knn = 15 # the number of neighbors considered to build the knn network.\nnb_var_genes = 2000 # number of the top variable genes to use for dimensionality reduction \nnb_pc = 50 # the number of principal components to use.   "},{"path":"Metacell-construction-chapter.html","id":"metacells-identification","chapter":"3 Constructing metacells","heading":"Metacells identification","text":"metacells identified using SCimplify function SuperCell package.SCimplify returns list containing following main elements:\n() single-cell assignments metacells (membership),\n(ii) metacell sizes (supercell_size),\n(iii) single-cell graph (graph.singlecell),\n(iv) metacell graph (graph.supercells),\n(v) genes used metacell identification (genes.use).","code":"\nMC <- SuperCell::SCimplify(Seurat::GetAssayData(sc_data, slot = \"data\"),  # single-cell log-normalized gene expression data\n                           k.knn = k_knn,\n                           gamma = gamma,\n                           # n.var.genes = nb_var_genes,  \n                           n.pc = nb_pc,\n                           genes.use = Seurat::VariableFeatures(sc_data)\n                           )"},{"path":"Metacell-construction-chapter.html","id":"retrieve-aggregated-metacell-data","chapter":"3 Constructing metacells","heading":"Retrieve aggregated metacell data","text":"supercell_GE() function can used generate metacell counts matrix (aggregation gene expression across cells belonging metacell).\nTwo modes can used single-cell aggregation, .e. averaging log-normalized gene expression summing raw counts (using mode parameter).\nNote provide raw counts aggregation tutorial match aggregation steps using PC2 SEAcells (see 3.2 3.3).\nData normalization thus needed downstream analyses metacell counts matrix.","code":"\nMC.GE <- supercell_GE(Seurat::GetAssayData(sc_data, slot = \"counts\"),\n                      MC$membership,\n                      mode =  \"sum\"\n                      )\ndim(MC.GE) \n#> [1] 32738   264"},{"path":"Metacell-construction-chapter.html","id":"annotate-metacells-using-available-annotations","chapter":"3 Constructing metacells","heading":"3.1.5 Annotate metacells (using available annotations)","text":"can assign metacell particular annotation using supercell_assign() function.\ndefault, function assigns metacell cluster largest Jaccard coefficient avoid biases towards rare abundant clusters.\nAlternatively, assignment can performed using relative (method = \"relative\", may cause biases towards small populations) absolute (method = \"absolute\", may cause biases towards large populations) abundance.SuperCell package provides supercell_plot function visualize metacell network (igraph object number nodes corresponds number metacells),\nstored MC list graph.supercells.\nmetacells can colored respect vector annotation.","code":"\nprint(annotation_label)\n#>   3k_pbmc \n#> \"louvain\"\nMC$annotation <- supercell_assign(clusters = sc_data@meta.data[, annotation_label], # single-cell annotation\n                                  supercell_membership = MC$membership, # single-cell assignment to metacells\n                                  method = \"absolute\"\n                                  )\n\nhead(MC$annotation)\n#>                 1                 2                 3                 4 \n#>         \"B cells\" \"CD14+ Monocytes\"     \"CD4 T cells\"        \"NK cells\" \n#>                 5                 6 \n#>     \"CD4 T cells\"     \"CD4 T cells\"\nsupercell_plot(\n  MC$graph.supercells, \n  group = MC$annotation, \n  seed = 1, \n  alpha = -pi/2,\n  main  = \"Metacells colored by cell line assignment\"\n)"},{"path":"Metacell-construction-chapter.html","id":"save-output","chapter":"3 Constructing metacells","heading":"3.1.6 Save output","text":"future downstream analyses R (section 6.1), metacell counts can saved Seurat object.\nalso save Seurat object PCA components genes used SCimplify future QC analysis (See 4).can also use supercell_2_Seurat() function SuperCell package.\nfunction takes inputs metacell count matrix (output SuperCell supercell_GE() function) output SuperCell SCimplify() function\noutput Seurat object containing normalized metacells gene expression data well first (N.comp) principal components PCA performed internally using user defined set genes (default genes used metacells constructions).future downstream analyses python (section ??), metacell counts can saved Anndata object:","code":"\ncolnames(MC.GE) <- as.character(1:ncol(MC.GE))\nMC.seurat <- CreateSeuratObject(counts = MC.GE, \n                                meta.data = data.frame(size = as.vector(table(MC$membership)))\n                                )\nMC.seurat[[annotation_label]] <- MC$annotation\n\n# save single-cell membership to metacells in the MC.seurat object\nMC.seurat@misc$cell_membership <- data.frame(row.names = names(MC$membership), membership = MC$membership)\nMC.seurat@misc$var_features <- MC$genes.use \n\n# Save the PCA components and genes used in SCimplify  \nPCA.res <- irlba::irlba(scale(Matrix::t(sc_data@assays$RNA@data[MC$genes.use, ])), nv = nb_pc)\npca.x <- PCA.res$u %*% diag(PCA.res$d)\nrownames(pca.x) <- colnames(sc_data@assays$RNA@data)\nMC.seurat@misc$sc.pca <- CreateDimReducObject(\n  embeddings = pca.x,\n  loadings = PCA.res$v,\n  key = \"PC_\",\n  assay = \"RNA\"\n)\nprint(paste0(\"Saving metacell object for the \", proj_name, \" dataset using \", MC_tool))\n#> [1] \"Saving metacell object for the 3k_pbmc dataset using SuperCell\"\nsaveRDS(MC.seurat, file = paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))\nMC.seurat <- supercell_2_Seurat(\n  SC.GE = MC.GE,\n  SC = MC,\n  fields = c(\"annotation\", \"supercell_size\"), # elements of MC to save as metacell metadata \n  var.genes = MC$genes.use,\n  N.comp = 10\n)\nsaveRDS(MC.seurat, file = paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))\nMC.seurat.ad <- anndata::AnnData(\n  X = Matrix::t(Seurat::GetAssayData(MC.seurat, slot = \"counts\")),\n  obs = MC.seurat@meta.data\n)\n\nanndata::write_h5ad(anndata = MC.seurat.ad, filename = paste0('./data/', proj_name, '/metacell_', MC_tool,'.h5ad'))#>            used  (Mb) gc trigger  (Mb) max used  (Mb)\n#> Ncells  3474466 185.6    5447132 291.0  5447132 291.0\n#> Vcells 20531196 156.7   65218418 497.6 65217828 497.6"},{"path":"Metacell-construction-chapter.html","id":"MC2-construction","chapter":"3 Constructing metacells","heading":"3.2 MC2 (Python)","text":"section, construct metacells using Metacell-2 (MC2) implemented Python.","code":""},{"path":"Metacell-construction-chapter.html","id":"method-1","chapter":"3 Constructing metacells","heading":"3.2.1 Method","text":"Metacell-2 (MC2) python tool construct metacells updated version MetaCell algorithm, introduced concept metacell.\nMC2 applies two-phase divide--conquer approach. Cells randomly divided piles ~10k cells \ninitial metacells built applying MetaCell-like approach per pile, .e. based single-cell kNN graph built\nlog-normalized counts using set highly variable genes.\n, transcriptionally similar metacells grouped metagroup piles identification final metacells outliers identification.\nNote prior metacell identification, MC2 framework recommends gene filtering steps. choice genes used\nmethod high importance assure good quality metacells.code provided section adapted author’s tutorial.\ninformation method, please refer review (Review?) original paper (Ben-Kiki et al. 2022).","code":""},{"path":"Metacell-construction-chapter.html","id":"importing-python-packages","chapter":"3 Constructing metacells","heading":"Importing python packages","text":"run MC2, following python packages need imported:don’t packages installed, please refer section 1.1.","code":"import os\nimport numpy as np\nimport pandas as pd\nimport anndata as ad\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport metacells as mc"},{"path":"Metacell-construction-chapter.html","id":"data-loading-1","chapter":"3 Constructing metacells","heading":"3.2.2 Data loading","text":"run Metacell-2 (MC2) single-cell dataset composed around 3000 peripheral blood mononuclear cells (PBMCs).\nPlease follow section 1.2 retrieve data scanpy package save data following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”.initialize name anndata (unstructured annotations) object using mc.ut.set_name() function MC2 package.","code":"MC_tool = \"MC2\"\nproj_name = \"3k_pbmc\"\nad = sc.read(os.path.join(\"data\", proj_name, \"singlecell_anndata_filtered.h5ad\"))\nad.X = ad.raw.X.copy()mc.ut.set_name(ad, proj_name)"},{"path":"Metacell-construction-chapter.html","id":"filtering-steps-1","chapter":"3 Constructing metacells","heading":"3.2.3 Filtering steps","text":"MC2 requires standard filtering steps doublet filtering performed outside MC2 framework.\naddition standard data filtering steps, MC2 package proposes functions filter single-cell data gene cell level (See author’s vignette).\ngene level, filtering steps consist excluding genes based biological knowledge (e.g. mitochrondrial genes) well based expression levels.\nlatter genes include genes zero expression low expression levels “bursty lonely genes” (.e., genes high expression levels correlation gene).\ncell level, filtering performed based cells UMI counts.","code":""},{"path":"Metacell-construction-chapter.html","id":"gene-filtering","chapter":"3 Constructing metacells","heading":"Gene filtering","text":"following code chunk, exclude genes using mc.pl.exclude_genes()function MC2 package.\nBased authors vignette, consider minimal list genes exclude, .e., sex-specific non-coding genes well mitochondrial genes.\ncomplete list genes, iterative approach can used following guidelines MC2 authors second vignette.\nmc.pl.exclude_genes() function filter :\n) known---excluded genes defined user gene names gene names patterns (EXCLUDED_GENE_NAMES EXCLUDED_GENE_PATTERNS parameters respectively),\nii) “bursty lonely genes”.","code":"EXCLUDED_GENE_NAMES = [\"XIST\", \"MALAT1\", \"NEAT1\"] \nEXCLUDED_GENE_PATTERNS = ['MT-.*']\n\nmc.pl.exclude_genes(\n    ad,\n    excluded_gene_names=EXCLUDED_GENE_NAMES,\n    excluded_gene_patterns=EXCLUDED_GENE_PATTERNS,\n    random_seed=123456\n)\n#> set 3k_pbmc.var[bursty_lonely_gene]: 0 true (0%) out of 32738 bools\n#> set 3k_pbmc.var[properly_sampled_gene]: 16579 true (50.64%) out of 32738 bools\n#> set 3k_pbmc.var[excluded_gene]: 16174 true (49.4%) out of 32738 bools"},{"path":"Metacell-construction-chapter.html","id":"cell-filtering-based-on-umis-counts","chapter":"3 Constructing metacells","heading":"Cell filtering based on UMIs counts","text":"MC2 framework, cells low high UMI content filtered (PROPERLY_SAMPLED_MIN_CELL_TOTAL, PROPERLY_SAMPLED_MAX_CELL_TOTAL variables defining thresholds next code chunk).\nAlso, cell filtering based UMI counts excluded genes also performed(PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION variable).\nSince dataset pre-filtered, lenient cutoffs used tutorial.\nfollowing code chunk defines parameters.\nadapt datasets, advise explore distributions total UMI counts UMI counts excluded genes, recommended described MC2 original vignette.number UMIs excluded genes computed using mc.tl.compute_excluded_gene_umis() function cells filtered using mc.pl.exclude_cells() function.\nAdditional cells can filtered adding cell description columns obs data frame anndata oject. annotation boolean indicating whether cell filtered .\nname column provided mc.pl.exclude_cells() function via additional_cells_masks parameter.performing two-step filtering (genes cells), “cleaned” data can extracted using mc.pl.extract_clean_data() function.","code":"PROPERLY_SAMPLED_MIN_CELL_TOTAL = 200 \nPROPERLY_SAMPLED_MAX_CELL_TOTAL = 10000 \nPROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION = 0.25mc.tl.compute_excluded_gene_umis(ad)\n\nmc.pl.exclude_cells(\n    ad,\n    properly_sampled_min_cell_total=PROPERLY_SAMPLED_MIN_CELL_TOTAL,\n    properly_sampled_max_cell_total=PROPERLY_SAMPLED_MAX_CELL_TOTAL,\n    properly_sampled_max_excluded_genes_fraction=PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION # ,\n    # additional_cells_masks=[\"|doublet_cell\"]\n)\n#> set 3k_pbmc.obs[properly_sampled_cell]: 2638 true (100%) out of 2638 bools\n#> set 3k_pbmc.obs[excluded_cell]: 0 true (0%) out of 2638 bools# Extract clean dataset (with filtered cells and genes)\nad = mc.pl.extract_clean_data(ad)\n#> set 3k_pbmc.clean.obs[full_cell_index]: 2638 int32s\n#> set 3k_pbmc.clean.var[full_gene_index]: 16564 int32s"},{"path":"Metacell-construction-chapter.html","id":"building-metacells-1","chapter":"3 Constructing metacells","heading":"3.2.4 Building metacells","text":"","code":""},{"path":"Metacell-construction-chapter.html","id":"defining-lateral-genes","chapter":"3 Constructing metacells","heading":"Defining lateral genes","text":"build metacells, need define lateral genes, genes strong biological signal independent cell-state, e.g. cell-cycle genes.\ngenes ignored computing cells similarity building metacells\nconsidered define outlier cells (.e., expression levels lateral genes consistent within metacells).\nfollowing chunk, consider minimal list lateral genes (provided MC2 authors) including cell-cycle ribosomal genes \nmark MC2 object using mc.pl.mark_lateral_genes() function.genes higher variances expected lead false positive outlier identification.\nUsers can mark genes noisy genes using mc.pl.mark_noisy_genes() function.extend list lateral genes, users can use relate_to_lateral_genes function identify genes highly correlated predefined lateral genes.\nuse function described vignette MC2 authors.","code":"\nLATERAL_GENE_NAMES = [\n    \"ACSM3\", \"ANP32B\", \"APOE\", \"AURKA\", \"B2M\", \"BIRC5\", \"BTG2\", \"CALM1\", \"CD63\", \"CD69\", \"CDK4\",\n    \"CENPF\", \"CENPU\", \"CENPW\", \"CH17-373J23.1\", \"CKS1B\", \"CKS2\", \"COX4I1\", \"CXCR4\", \"DNAJB1\",\n    \"DONSON\", \"DUSP1\", \"DUT\", \"EEF1A1\", \"EEF1B2\", \"EIF3E\", \"EMP3\", \"FKBP4\", \"FOS\", \"FOSB\", \"FTH1\",\n    \"G0S2\", \"GGH\", \"GLTSCR2\", \"GMNN\", \"GNB2L1\", \"GPR183\", \"H2AFZ\", \"H3F3B\", \"HBM\", \"HIST1H1C\",\n    \"HIST1H2AC\", \"HIST1H2BG\", \"HIST1H4C\", \"HLA-A\", \"HLA-B\", \"HLA-C\", \"HLA-DMA\", \"HLA-DMB\",\n    \"HLA-DPA1\", \"HLA-DPB1\", \"HLA-DQA1\", \"HLA-DQB1\", \"HLA-DRA\", \"HLA-DRB1\", \"HLA-E\", \"HLA-F\", \"HMGA1\",\n    \"HMGB1\", \"HMGB2\", \"HMGB3\", \"HMGN2\", \"HNRNPAB\", \"HSP90AA1\", \"HSP90AB1\", \"HSPA1A\", \"HSPA1B\",\n    \"HSPA6\", \"HSPD1\", \"HSPE1\", \"HSPH1\", \"ID2\", \"IER2\", \"IGHA1\", \"IGHA2\", \"IGHD\", \"IGHG1\", \"IGHG2\",\n    \"IGHG3\", \"IGHG4\", \"IGHM\", \"IGKC\", \"IGKV1-12\", \"IGKV1-39\", \"IGKV1-5\", \"IGKV3-15\", \"IGKV4-1\",\n    \"IGLC2\", \"IGLC3\", \"IGLC6\", \"IGLC7\", \"IGLL1\", \"IGLL5\", \"IGLV2-34\", \"JUN\", \"JUNB\", \"KIAA0101\",\n    \"LEPROTL1\", \"LGALS1\", \"LINC01206\", \"LTB\", \"MCM3\", \"MCM4\", \"MCM7\", \"MKI67\", \"MT2A\", \"MYL12A\",\n    \"MYL6\", \"NASP\", \"NFKBIA\", \"NUSAP1\", \"PA2G4\", \"PCNA\", \"PDLIM1\", \"PLK3\", \"PPP1R15A\", \"PTMA\",\n    \"PTTG1\", \"RAN\", \"RANBP1\", \"RGCC\", \"RGS1\", \"RGS2\", \"RGS3\", \"RP11-1143G9.4\", \"RP11-160E2.6\",\n    \"RP11-53B5.1\", \"RP11-620J15.3\", \"RP5-1025A1.3\", \"RP5-1171I10.5\", \"RPS10\", \"RPS10-NUDT3\", \"RPS11\",\n    \"RPS12\", \"RPS13\", \"RPS14\", \"RPS15\", \"RPS15A\", \"RPS16\", \"RPS17\", \"RPS18\", \"RPS19\", \"RPS19BP1\",\n    \"RPS2\", \"RPS20\", \"RPS21\", \"RPS23\", \"RPS24\", \"RPS25\", \"RPS26\", \"RPS27\", \"RPS27A\", \"RPS27L\",\n    \"RPS28\", \"RPS29\", \"RPS3\", \"RPS3A\", \"RPS4X\", \"RPS4Y1\", \"RPS4Y2\", \"RPS5\", \"RPS6\", \"RPS6KA1\",\n    \"RPS6KA2\", \"RPS6KA2-AS1\", \"RPS6KA3\", \"RPS6KA4\", \"RPS6KA5\", \"RPS6KA6\", \"RPS6KB1\", \"RPS6KB2\",\n    \"RPS6KC1\", \"RPS6KL1\", \"RPS7\", \"RPS8\", \"RPS9\", \"RPSA\", \"RRM2\", \"SMC4\", \"SRGN\", \"SRSF7\", \"STMN1\",\n    \"TK1\", \"TMSB4X\", \"TOP2A\", \"TPX2\", \"TSC22D3\", \"TUBA1A\", \"TUBA1B\", \"TUBB\", \"TUBB4B\", \"TXN\", \"TYMS\",\n    \"UBA52\", \"UBC\", \"UBE2C\", \"UHRF1\", \"YBX1\", \"YPEL5\", \"ZFP36\", \"ZWINT\"\n]\nLATERAL_GENE_PATTERNS = [\"RP[LS].*\"]  # Ribosomal\n\n# This will mark as \"lateral_gene\" any genes that match the above, if they exist in the clean dataset.\nmc.pl.mark_lateral_genes(\n    ad,\n    lateral_gene_names=LATERAL_GENE_NAMES,\n    lateral_gene_patterns=LATERAL_GENE_PATTERNS,\n)\n#> set 3k_pbmc.clean.var[lateral_gene]: 225 true (1.358%) out of 16564 bools\nNOISY_GENE_NAMES = [\n    \"CCL3\", \"CCL4\", \"CCL5\", \"CXCL8\", \"DUSP1\", \"FOS\", \"G0S2\", \"HBB\", \"HIST1H4C\", \"IER2\", \"IGKC\",\n    \"IGLC2\", \"JUN\", \"JUNB\", \"KLRB1\", \"MT2A\", \"RPS26\", \"RPS4Y1\", \"TRBC1\", \"TUBA1B\", \"TUBB\"\n]\n# This will mark as \"noisy_gene\" any genes that match the above, if they exist in the clean dataset.\nmc.pl.mark_noisy_genes(ad, noisy_gene_names=NOISY_GENE_NAMES)\n#> set 3k_pbmc.clean.var[noisy_gene]: 17 true (0.1026%) out of 16564 bools"},{"path":"Metacell-construction-chapter.html","id":"define-target_metacell_size-graining-level","chapter":"3 Constructing metacells","heading":"Define target_metacell_size (graining level)","text":"default, MC2 build metacells size 96 cells per metacells.\nUsers can vary target_metacell_size parameter reach desired graining level.","code":"gamma = 25 \ntarget_metacell_size = gamma"},{"path":"Metacell-construction-chapter.html","id":"metacells-identification-using-the-divide-and-conquer-approach","chapter":"3 Constructing metacells","heading":"Metacells identification using the divide and conquer approach","text":"construction metacells MC2 performed using mc.pl.divide_and_conquer_pipeline() function.\nNote default cores system used metacells construction.\nchange behavior adapt number cores MC2 authors propose use mc.pl.guess_max_parallel_piles() mc.pl.set_max_parallel_piles() functions\nadapt number processed parallel depending available memory.mc.pl.divide_and_conquer_pipeline() function associates cell metacell defines cell outlier.\nassignments found obs layer anndata object.following code chunk adds columns (named membership) containing single_cell assignments obs attribute single-cell anndata object.\nmembership information required compute metacells quality metrics shown chapter 4.","code":"max_parallel_piles = mc.pl.guess_max_parallel_piles(ad)\nmc.pl.set_max_parallel_piles(max_parallel_piles)\nmc.pl.divide_and_conquer_pipeline(\n    ad,\n    target_metacell_size = target_metacell_size,\n    random_seed = 123456)\n#> set 3k_pbmc.clean.var[selected_gene]: * -> False\n#> set 3k_pbmc.clean.var[rare_gene]: 0 true (0%) out of 16564 bools\n#> set 3k_pbmc.clean.var[rare_gene_module]: 16564 int32 elements with all outliers (100%)\n#> set 3k_pbmc.clean.obs[cells_rare_gene_module]: 2638 int32 elements with all outliers (100%)\n#> set 3k_pbmc.clean.obs[rare_cell]: 0 true (0%) out of 2638 bools\n#> set 3k_pbmc.clean.var[selected_gene]: 256 true (1.546%) out of 16564 bools\n#> set 3k_pbmc.clean.obs[metacell]: 2638 int32s\n#> set 3k_pbmc.clean.obs[dissolved]: 45 true (1.706%) out of 2638 bools\n#> set 3k_pbmc.clean.obs[metacell_level]: 2638 int32s\n\nad.obs.metacell.head\n#> <bound method NDFrame.head of index\n#> AAACATACAACCAC-1     66\n#> AAACATTGAGCTAC-1     87\n#> AAACATTGATCAGC-1     84\n#> AAACCGTGCTTCCG-1     91\n#> AAACCGTGTATGCG-1    110\n#>                    ... \n#> TTTCGAACTCTCAT-1    112\n#> TTTCTACTGAGGCA-1     74\n#> TTTCTACTTCCTCG-1    113\n#> TTTGCATGAGAGGC-1     57\n#> TTTGCATGCCTCAC-1     82\n#> Name: metacell, Length: 2638, dtype: int32># make a membership -- index of metacells to which single cells belong to \nad.obs['membership'] = [int(i)+1 if i >= 0 else np.nan for i in ad.obs.metacell] "},{"path":"Metacell-construction-chapter.html","id":"retrieve-aggregated-metacell-data-1","chapter":"3 Constructing metacells","heading":"Retrieve aggregated metacell data","text":"function mc.pl.collect_metacells() used subsequently retrieve anndata object containing data metacells level instead single-cell level.\nfunction store X data matrix anndata object matrix gene fraction (.e., sum gene levels metacell sums 1)\nstore total UMIs per gene per metacell layer total_umis.","code":"\nmc_ad = mc.pl.collect_metacells(ad, name='metacells', random_seed = 123456)\n#> set metacells.obs[grouped]: 122 int64s\n#> set metacells.obs[total_umis]: 122 float64s\n#> set metacells.layers[total_umis]: ndarray 122 X 16564 float32s\n#> set metacells.obs[__zeros_downsample_umis]: 122 int64s\n#> set metacells.layers[zeros]: ndarray 122 X 16564 int32s\n#> set 3k_pbmc.clean.obs[metacell_name]: 2638 <U8s\n#> set metacells.var[gene_ids]: 16564 objects\n#> set metacells.var[bursty_lonely_gene]: 0 true (0%) out of 16564 bools\n#> set metacells.var[properly_sampled_gene]: 16564 true (100%) out of 16564 bools\n#> set metacells.var[excluded_gene]: 0 true (0%) out of 16564 bools\n#> set metacells.var[full_gene_index]: 16564 int32s\n#> set metacells.var[lateral_gene]: 225 true (1.358%) out of 16564 bools\n#> set metacells.var[noisy_gene]: 17 true (0.1026%) out of 16564 bools\n#> set metacells.var[selected_gene]: 256 true (1.546%) out of 16564 bools\n#> set metacells.var[rare_gene]: 0 true (0%) out of 16564 bools\n#> set metacells.var[rare_gene_module]: 16564 int32s\n#> set metacells.obs[metacells_rare_gene_module]: 122 int32s\n#> set metacells.obs[rare_metacell]: 0 true (0%) out of 122 bools\n#> set metacells.uns[outliers]: 161\n#> set metacells.uns[metacells_algorithm]: metacells.0.9.0\nmc_ad.shape\n#> (122, 16564)\nmc_ad.X.sum(axis=1)[:5] \n#> matrix([[1.        ],\n#>         [1.        ],\n#>         [1.        ],\n#>         [1.        ],\n#>         [0.99999994]], dtype=float32)\nmc_ad.layers['total_umis']\n#> array([[1., 0., 0., ..., 0., 0., 0.],\n#>        [0., 0., 0., ..., 0., 1., 0.],\n#>        [0., 0., 0., ..., 0., 0., 2.],\n#>        ...,\n#>        [0., 0., 0., ..., 0., 2., 3.],\n#>        [0., 0., 0., ..., 0., 0., 0.],\n#>        [1., 0., 0., ..., 0., 1., 0.]], dtype=float32)"},{"path":"Metacell-construction-chapter.html","id":"annotate-metacells-using-available-annotations-1","chapter":"3 Constructing metacells","heading":"3.2.5 Annotate metacells (using available annotations)","text":"single-cell annotations available original single-cell anndata object. can transfer annotations metacell anndata object\nusing mc.tl.convey_obs_to_group() function associate metacell frequent annotation (categorical) \naveraged annotation (continuous) across single-cells composing metacell\n(use mc.ut.most_frequent np.mean respectively mode paratemer).","code":"# Assign a single value for each metacell based on the cells.\nmc.tl.convey_obs_to_group(\n    adata=ad, gdata=mc_ad,\n    property_name=annotation_label, to_property_name=annotation_label,\n    method=mc.ut.most_frequent  # This is the default, for categorical data\n)\n#> set metacells.obs[louvain]: 122 <U17s\n\n# Compute the fraction of cells with each possible value in each metacell:\nmc.tl.convey_obs_fractions_to_group(  \n    adata=ad, gdata=mc_ad,\n    property_name=annotation_label, to_property_name=annotation_label\n)\n#> set metacells.obs[louvain_fraction_of_B cells]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_CD14+ Monocytes]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_CD4 T cells]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_CD8 T cells]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_Dendritic cells]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_FCGR3A+ Monocytes]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_Megakaryocytes]: 122 float64s\n#> set metacells.obs[louvain_fraction_of_NK cells]: 122 float64s"},{"path":"Metacell-construction-chapter.html","id":"save-output-1","chapter":"3 Constructing metacells","heading":"3.2.6 Save output","text":"future downstream analyses python (section ??), save metacell counts Anndata object:future QCs downstream analyses R (section 6.1), save metacell counts Seurat object:","code":"## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object\nmc_ad.uns = ad.uns.copy()\nmc_ad.uns['sc.obs'] = ad.obs.copy()\n\n# save the requested gamma\nmc_ad.uns['gamma'] = gamma\n\n# save metacell size\nmc_ad.obs.rename(columns={'grouped':'size'}, inplace = True)\n\nprint(\"Saving metacell object for the \"+ proj_name+ \" dataset using \"+ MC_tool)\n#> Saving metacell object for the 3k_pbmc dataset using MC2\nmc_ad.write_h5ad(os.path.join('./data', proj_name, f'metacell_{MC_tool}.h5ad'))\nlibrary(Seurat)\nlibrary(anndata)\nlibrary(reticulate)\nadata_mc <- read_h5ad(paste0(\"data/\", py$proj_name, \"/metacell_MC2.h5ad\"))\n\n# Save counts and metadata in a Seurat object\ncountMatrix <-  Matrix::t(adata_mc$X)\ncolnames(countMatrix) <- adata_mc$obs_names\nrownames(countMatrix) <- adata_mc$var_names\nMC.seurat <- CreateSeuratObject(counts = as(countMatrix, 'CsparseMatrix'), meta.data = as.data.frame(adata_mc$obs))\n#> Warning: Feature names cannot have underscores ('_'), replacing with dashes\n#> ('-')\n#> Warning: Invalid name supplied, making object name syntactically valid. New\n#> object name is\n#> sizetotal_umisX__zeros_downsample_umismetacells_rare_gene_modulerare_metacelllouvainlouvain_fraction_of_B.cellslouvain_fraction_of_CD14..Monocyteslouvain_fraction_of_CD4.T.cellslouvain_fraction_of_CD8.T.cellslouvain_fraction_of_Dendritic.cellslouvain_fraction_of_FCGR3A..Monocyteslouvain_fraction_of_Megakaryocyteslouvain_fraction_of_NK.cells;\n#> see ?make.names for more details on syntax validity\nMC.seurat@misc[[\"var_features\"]] <- rownames(adata_mc$var)[which(adata_mc$var$selected_gene == T)] \n\n# Save membership in misc\nMC.seurat@misc$cell_membership <- py$ad$obs['membership']\nsaveRDS(MC.seurat, file = paste0('./data/', py$proj_name, '/metacell_MC2.rds'))"},{"path":"Metacell-construction-chapter.html","id":"SEACells-construction","chapter":"3 Constructing metacells","heading":"3.3 SEACells (Python)","text":"section, construct metacells using SEACells.","code":""},{"path":"Metacell-construction-chapter.html","id":"method-2","chapter":"3 Constructing metacells","heading":"3.3.1 Method","text":"SEAcells method builds single-cell kNN graph Euclidean distance principal component space (SVD scATAC-seq) space.\nDistances graph transformed affinity applying adaptive Gaussian kernel.\naffinity matrix decomposed archetypes (linear combination cells) membership matrices (cells linear combination archetypes).\nSingle cells assigned given metacell based maximum membership value corresponding archetype.code provided section adapted author’s jupyter notebook.\ninformation method, please refer review (Review?) original paper (Persad et al. 2023).","code":""},{"path":"Metacell-construction-chapter.html","id":"importing-python-packages-1","chapter":"3 Constructing metacells","heading":"Importing python packages","text":"run SEACells, following python packages need imported:don’t packages installed, please refer section 1.1.","code":"import os\nimport pandas as pd\nimport scanpy as sc\nimport SEACells\nimport random"},{"path":"Metacell-construction-chapter.html","id":"data-loading-2","chapter":"3 Constructing metacells","heading":"3.3.2 Data loading","text":"Similarly SuperCell MC2, run SEACells single-cell dataset composed around 3000 peripheral blood mononuclear cells (PBMCs).\nPlease follow section 1.2 retrieve data scanpy package save data following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”.","code":"MC_tool = \"SEACells\"\nproj_name = \"3k_pbmc\"\nad = sc.read(os.path.join(\"data\", proj_name, \"singlecell_anndata_filtered.h5ad\"))"},{"path":"Metacell-construction-chapter.html","id":"filtering-steps-2","chapter":"3 Constructing metacells","heading":"3.3.3 Filtering steps","text":"tutorial, data pre-filterd SEACells perform additionnal filtering.","code":""},{"path":"Metacell-construction-chapter.html","id":"building-metacells-2","chapter":"3 Constructing metacells","heading":"3.3.4 Building metacells","text":"Metacells construction using SEACells requires 2 main inputs: ) anndata object (build_kernel_on parameter), \nii) key indicating matrix obsm attribute anndata object considered compute kernel needed archetypal analysis (build_kernel_on parameter).\nImportant optional inputs : number metacells identify (n_SEACells parameter), used input archetypal analysis,\nii) number neighbors consider knn graph (n_neighbors parameter).","code":""},{"path":"Metacell-construction-chapter.html","id":"data-pre-processing-1","chapter":"3 Constructing metacells","heading":"Data pre-processing","text":"following code chunk saves raw counts filtered data raw attribute anndata object.\nraw counts used later metacells aggregation.build kernel archetypal analysis, SEACells requires lower-dimensionnal embedding data (example using PCA scRNA-Seq data SVD scATAC-Seq data).\nnext code chunk, follow standard pre-processing steps prior PCA computation, .e., data normalization, log transformation, identification highly variable genes.\nPCA components saved obsm attribute anndata object.pre-process single-cell data, using standard pre-processing single-cell RNA-seq data using Scanpy. information, see Scanpy tutorial.","code":"raw_ad = sc.AnnData(ad.X)\nraw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names\nad.raw = raw_ad# Normalize cells, log transform and compute highly variable genes\nsc.pp.normalize_per_cell(ad, 10000)\nsc.pp.log1p(ad)\nsc.pp.highly_variable_genes(ad, n_top_genes=2000)# Compute principal components - \n\nn_comp    = 30\nsc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True)\n\n# Compute UMAP for visualization\n# Here we use 30 components to be consistent with our main tutorial, but fill free to explore other number of principal components to use \n\nsc.pp.neighbors(ad, n_neighbors=15, n_pcs=30)\nsc.tl.umap(ad)"},{"path":"Metacell-construction-chapter.html","id":"setting-up-seacells-parameters","chapter":"3 Constructing metacells","heading":"Setting up SEACells parameters","text":"tutorial, use SEACells model 30 first principal components resulting PCA build knn graph used compute kernel.\nnumber neighbors considered knn graph can fixed using n_neighbors parameter (15).\nmentioned previously, users provide input number metacells required (n_SEACells parameter). number can defined ratio number single cells desired graining level (gamma parameter following code chunk).\nexample, choose graining level 25.","code":"build_kernel_on = 'X_pca' # key in ad.obsm to use for computing metacells\nn_waypoint_eigs = 30      # Number of eigenvalues to consider when initializing metacells\nn_neighbors = 30 # Number of neighbors used for graph construction \ngamma = 25   # the requested graining level\nn_SEACells = int(ad.shape[0]/gamma) # the requested number of metacells  "},{"path":"Metacell-construction-chapter.html","id":"initializing-the-seacells-model","chapter":"3 Constructing metacells","heading":"Initializing the SEACells model","text":"SEACells model initialized previously defined parameters using SEACells.core.SEACells function.Kernel computation performed using mconstruct_kernel_matrix function.Metacells initialized using initialize_archetypes function.\nSEACells archetypes initialization based cells sampling thus stochastic. User can fix seed reproducible results.\ncheck archetypes evenly spread, users can visualize using plot.plot_initialization function.","code":"model = SEACells.core.SEACells(ad,\n                  build_kernel_on = build_kernel_on,\n                  n_SEACells = n_SEACells,\n                  n_waypoint_eigs = n_waypoint_eigs,\n                  n_neighbors = n_neighbors,\n                  convergence_epsilon = 1e-5,\n                  verbose = True)\n#> Welcome to SEACells!model.construct_kernel_matrix()\nM = model.kernel_matrix# set seed for reproducibility\nrandom.seed(123)\n\n# Initialize archetypes\nmodel.initialize_archetypes()\n#> Building kernel on X_pca\n#> Computing diffusion components from X_pca for waypoint initialization ... \n#> Done.\n#> Sampling waypoints ...\n#> Done.\n#> Selecting 78 cells from waypoint initialization.\n#> Initializing residual matrix using greedy column selection\n#> Initializing f and g...\n#> Selecting 27 cells from greedy initialization.\n#> \n#> \n  0%|          | 0/37 [00:00<?, ?it/s]\n 59%|#####9    | 22/37 [00:00<00:00, 213.26it/s]\n100%|##########| 37/37 [00:00<00:00, 217.95it/s]\n# Visualize the initialization \nSEACells.plot.plot_initialization(ad, model, plot_basis='X_umap') "},{"path":"Metacell-construction-chapter.html","id":"fitting-the-seacells-model-to-identify-metacells","chapter":"3 Constructing metacells","heading":"Fitting the SEACells model to identify metacells","text":"identification archetypes iterative process. example, fixed minimum maximum number iteration 10 50 respectively.\ncheck model convergence using plot_convergence function.final archetypes identified, can assign single-cell one metacell (hard assignments).\nassignments (membership) can retrieved using get_hard_assignments function extracted anndata object using ad.obs[\"SEACell\"].\ntutorial, consider hard assignments. However, SEACells package also provides option retrieve soft assignments (multiple weighted assignments cell) using get_soft_assignments function.\ndetails soft assignments, please refer SEACell paper original author’s jupyter notebook.","code":"model.fit(min_iter = 10, max_iter = 100)\n#> Randomly initialized A matrix.\n#> Setting convergence threshold at 0.00109\n#> Starting iteration 1.\n#> Completed iteration 1.\n#> Starting iteration 10.\n#> Completed iteration 10.\n#> Starting iteration 20.\n#> Completed iteration 20.\n#> Starting iteration 30.\n#> Completed iteration 30.\n#> Starting iteration 40.\n#> Completed iteration 40.\n#> Converged after 43 iterations.\nmodel.plot_convergence()membership = model.get_hard_assignments()\nmembership.head\n#> <bound method NDFrame.head of                      SEACell\n#> index                       \n#> AAACATACAACCAC-1  SEACell-26\n#> AAACATTGAGCTAC-1  SEACell-89\n#> AAACATTGATCAGC-1  SEACell-33\n#> AAACCGTGCTTCCG-1  SEACell-84\n#> AAACCGTGTATGCG-1  SEACell-34\n#> ...                      ...\n#> TTTCGAACTCTCAT-1  SEACell-92\n#> TTTCTACTGAGGCA-1  SEACell-21\n#> TTTCTACTTCCTCG-1  SEACell-19\n#> TTTGCATGAGAGGC-1  SEACell-73\n#> TTTGCATGCCTCAC-1  SEACell-72\n#> \n#> [2638 rows x 1 columns]>\nad.obs[\"SEACell\"].head\n#> <bound method NDFrame.head of index\n#> AAACATACAACCAC-1    SEACell-26\n#> AAACATTGAGCTAC-1    SEACell-89\n#> AAACATTGATCAGC-1    SEACell-33\n#> AAACCGTGCTTCCG-1    SEACell-84\n#> AAACCGTGTATGCG-1    SEACell-34\n#>                        ...    \n#> TTTCGAACTCTCAT-1    SEACell-92\n#> TTTCTACTGAGGCA-1    SEACell-21\n#> TTTCTACTTCCTCG-1    SEACell-19\n#> TTTGCATGAGAGGC-1    SEACell-73\n#> TTTGCATGCCTCAC-1    SEACell-72\n#> Name: SEACell, Length: 2638, dtype: object>"},{"path":"Metacell-construction-chapter.html","id":"retrieve-aggregated-metacell-data-2","chapter":"3 Constructing metacells","heading":"Retrieve aggregated metacell data","text":"core.summarize_by_SEACell function can used generate metacell count matrix (aggregation counts across cells belonging metacell).","code":"mc_ad = SEACells.core.summarize_by_SEACell(ad, SEACells_label='SEACell', summarize_layer='raw', celltype_label=annotation_label)\n#> \n  0%|          | 0/105 [00:00<?, ?it/s]\n 59%|#####9    | 62/105 [00:00<00:00, 615.29it/s]\n100%|##########| 105/105 [00:00<00:00, 634.76it/s]"},{"path":"Metacell-construction-chapter.html","id":"annotate-metacells","chapter":"3 Constructing metacells","heading":"Annotate metacells","text":"Note providing annotation celltype_label parameter SEACells.core.summarize_by_SEACell function\nallowed us annotate metacells common cell type metacell.","code":""},{"path":"Metacell-construction-chapter.html","id":"visualize-metacells","chapter":"3 Constructing metacells","heading":"3.3.5 Visualize metacells","text":"visualize metacells, can project metacells single-cell UMAP representation using plot.plot_2D included SEACells package.","code":"SEACells.plot.plot_2D(ad, key='X_umap', colour_metacells=True)"},{"path":"Metacell-construction-chapter.html","id":"save-output-2","chapter":"3 Constructing metacells","heading":"Save output","text":"future downstream analyses python (section ??), save metacell counts Anndata object:future downstream analyses R (section 6.1), save metacell counts Seurat object:","code":"print(\"Saving metacell object for the \"+ proj_name+ \" dataset using \"+ MC_tool)\n#> Saving metacell object for the 3k_pbmc dataset using SEACells\n\n# Save metacell sizes \nlabel_df = ad.obs[['SEACell']].reset_index()\nmc_ad.obs = mc_ad.obs.join(pd.DataFrame(label_df.groupby('SEACell').count().iloc[:, 0]).rename(columns={'index':'size'}))\n\n# save pca used to compute metacells\nmc_ad.uns['var_features']=ad.var_names[ad.var.highly_variable].tolist()\nmc_ad.uns['sc.pca']=ad.obsm['X_pca'] \nmc_ad.uns['sc.umap']=ad.obsm['X_umap'] \nmc_ad.write_h5ad(os.path.join('./data', proj_name, f'metacell_{MC_tool}.h5ad'))\nlibrary(Seurat)\nlibrary(anndata)\nlibrary(reticulate)\nadata_mc <- read_h5ad(paste0(\"data/\", py$proj_name, \"/metacell_SEACells.h5ad\"))\n\n# Save counts and metadata in a Seurat object\ncountMatrix <-  Matrix::t(adata_mc$X)\ncolnames(countMatrix) <- adata_mc$obs_names\nrownames(countMatrix) <- adata_mc$var_names\nMC.seurat <- CreateSeuratObject(counts = as(countMatrix, 'CsparseMatrix'), meta.data = as.data.frame(adata_mc$obs))\n#> Warning: Feature names cannot have underscores ('_'), replacing with dashes\n#> ('-')\n# MC.seurat@misc[[\"sc.pca\"]] <- adata_mc$uns$sc.pca\n# MC.seurat@misc[[\"sc.umap\"]] <- adata_mc$uns$sc.umap\nMC.seurat@misc[[\"var_features\"]] <- adata_mc$uns$var_features \npca.res <- adata_mc$uns$sc.pca\nrownames(pca.res) <- rownames(py$ad$obs)\nMC.seurat@misc$sc.pca <- CreateDimReducObject(\n  embeddings = pca.res,\n  key = \"PC_\",\n  assay = \"RNA\"\n)\n#> Warning: No columnames present in cell embeddings, setting to 'PC_1:30'\n# Save membership in misc\nMC.seurat@misc$cell_membership <- data.frame(row.names = rownames(py$membership), membership = py$membership$SEACell)\nsaveRDS(MC.seurat, file = paste0('./data/', py$proj_name, '/metacell_SEACells.rds'))"},{"path":"QCs.html","id":"QCs","chapter":"4 Metacells QCs","heading":"4 Metacells QCs","text":"Different metrics proposed previous metacell studies evaluate quality metacells.\npropose R package called MetacellToolkit, compute visualize metrics.\npackage also provides function visualize metacells projected single-cell space.Import packages:explore metacells QCs, need load:\n() single-cell data used build metacells \n(ii) metacell data saved Seurat object (see chapter 3).","code":"\n# if(system.file(package='MetacellToolkit') == \"\"){\n#   remotes::install_github(\"GfellerLab/MetacellAnalysisToolkit@dev_ag\", force = TRUE, upgrade = FALSE)\n# } \nlibrary(MetacellAnalysisToolkit)\nlibrary(Seurat)\n# Load the single-cell data \nsc_data = readRDS(paste0(\"data/\", proj_name, \"/singlecell_seurat_filtered.rds\"))\n# Load the metacell data \nmc_data = readRDS(paste0('data/', proj_name, '/metacell_', MC_tool,'.rds'))"},{"path":"QCs.html","id":"quantitative-metrics","chapter":"4 Metacells QCs","heading":"4.1 Quantitative metrics","text":"","code":""},{"path":"QCs.html","id":"purity","chapter":"4 Metacells QCs","heading":"4.1.1 Purity","text":"available, cell annotations can used annotate metacell abundant cell category (e.g. cell type) composing metacell (see chapter 3).\nalso allows us compute metacell purity. annotation considered cell type, purity metacell proportion abundant\ncell type within metacell (Bilous et al. 2022).","code":"\nmc_data$purity <- mc_purity(membership = mc_data@misc$cell_membership$membership, annotation = sc_data@meta.data[, annotation_label])\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"purity\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"purity\", split.by = annotation_label)"},{"path":"QCs.html","id":"compactness","chapter":"4 Metacells QCs","heading":"4.1.2 Compactness","text":"compactness metacell variance components within metacell (Persad et al. 2023).\nlower compactness value better.metric well separation metric computed based low embedding single-cell data (e.g., PCA).\nNote important use embedding used initially construc metacells.\nnext chunk, retrieve principal components computed metacell construction\n(chapter 3 principal components saved Seurat objects containing metacell data)\nrun UMAP visualization.","code":"\nsc_data@reductions[[\"pca\"]] <- mc_data@misc$sc.pca\nsc_data <- RunUMAP(sc_data, reduction = \"pca\", dims = c(1:30), n.neighbors = 15, verbose = F, min.dist = 0.5)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\nUMAPPlot(sc_data, group.by = annotation_label, reduction = \"umap\")\nmembership_df <- mc_data@misc$cell_membership\nmc_data$compactness <- mc_compactness(cell.membership = membership_df, sc.obj = sc_data,\n                                      sc.reduction = \"pca\", n.components = 30, diffusion.components = T)\n#> Computing compactness ...\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"compactness\")\n#> Warning: Removed 15 rows containing non-finite values (`stat_boxplot()`).\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"compactness\", split.by = annotation_label)\n#> Warning: Removed 15 rows containing non-finite values (`stat_boxplot()`)."},{"path":"QCs.html","id":"separation","chapter":"4 Metacells QCs","heading":"4.1.3 Separation","text":"separation metacell distance closest metacell (Persad et al. 2023).\nhigher separation value better.Note compactness separation metrics correlated, better compactness results worse separation vice versa.\nMetacells dense regions better compactness worse separation,\nmetacells sparse regions better separation worse compactness.","code":"\nmc_data$separation <- mc_separation(cell.membership = membership_df, sc.obj = sc_data, sc.reduction = \"pca\", diffusion.components = T)\n#> Computing separation ...\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"separation\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"separation\", split.by = annotation_label)\nlibrary(ggplot2)\nggplot(data.frame(compactness = log(mc_data$compactness), separation = log(mc_data$separation)), \n       aes(x=compactness, y=separation)) + \n  geom_point()+\n  geom_smooth(method=lm) + ggpubr::stat_cor(method = \"spearman\")\n#> `geom_smooth()` using formula = 'y ~ x'\n#> Warning: Removed 15 rows containing non-finite values (`stat_smooth()`).\n#> Warning: Removed 15 rows containing non-finite values (`stat_cor()`).\n#> Warning: Removed 15 rows containing missing values (`geom_point()`)."},{"path":"QCs.html","id":"inv","chapter":"4 Metacells QCs","heading":"4.1.4 INV","text":"inner normalized variance (INV) metacell mean-normalized variance gene expression within metacell (Ben-Kiki et al. 2022).\nlower INV value better.\nNote metric latent-space independent.","code":"\nmc_data$INV <- mc_INV(cell.membership = membership_df, sc.obj = sc_data, group.label = \"membership\")\n#> Counts and data slots are identical.\n#> Normalizing data ...\n#> Computing INV ...\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"INV\")\n#> Warning: Removed 15 rows containing non-finite values (`stat_boxplot()`).\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"INV\", split.by = annotation_label)\n#> Warning: Removed 15 rows containing non-finite values (`stat_boxplot()`)."},{"path":"QCs.html","id":"size-distribution","chapter":"4 Metacells QCs","heading":"4.2 Size distribution","text":"size metacell corresponds number single cells contains.\nhomogeneous metacell size distribution ideal downstream analyses, since larger metacells express genes,\nconfound analyses. heterogeneous size distributions obtained recommend weighted downstream analyses described section 6.2.","code":"\n# Seurat::VlnPlot(mc_data, features = \"size\", pt.size = 2)\n# Seurat::VlnPlot(mc_data, features = \"size\", pt.size = 2, group.by = annotation_label)\nhist(mc_data$size, main = \"Size distribution\", xlab = \"Size\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"size\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"size\", split.by = annotation_label) "},{"path":"QCs.html","id":"representativeness-of-metacells","chapter":"4 Metacells QCs","heading":"4.3 Representativeness of metacells","text":"visualize metacells, can project metacells single-cell UMAP representation using mc_projection() function (adapted plot.plot_2D() SEACells package).\ngood metacell partition reproduce overall structure single-cell data uniformly representing latent space.\nuse function need data single-cell level (least low-dimensional embedding data) single-cell membership metacell.default size metacells dots proportionnal size metacells.\nMetacells can also colored continuous variable one QC metrics computed previous chunks:","code":"\n\nmc_projection(\n  sc.obj = sc_data, \n  mc.obj = mc_data,\n  cell.membership = membership_df,\n  sc.reduction = \"umap\", \n  sc.label = unlist(annotation_label), # single cells will be colored according the sc.label  \n  metacell.label = unlist(annotation_label) # metacells cell will be colored according the metacell.label\n  )\nmc_projection(\n  sc.obj = sc_data, \n  mc.obj = mc_data, \n  cell.membership = membership_df,\n  sc.reduction = \"umap\", \n  sc.label = unlist(annotation_label), # single cells will be colored according the sc.label  \n  continuous_metric = TRUE,\n  metric = \"compactness\"\n  )"},{"path":"command-line.html","id":"command-line","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5 Metacell Analysis Toolkit (MCAT)","text":"provide command line tool allowing users build metacells using either tool (MC2, SuperCell SEACells) provided dataset.\ncommand line tool takes multiple parameters input, e.g., number neighbors considered knn, number components used, graining level.\nexample required benchmark setting.use toolkit analyse differentiating hematopoietic stem cells (Human CD34+).\nNote retrieved RNA data 10X multiome experiment won’t analyse ATAC modality.\nretrieve data, please refer section 1.3.","code":""},{"path":"command-line.html","id":"setting-up-the-environment","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.1 Setting up the environment","text":"","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nSys.setenv(RETICULATE_PYTHON = conda_env)\nlibrary(SuperCell)\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\nlibrary(anndata)\nlibrary(MetacellAnalysisToolkit)\nlibrary(ggplot2)"},{"path":"command-line.html","id":"metacell-building","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.2 Metacell building","text":"use MCAT bash command line build metacells MetaCell2 SuperCell.\ncall MCAT command line, please define path gihub cloned repository optained github repository.","code":""},{"path":"command-line.html","id":"building-metacell-with-metacell2-mc2","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.2.1 Building metacell with MetaCell2 (MC2)","text":"use MetaCell2 (-t MetaCell) identify metacells gamma 50 (-g 50). specify want Seurat .rds object ouput (-s seurat).","code":"MCAT_path=....\n${MCAT_path}/cli/MCAT -t MetaCell -i data/CD34/cd34_multiome_rna.h5ad -o data/CD34/MC2/ -g 50 -s seurat"},{"path":"command-line.html","id":"building-metacell-with-supercell","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.2.2 Building metacell with SuperCell","text":"use SuperCell (-t SuperCell) identify metacells gamma 50 (-g 50). specify want Seurat .rds object ouput (-s seurat).\nuse 2000 highly variable genes (HVGs, -f 2000) compute PCA use 50 components (-n 50) make k = 30 knn (-k 30) graph identify metacells.","code":"MCAT_path=....\n${MCAT_path}/cli/MCAT -t SuperCell -i data/CD34/cd34_multiome_rna.h5ad -o data/CD34/SuperCell/ -f 2000 -g 50 -n 50 -k 30 -s seurat"},{"path":"command-line.html","id":"short-downstream-analysis-of-the-metacells","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.3 Short downstream analysis of the metacells","text":"","code":""},{"path":"command-line.html","id":"metacell2-metacells","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.3.1 MetaCell2 metacells","text":"load object obtained MCATWe Normalize metacells data, identify HVGs, make classical dimensionality reduction (first PCA vizualisation UMAP).Plot results using Seurat.correctly retrieve two main differentiation path CD34+ cells.\none hand, Megakaryocyte Erythrocyte Progenitor (MEP) fate GATA2 GATA1 transcription factor expression.\n, Lymphoid Myeloid Multipotent Progenitor (LMPP) fate SPI1 transcription factor expression.can metacells obtained SuperCellWe load object obtained MCATWe Normalize supercells data, identify HVGs, make classical dimensionality reduction (first PCA vizualisation UMAP).Plot results using Seurat.","code":"\ncd34.metacell <- readRDS(\"data/CD34/MC2/mc_Seurat.rds\")\ncd34.metacell\n#> An object of class Seurat \n#> 12462 features across 140 samples within 1 assay \n#> Active assay: RNA (12462 features, 0 variable features)\ncd34.metacell <- NormalizeData(cd34.metacell)\ncd34.metacell <- FindVariableFeatures(cd34.metacell)\ncd34.metacell <- ScaleData(cd34.metacell)\n#> Centering and scaling data matrix\ncd34.metacell <- RunPCA(cd34.metacell)\n#> PC_ 1 \n#> Positive:  NUP210, MIS18BP1, LCP1, IQGAP1, P4HB, SLC2A4RG, COLGALT1, GRB2, ARHGEF18, BRI3BP \n#>     RBL1, AGTPBP1, GGA2, TTC7A, PTPRE, IL17RA, CLEC12A, SLC4A7, CEP128, ARHGAP26 \n#>     LINC01572, UVRAG, LCORL, LRP8, MAP3K1, PDE3B, UBE2E2, GEN1, NSD2, SND1 \n#> Negative:  RPL34, MEIS1, NKAIN2, CHRM3, LAPTM4B, RPL11, ANGPT1, PRKG1, INPP4B, NRIP1 \n#>     RPS2, PDZD2, CRHBP, GPC5, NPR3, PRKG2, ITGA9, CASC15, BEX2, ST8SIA6 \n#>     YES1, DAPK1, ITGA9-AS1, MSI2, MED12L, NFATC2, HMGA2, RPS18, SLC8A3, CHRM3-AS2 \n#> PC_ 2 \n#> Positive:  TFR2, GATA1, UROD, KLF1, DNPH1, ANK1, TIMM13, PRDX2, XACT, ADAMTS3 \n#>     MYC, EPOR, RYR3, TMEM14C, PLIN2, CNRIP1, KEL, CSF1, PTH2R, CYTOR \n#>     MPST, P2RX5, SPTBN2, ELOVL6, SLC40A1, CXADR, SLC39A3, ZFPM1, NMNAT3, FADS2 \n#> Negative:  AKAP13, VIM, CD74, PRKCB, STK17B, CYTH1, HLA-DQB1, DOCK10, SBF2, RASSF2 \n#>     PRKCE, TSC22D3, PLCB1, CD44, ANKRD44, DST, HDAC9, PDE4B, HLA-DRA, TCF4 \n#>     CALCRL, IDS, TGFBR2, SLCO3A1, POU2F2, AKNA, NEGR1, YPEL5, FYN, COL24A1 \n#> PC_ 3 \n#> Positive:  MYL12A, CARD11, PLP2, CCDC69, LGMN, CTSB, CST3, ARL4C, LIME1, PCED1B \n#>     CYTH4, CDKN2D, IQSEC1, RNASE6, IGFLR1, CYB561A3, NCF1, PCED1B-AS1, SPIB, FAM160A1 \n#>     CCDC50, MPEG1, RUBCNL, CYBB, GABARAP, LY96, UGCG, TGFBI, IGF2R, HLA-DMA \n#> Negative:  ANKRD28, LRMDA, EREG, SNHG25, IRAK3, FNDC3B, PCBP3, CSF3R, RAB44, AZU1 \n#>     GPI, MTUS2, SLC22A15, SLC22A4, DENND3, ATP8B4, ELANE, ERLIN1, MARC1, TENT5A \n#>     SLC36A4, DSTYK, IL1RAP, RFX8, MS4A3, MFSD10, PKP2, CEP170, RAB27A, HGF \n#> PC_ 4 \n#> Positive:  EVI5, TET2, CPQ, FCGRT, SRGN, DENND4A, THEMIS2, RNH1, SUCLG2, PIP5K1B \n#>     NR4A2, S100A6, FAM102B, CD4, FGD4, EMP3, CPPED1, EHBP1L1, NID1, AOAH \n#>     ARHGEF12, PHTF1, GRASP, ZNF385A, PRKCA, RIPOR3, PRKAR2B, SAT1, CHD7, KCNQ1 \n#> Negative:  SMIM24, IGLL1, PHGDH, SPARC, LGALS3BP, ITM2C, MZB1, CD69, IGFBP7, SPINK2 \n#>     LAT2, TMIGD2, C1QTNF4, RPLP1, DOCK1, GYPC, ARMH1, CDK6, ADA, SDK2 \n#>     FLT3, PIK3R1, BAALC, PLCB1, SATB1, LRRC26, ARHGAP25, CYFIP2, LNCAROD, PROM1 \n#> PC_ 5 \n#> Positive:  CIT, C21orf58, NUF2, KIF15, SPC25, DIAPH3, SMC4, NDC80, CDCA5, RRM2 \n#>     ESCO2, CDC25C, DEPDC1B, RTKN2, HIST1H4C, MELK, MFGE8, SKA3, KIF20B, NUSAP1 \n#>     NCAPG, ESPL1, EXO1, TACC3, RRM1, NCAPG2, PLK4, E2F8, KIF11, CDK1 \n#> Negative:  SOX4, ACTG1, MIR181A1HG, LINC00173, MED13L, IGFBP7, IL2RG, HCST, SLC43A2, SATB1 \n#>     ABHD17B, ARPP21, TMSB10, TRPM2, LAT2, DNTT, SLC45A3, MYO1G, S100Z, SMAD7 \n#>     REEP5, RPLP1, LINC01934, TNFRSF21, RBMS3, WDR66, MZB1, COBL, CDK6, MOB1B\ncd34.metacell <- RunUMAP(cd34.metacell,dims = c(1:50),min.dist = 0.5)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\n#> 15:31:12 UMAP embedding parameters a = 0.583 b = 1.334\n#> 15:31:12 Read 140 rows and found 50 numeric columns\n#> 15:31:12 Using Annoy for neighbor search, n_neighbors = 30\n#> 15:31:12 Building Annoy index with metric = cosine, n_trees = 50\n#> 0%   10   20   30   40   50   60   70   80   90   100%\n#> [----|----|----|----|----|----|----|----|----|----|\n#> **************************************************|\n#> 15:31:12 Writing NN index file to temp file /tmp/35398939/RtmpceShhA/file2a870e7114758a\n#> 15:31:12 Searching Annoy index using 1 thread, search_k = 3000\n#> 15:31:12 Annoy recall = 100%\n#> 15:31:13 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n#> 15:31:13 Initializing from normalized Laplacian + noise (using irlba)\n#> 15:31:13 Commencing optimization for 500 epochs, with 4956 positive edges\n#> 15:31:13 Optimization finished\numap.metacell <- UMAPPlot(cd34.metacell,group.by = \"celltype\",label = T)\numap.metacell\ngenes <- c(\"CD34\",\"GATA2\",\"GATA1\",\"SPI1\")\nmarker.metacell.umaps <- lapply(genes, FUN = function(x){\n  plot <- FeaturePlot(cd34.metacell, features = x)\n  }\n)\nmarker.metacell.umaps\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]\ndata <- cbind(umap.metacell$data, cd34.metacell$size)\ncolnames(data)[length(colnames(data))] <- \"size\"\nggplot(data,aes(x= UMAP_1,y=UMAP_2,color = celltype)) + geom_point(aes(size=size)) + theme_classic()\nlapply(marker.metacell.umaps,FUN = function(x){\n  data <- cbind(x$data,cd34.metacell$size)\n  colnames(data)[length(colnames(data))] <- \"size\"\n  gene <- colnames(data)[length(colnames(data))-1]\n  ggplot(data,aes(x= UMAP_1,y=UMAP_2,size=size,colour = .data[[gene]])) + geom_point() + \n    scale_color_gradientn(colors =  c(\"lightgrey\", \"blue\"), \n                          guide = \"colorbar\")  +\n  theme_classic() + ggtitle(gene)\n} )\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]\ncd34.supercell <- readRDS(\"data/CD34/SuperCell/mc_Seurat.rds\")\ncd34.supercell\n#> An object of class Seurat \n#> 12464 features across 138 samples within 1 assay \n#> Active assay: RNA (12464 features, 0 variable features)\ncd34.supercell <- NormalizeData(cd34.supercell)\ncd34.supercell <- FindVariableFeatures(cd34.supercell)\ncd34.supercell <- ScaleData(cd34.supercell)\n#> Centering and scaling data matrix\ncd34.supercell <- RunPCA(cd34.supercell)\n#> PC_ 1 \n#> Positive:  TST, NECTIN1, PCLAF, BLVRB, CD36, S100A6, CCDC26, PPP1R14A, PMP22, ANK1 \n#>     ECE1, KLF1, KEL, PLIN2, KCNH2, ADAMTS3, EPOR, CKS1B, HBD, CSF1 \n#>     PRKAR2B, HES6, GATA1, H2AFX, CXADR, APOC1, CENPM, TFR2, APOE, CSF2RB \n#> Negative:  PRKCH, MIR99AHG, RBPMS, CD109, LINC01122, CRHBP, FAM169A, SCML4, ADGRG6, GUCY1A1 \n#>     ABLIM1, NRIP1, MEIS1, SGCZ, NBEA, TMEM163, RORA, MAGI2, PRDM16, ROBO4 \n#>     FGD5, RABGAP1, RNF220, L3MBTL4, ITGA9, SPTBN1, PTPRM, PROM1, MPPED2, IL12RB2 \n#> PC_ 2 \n#> Positive:  PRKCE, GAS7, SPNS3, HDAC9, AFF3, CRYBG1, CYTH1, NEGR1, RUNX2, LRRFIP1 \n#>     MAP3K8, PDE4B, RASGEF1B, RAB11FIP1, FLT3, PRAG1, FAM107B, ITGAL, TIMP2, SDK2 \n#>     HLA-DMB, PLD4, IRF8, APP, LGALS1, AHNAK, ARL4C, PAG1, ZFP36, TSPOAP1 \n#> Negative:  STON2, TAL1, ZNF385D, MYH10, ALDH1A1, VPS37B, CDC42BPA, SLC40A1, DNAJC6, ST8SIA6 \n#>     CYTL1, UROD, PHTF1, TNIK, ABO, NFIA, PIP5K1B, PDZD2, SORBS1, ZNF385D-AS2 \n#>     TRIM58, ICAM4, XACT, ZFPM1, GATA1, HNRNPLL, ARHGEF12, TFR2, RYR3, MINPP1 \n#> PC_ 3 \n#> Positive:  EXT1, RGS1, CARD11, MAPRE2, P2RY14, TMEM59, LGMN, JCHAIN, CCND3, SETBP1 \n#>     CYTH4, CD37, IGF2R, ITM2B, HLA-DMA, ADAM19, LIME1, IL18R1, PMEPA1, HLA-DRA \n#>     UGCG, HLA-DPA1, RASD1, LINC01226, SLC9A7, CDKN2D, HLA-DPB1, SPIB, FAM160A1, TSBP1 \n#> Negative:  FNDC3B, RAB44, SLC22A4, AZU1, PLPPR3, RFX8, PLD1, RAB27A, LRMDA, ELANE \n#>     PCBP3, HGF, CST7, NT5DC3, C16orf74, CTSG, MTUS2, SLC22A15, YBX3, CFD \n#>     MPO, IL1RAP, MS4A3, SLC1A3, AFF2, PRTN3, LYST, NR6A1, IGFBP2, CSF3R \n#> PC_ 4 \n#> Positive:  IGLL1, PHGDH, LGALS3BP, TSPAN7, SMIM24, PTPRD, NDC80, SKA3, MXD3, BAALC \n#>     SPC25, SPARC, CDKN3, FANCD2, KIF2C, FBXO43, ESCO2, RAD51AP1, CDCA5, CDK1 \n#>     PRDX1, ARHGAP11B, ITGA6, DEPDC1B, MYLK, BAALC-AS1, TPX2, MREG, MYO5C, SPC24 \n#> Negative:  KCNQ1, OSCAR, GRASP, ADAM8, ADAP1, FCGRT, FGD4, KDM7A, CTSH, CD86 \n#>     NR4A2, CD4, ENTPD1, LYZ, VDR, NAMPT, HCK, CSTA, ITGAX, PER1 \n#>     GABARAPL1, MNDA, FAM102B, CFP, ZNF503, TNFAIP2, PPARD, LRP1, NLRP12, RETN \n#> PC_ 5 \n#> Positive:  DNTT, LINC00426, GABPB1-AS1, SCN3A, VPREB1, LTB, LINC01237, ARPP21, MME, PCAT14 \n#>     CD79A, CD96, ERGIC1, CYGB, IL7R, EBF1, LINC00173, CD79B, LINC01934, UMODL1 \n#>     SCAI, ATP1A3, LGALS3BP, C5orf56, RETREG1, SLC43A2, SIDT1, LINC01375, SPON1, COBL \n#> Negative:  AURKB, TOP2A, DEPDC1B, UBE2C, CDCA3, CKAP2L, ASPM, NUSAP1, KIF4A, KIF14 \n#>     KIFC1, PRC1, GTSE1, CIT, KIF18B, NUF2, CDK1, KIF15, KIF11, FOXM1 \n#>     BIRC5, CCNA2, CDC25C, MKI67, TUBB4B, CDCA8, TPX2, CENPE, KIF23, CDCA2\ncd34.supercell <- RunUMAP(cd34.supercell,dims = c(1:50),min.dist = 0.5)\n#> 15:31:18 UMAP embedding parameters a = 0.583 b = 1.334\n#> 15:31:18 Read 138 rows and found 50 numeric columns\n#> 15:31:18 Using Annoy for neighbor search, n_neighbors = 30\n#> 15:31:18 Building Annoy index with metric = cosine, n_trees = 50\n#> 0%   10   20   30   40   50   60   70   80   90   100%\n#> [----|----|----|----|----|----|----|----|----|----|\n#> **************************************************|\n#> 15:31:18 Writing NN index file to temp file /tmp/35398939/RtmpceShhA/file2a870e33935643\n#> 15:31:18 Searching Annoy index using 1 thread, search_k = 3000\n#> 15:31:18 Annoy recall = 100%\n#> 15:31:19 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n#> 15:31:19 Initializing from normalized Laplacian + noise (using irlba)\n#> 15:31:19 Commencing optimization for 500 epochs, with 4504 positive edges\n#> 15:31:19 Optimization finished\numap.supercell <- UMAPPlot(cd34.supercell,group.by = \"celltype\",label = T)\numap.supercell\ngenes <- c(\"CD34\",\"GATA2\",\"GATA1\",\"SPI1\")\nmarker.supercell.umaps <- lapply(genes, FUN = function(x){\n  plot <- FeaturePlot(cd34.supercell, features = x)\n  }\n)\nmarker.supercell.umaps\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]\ndata <- cbind(umap.supercell$data,cd34.supercell$size)\ncolnames(data)[length(colnames(data))] <- \"size\"\nggplot(data,aes(x= UMAP_1,y=UMAP_2,color = celltype)) + geom_point(aes(size=size)) + theme_classic()\nlapply(marker.supercell.umaps,FUN = function(x){\n  data <- cbind(x$data,cd34.supercell$size)\n  colnames(data)[length(colnames(data))] <- \"size\"\n  gene <- colnames(data)[length(colnames(data))-1]\n  ggplot(data,aes(x= UMAP_1,y=UMAP_2,size=size,colour = .data[[gene]])) + geom_point() + \n    scale_color_gradientn(colors =  c(\"lightgrey\", \"blue\"), \n                          guide = \"colorbar\")  +\n  theme_classic() + ggtitle(gene)\n} )\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]"},{"path":"command-line.html","id":"qc-with-the-metacellanalysistoolkit-package","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.4 QC with the MetacellAnalysisToolkit package","text":"","code":""},{"path":"command-line.html","id":"loading-single-cell-data","chapter":"5 Metacell Analysis Toolkit (MCAT)","heading":"5.4.1 Loading single-cell data","text":"First need load single cell data make classical dimentionality reduction analysis.Plot single cell data.Now can plot metacells MetaCell2 single-cell space.metacells obtained SuperCell.can compute compactness separation metacells single cell pca.\nmc_compactnness can use approach SEACells computing metrics diffusion map obtained pca.First MetaCell2 metacellsComparison MetaCell2 SuperCell compactness (lower better).Comparison MetaCell2 SuperCell INV (lower better).","code":"\ncd34.singlecells <- read_h5ad(\"data/CD34/cd34_multiome_rna.h5ad\")\ncd34.singlecells <- CreateSeuratObject(counts = Matrix::t(cd34.singlecells$X),meta.data = cd34.singlecells$obs)\ncd34.singlecells <- NormalizeData(cd34.singlecells)\ncd34.singlecells <- FindVariableFeatures(cd34.singlecells)\ncd34.singlecells <- ScaleData(cd34.singlecells)\n#> Centering and scaling data matrix\ncd34.singlecells <- RunPCA(cd34.singlecells)\n#> PC_ 1 \n#> Positive:  NKAIN2, MEIS1, CRHBP, INPP4B, CALN1, CHRM3, AVP, PCDH9, GPC5, PRKG1 \n#>     ANGPT1, MECOM, MIR99AHG, PRKG2, PBX1, PRKCH, SKAP1, PREX2, ZNF385D, THRB \n#>     IL12A-AS1, RBPMS, HLF, LIMCH1, LINC01122, ST8SIA6, TMEM163, MED12L, CABLES1, PDZD2 \n#> Negative:  DIAPH3, POLQ, RRM2, ASPM, TUBB, MKI67, TOP2A, CIT, TUBA1B, BRIP1 \n#>     NUSAP1, CLSPN, ATAD2, SHCBP1, H2AFZ, STMN1, TMPO, KIF15, NCAPG2, DTL \n#>     CENPF, GTSE1, KNL1, PCLAF, HMGN2, ACTB, UHRF1, ZNF367, MELK, AURKB \n#> PC_ 2 \n#> Positive:  PLCB1, NEGR1, PRKCE, AFF3, ATP8B4, SAMHD1, CD44, UBE2E2, MPO, PTPRE \n#>     TTC7A, FLT3, ARHGAP26, GAS7, VIM, RELL1, AKAP13, RAB11FIP1, RUNX2, HDAC9 \n#>     PLD4, ADGRE5, SLC8A1, KLF6, IRF8, SFMBT2, CD74, RBM47, GAB2, SDK2 \n#> Negative:  ANK1, RYR3, XACT, ITGA2B, APOC1, EEF1A1, TFR2, CPB1, KLF1, RPS3 \n#>     APOE, PTH2R, RPL7A, KCNH2, RPS6, BLVRB, FAM178B, KEL, ZNF385D, GATA1 \n#>     ADAMTS3, SLC40A1, RPS5, EEF1B2, RPS3A, RPL13A, CSF1, RPL8, CNRIP1, HBD \n#> PC_ 3 \n#> Positive:  CD74, HLA-DRA, HLA-DRB1, FAM160A1, ACTG1, JCHAIN, EEF1A1, HLA-DPA1, ARL4C, TGFBI \n#>     BLNK, TMSB4X, SPIB, PLXNA4, RPL13A, LGMN, CORO1A, RPS5, SCT, RPS3 \n#>     RNASE6, RPS3A, LIME1, CUX2, ADAM19, PLD4, CST3, IRF7, CARD11, RPL28 \n#> Negative:  AZU1, FNDC3B, ELANE, MPO, LRMDA, PRTN3, KCNQ5, LYST, AFF2, SLC22A15 \n#>     F13A1, EREG, CFD, PLPPR3, ATP8B4, ZEB2, PCBP3, PDE3B, IL1RAP, ACSM3 \n#>     ZNF804A, CSF3R, SLC39A11, PLD1, DENND4A, ANXA1, CTSG, RREB1, TFRC, DGKG \n#> PC_ 4 \n#> Positive:  SPINK2, CALN1, PLCB1, INPP4B, NKAIN2, ANGPT1, ATP8B4, CHRM3, MEIS1, DIAPH3 \n#>     PHGDH, MIR924HG, SMIM24, MDK, TOP2A, CSF3R, ASPM, C1QTNF4, KIF15, TYMS \n#>     PRKCH, NUSAP1, TUBA1B, RRM2, CIT, TK1, CDCA5, POLQ, NDC80, AURKB \n#> Negative:  SAMHD1, CD36, SULF2, ANK1, FAM160A1, TGFBI, CST3, RYR3, RAB11FIP1, S100A6 \n#>     APOC1, XACT, IRF8, RNASE6, FCER1G, PLXNA4, LYZ, CPB1, APOE, UGCG \n#>     FAM178B, GPR183, CSF2RB, RBM47, PIK3R5, MPEG1, CUX2, MICAL2, SLC8A1, CYBB \n#> PC_ 5 \n#> Positive:  MECOM, PCDH9, PRKG1, ASPM, PLXDC2, THRB, SKAP1, PHTF1, ZNF385D, PRKG2 \n#>     SETBP1, PBX1, GPC5, LIMCH1, TOP2A, MED12L, MKI67, GTSE1, ELL2, PTK2 \n#>     PREX2, CENPE, AURKB, CRHBP, DNM3, KIF18B, NUSAP1, HLF, CIT, DIAPH3 \n#> Negative:  GAPDH, RPS19, IGLL1, RPLP0, C1QTNF4, RPL28, RPL13A, RPL18A, RPS24, EEF1A1 \n#>     GYPC, PRSS57, RPLP2, SMIM24, RPS8, RPL35, MIR181A1HG, RPS3, RPL27A, RPL14 \n#>     RPL7, RPS6, RPL6, RPL8, RPL32, RACK1, ACTG1, RPL29, RPS3A, RPL7A\ncd34.singlecells <- RunUMAP(cd34.singlecells,dims = c(1:50))\n#> 15:31:32 UMAP embedding parameters a = 0.9922 b = 1.112\n#> 15:31:32 Read 6881 rows and found 50 numeric columns\n#> 15:31:32 Using Annoy for neighbor search, n_neighbors = 30\n#> 15:31:32 Building Annoy index with metric = cosine, n_trees = 50\n#> 0%   10   20   30   40   50   60   70   80   90   100%\n#> [----|----|----|----|----|----|----|----|----|----|\n#> **************************************************|\n#> 15:31:32 Writing NN index file to temp file /tmp/35398939/RtmpceShhA/file2a870e5913162a\n#> 15:31:32 Searching Annoy index using 1 thread, search_k = 3000\n#> 15:31:34 Annoy recall = 100%\n#> 15:31:34 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n#> 15:31:35 Initializing from normalized Laplacian + noise (using irlba)\n#> 15:31:35 Commencing optimization for 500 epochs, with 293954 positive edges\n#> 15:31:43 Optimization finished\nUMAPPlot(cd34.singlecells,group.by = \"celltype\",label = T)\nmc_projection(\n  sc.obj = cd34.singlecells,\n  mc.obj = cd34.metacell,\n  cell.membership = cd34.metacell@misc$membership,\n  sc.reduction = \"umap\",\n  sc.label = \"celltype\", # single cells will be colored according the sc.label\n  metacell.label = \"celltype\" # metacells cell will be colored according the metacell.label\n  ) + theme_classic()\nmc_projection(\n  sc.obj = cd34.singlecells,\n  mc.obj = cd34.supercell,\n  cell.membership = cd34.supercell@misc$cell_membership,\n  sc.reduction = \"umap\",\n  sc.label = \"celltype\", # single cells will be colored according the sc.label\n  metacell.label = \"celltype\" # metacells cell will be colored according the metacell.label\n  ) + theme_classic()\ncd34.metacell$compactness <- mc_compactness(cell.membership = cd34.metacell@misc$cell_membership, sc.obj = cd34.singlecells,\n                                      sc.reduction = \"pca\", n.components = 50, diffusion.components = T)\n#> Computing compactness ...\n\nqc_boxplot(mc.obj = cd34.metacell, qc.metrics = \"compactness\")\ncd34.metacell$separation <- mc_separation(cell.membership = cd34.metacell@misc$cell_membership, sc.obj = cd34.singlecells,\n                                      sc.reduction = \"pca\", n.components = 50, diffusion.components = T)\n#> Computing separation ...\n\nqc_boxplot(mc.obj = cd34.metacell, qc.metrics = \"separation\")\ncd34.supercell$compactness <- mc_compactness(cell.membership = cd34.supercell@misc$cell_membership, sc.obj = cd34.singlecells,\n                                      sc.reduction = \"pca\", n.components = 50, diffusion.components = T)\n#> Computing compactness ...\n\nqc_boxplot(mc.obj = cd34.supercell, qc.metrics = \"compactness\")\ncd34.supercell$separation <- mc_separation(cell.membership = cd34.supercell@misc$cell_membership, sc.obj = cd34.singlecells,\n                                      sc.reduction = \"pca\", n.components = 50, diffusion.components = T)\n#> Computing separation ...\n\nqc_boxplot(mc.obj = cd34.supercell, qc.metrics = \"separation\")\ncd34.supercell$INV <- mc_INV(cell.membership = cd34.supercell@misc$cell_membership, sc.obj = cd34.singlecells)\n#> Computing INV ...\ncd34.metacell$INV <- mc_INV(cell.membership = cd34.metacell@misc$cell_membership, sc.obj = cd34.singlecells)\n#> Computing INV ...\ncd34.metacell$tool <- \"MetaCell2\"\ncd34.supercell$tool <- \"SuperCell\"\ndata.metrics <- rbind(cd34.metacell@meta.data[,c(\"tool\",\"INV\",\"compactness\",\"separation\")],\n                      cd34.supercell@meta.data[,c(\"tool\",\"INV\",\"compactness\",\"separation\")])\n\nggplot(data.metrics,aes(y=compactness,x=tool,fill = tool)) + geom_boxplot()\nggplot(data.metrics,aes(y=separation,x=tool,fill = tool)) + geom_boxplot()\nggplot(data.metrics,aes(y=INV,x=tool,fill = tool)) + geom_boxplot()"},{"path":"downstream-analysis-of-metacells.html","id":"downstream-analysis-of-metacells","chapter":"6 Downstream analysis of metacells","heading":"6 Downstream analysis of metacells","text":"chapter, run standard advanced downstream analyses metacells instead single-cell data.\nanalysis, treat metacell single cell, neglecting information size metacell (.e., number containing single cells).\ninterested sample-weighted analysis, metacell size taken account, see section 6.2.","code":""},{"path":"downstream-analysis-of-metacells.html","id":"standard-analysis-R","chapter":"6 Downstream analysis of metacells","heading":"6.1 Standard analysis (R)","text":"tutorial, standard analyses include dimensionality reduction, clustering differential expression using Seurat framework.","code":"\nlibrary(Seurat) \n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\nlibrary(ggplot2)"},{"path":"downstream-analysis-of-metacells.html","id":"load-metacell-seurat-object","chapter":"6 Downstream analysis of metacells","heading":"6.1.1 Load metacell Seurat object","text":"use Seurat objects containing metacells counts data annotation (e.g. cell-type annotation) \nproceed standard Seurat downstream analyses.\nSeurat objects containing metacells counts data annotation generated end sections 3.1\nobjects can also generated using command line described chapter 5","code":"\nMC_tool = \"SuperCell\"\nproj_name = \"3k_pbmc\"\nannotation_column = \"louvain\"\ncelltype_colors <- c(\n  \"CD14+ Monocytes\"    = \"#E69F00\",  # orange\n  \"B cells\"            = \"#56B4E9\",  # sky blue\n  \"CD4 T cells\"        = \"#009E73\",  # bluish green\n  \"NK cells\"           = \"#F0E442\",  # yellow\n  \"CD8 T cells\"        = \"#0072B2\",  # blue\n  \"FCGR3A+ Monocytes\"  = \"#D55E00\",  # vermillion\n  \"Dendritic cells\"    = \"#CC79A7\",  # reddish purple\n  \"Megakaryocytes\"     = \"#000000\"   # black\n)\n\nMC.seurat = readRDS(paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))"},{"path":"downstream-analysis-of-metacells.html","id":"dimensionality-reduction","chapter":"6 Downstream analysis of metacells","heading":"6.1.2 Dimensionality reduction","text":"single-cells, normalize raw counts (aggregated raw counts) identify variable features metacells gene expression data.\nBased features, run PCA use first principal components obtain two dimensionnal representation data using UMAP.","code":"\nIdents(MC.seurat) <- annotation_column\nMC.seurat <- NormalizeData(MC.seurat)\nMC.seurat <- FindVariableFeatures(MC.seurat, selection.method = \"vst\", nfeatures = 2000)\nMC.seurat <- ScaleData(MC.seurat)\n#> Centering and scaling data matrix\nMC.seurat <- RunPCA(MC.seurat, verbose = F)\nMC.seurat <- RunUMAP(MC.seurat, dims = 1:30, verbose = F)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\nDimPlot(MC.seurat, reduction = \"umap\", cols = celltype_colors)"},{"path":"downstream-analysis-of-metacells.html","id":"clustering","chapter":"6 Downstream analysis of metacells","heading":"6.1.3 Clustering","text":"cluster metacells using Seurat clustering steps visualize clusters using UMAP:","code":"\nMC.seurat$SCclustering  <- SuperCell::supercell_cluster(D = dist(MC.seurat@reductions$pca@cell.embeddings[, 1:30]  ), k = 8)$clustering\nDimPlot(MC.seurat, reduction = \"umap\", group.by = \"SCclustering\")"},{"path":"downstream-analysis-of-metacells.html","id":"differential-expression-analysis","chapter":"6 Downstream analysis of metacells","heading":"6.1.4 Differential expression analysis","text":"perform diffrential analysis identify markers cluster 3 example using FindMarkers function.see top marker genes cluster contain Killer cell immunoglobulin-like receptors (KIRs) genes coding \ntransmembrane glycoproteins expressed natural killer cells.can verify identification NK cell cluster comparing metacell annotation metacell clustering.","code":"\n# Set idents to metacell annotation \nIdents(MC.seurat) <- \"SCclustering\"\n\ncells_markers <- FindMarkers(MC.seurat, ident.1 = \"4\", only.pos = TRUE)\n#> For a more efficient implementation of the Wilcoxon Rank Sum Test,\n#> (default method for FindMarkers) please install the limma package\n#> --------------------------------------------\n#> install.packages('BiocManager')\n#> BiocManager::install('limma')\n#> --------------------------------------------\n#> After installation of limma, Seurat will automatically use the more \n#> efficient implementation (no further action necessary).\n#> This message will be shown once per session\nhead(cells_markers)\n#>                p_val avg_log2FC pct.1 pct.2    p_val_adj\n#> LIM2    1.188910e-27  0.4687254 0.467 0.000 3.892253e-23\n#> FASLG   1.281776e-26  0.9488759 0.800 0.036 4.196277e-22\n#> SH2D1B  2.757388e-25  1.4437575 0.933 0.072 9.027137e-21\n#> KIR3DL2 1.480605e-23  1.1403146 0.867 0.068 4.847204e-19\n#> KIR3DL1 3.907898e-23  0.5023381 0.533 0.012 1.279368e-18\n#> PRSS23  6.410015e-22  1.7388849 0.933 0.092 2.098511e-17\ngenes = c(\"KIR3DL2\", \"KIR3DL1\")\nVlnPlot(MC.seurat, genes, ncol = 2, pt.size = 0.0)\np_cluster <- DimPlot(MC.seurat, group.by = \"SCclustering\")\np_annot <- DimPlot(MC.seurat, group.by = annotation_column, cols = celltype_colors)\np_cluster + p_annot"},{"path":"downstream-analysis-of-metacells.html","id":"visualize-gene-gene-correlation","chapter":"6 Downstream analysis of metacells","heading":"6.1.5 Visualize gene-gene correlation","text":"can use supercell_GeneGenePlot function SuperCell package visualize correlation marker genes cell-type:\n() single-cell level \n(ii) metacell level., load single-cell data metacells derived .visualize gene-gene correlation single-cell level:visualize gene-gene correlation metacell level:","code":"\nprint(proj_name)\n#> [1] \"3k_pbmc\"\nsc_data <- readRDS(paste0(\"data/\", proj_name, \"/singlecell_seurat_filtered.rds\"))\nsc_data <- NormalizeData(sc_data, normalization.method = \"LogNormalize\")\ncells_markers <- cells_markers [order(cells_markers$avg_log2FC, decreasing = T),]\ngene_x <- rownames(cells_markers)[1:5]  \ngene_y <- rownames(cells_markers)[6:10]\n\nalpha <- 0.7\n\np.sc <- SuperCell::supercell_GeneGenePlot(\n  GetAssayData(sc_data, slot = \"data\"),\n  gene_x = gene_x,\n  gene_y = gene_y,\n  clusters = sc_data@meta.data[, annotation_column],\n  sort.by.corr = F, \n  alpha = alpha, \n  color.use = celltype_colors\n)\np.sc$p\n\np.MC <- SuperCell::supercell_GeneGenePlot(GetAssayData(MC.seurat, slot = \"data\"),\n                                          gene_x = gene_x,\n                                          gene_y = gene_y,\n                                          clusters = MC.seurat@meta.data[, annotation_column],\n                                          sort.by.corr = F, supercell_size = MC.seurat$size,\n                                          alpha = alpha,\n                                          color.use = celltype_colors)\np.MC$p"},{"path":"downstream-analysis-of-metacells.html","id":"weighted-analysis","chapter":"6 Downstream analysis of metacells","heading":"6.2 Sample-weighted analysis","text":"","code":"\nlibrary(Seurat) \nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(SuperCell)"},{"path":"downstream-analysis-of-metacells.html","id":"load-metacell-seurat-object-1","chapter":"6 Downstream analysis of metacells","heading":"6.2.1 Load metacell Seurat object","text":"use Seurat objects containing metacells counts data annotation (e.g. cell-type annotation) \nproceed downstream analyses considering size metacells.\nSeurat objects containing metacells counts data annotation generated end sections 3.1\nobjects can also generated using command line described chapter 5","code":"\nMC_tool = \"SuperCell\"\nproj_name = \"3k_pbmc\"\nannotation_column = \"louvain\"\ncelltype_colors <- c(\n  \"CD14+ Monocytes\"    = \"#E69F00\",  # orange\n  \"B cells\"            = \"#56B4E9\",  # sky blue\n  \"CD4 T cells\"        = \"#009E73\",  # bluish green\n  \"NK cells\"           = \"#F0E442\",  # yellow\n  \"CD8 T cells\"        = \"#0072B2\",  # blue\n  \"FCGR3A+ Monocytes\"  = \"#D55E00\",  # vermillion\n  \"Dendritic cells\"    = \"#CC79A7\",  # reddish purple\n  \"Megakaryocytes\"     = \"#000000\"   # black\n)\nMC.seurat = readRDS(paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))"},{"path":"downstream-analysis-of-metacells.html","id":"dimensionality-reduction-1","chapter":"6 Downstream analysis of metacells","heading":"6.2.2 Dimensionality reduction","text":"single-cells, normalize raw counts (aggregated raw counts) identify variable features metacells gene expression data.\nBased features, run sample weighted PCA using function supercell_prcomp SuperCell R package\nuse first principal components obtain two dimensionnal representation data using UMAP.\nUsing supercell_DimPlot function SuperCell R package can visualize metacells sized UMAP space.","code":"\nMC.seurat <- NormalizeData(MC.seurat, normalization.method = \"LogNormalize\")\n\nMC_list <- list(N.SC = ncol(MC.seurat),\n                supercell_size = MC.seurat$size)\nMC_list$PCA <- SuperCell::supercell_prcomp(\n  Matrix::t(GetAssayData(MC.seurat, slot = \"data\")),\n  genes.use = MC.seurat@misc$var_features,  # or a new set of HVG can be computed\n  supercell_size = MC_list$supercell_size, # provide this parameter to run sample-weighted version of PCA,\n  k = 30\n)\n\nMC_list$UMAP <- supercell_UMAP(\n  SC = MC_list,\n  PCA_name = \"PCA\",\n  n.comp = 30, n_neighbors = 15\n)\n\nsupercell_DimPlot(SC = MC_list, \n  groups = MC.seurat@meta.data[, annotation_column],\n  dim.name = \"UMAP\", \n  title = paste0(\"UMAP of metacells colored by cell type assignment\"), color.use = celltype_colors\n)"},{"path":"downstream-analysis-of-metacells.html","id":"clustering-1","chapter":"6 Downstream analysis of metacells","heading":"6.2.3 Clustering","text":"cluster metacells using function supercell_cluster SuperCell R package perform clustering step visualize clusters UMAP space:","code":"\n# compute distance among metacells\nD  <- dist(MC_list$PCA$x)\n\n# cluster metacells\nMC_list$SCclustering  <- supercell_cluster(D = D, k = 8, supercell_size = MC_list$supercell_size)\nMC.seurat$SCclustering <- MC_list$SCclustering$clustering\n\n# Plot clustering result\nsupercell_DimPlot(\n  MC_list, \n  groups = factor(MC_list$SCclustering$clustering),\n  dim.name = \"UMAP\", \n  title = paste0(\"UMAP of metacells colored by metacell clustering\")\n)"},{"path":"downstream-analysis-of-metacells.html","id":"differential-expression-analysis-1","chapter":"6 Downstream analysis of metacells","heading":"6.2.4 Differential expression analysis","text":"perform diffrential analysis identify markers clusters using supercell_FindAllMarkers function SuperCell package.select markers cluster 4:visualize top 5 markers cluster 4 see top marker genes cluster contain marker genes natural killer cells GZMB GNLY.","code":"\n# Compute upregulated genes in each cell line (versus other cells)\nMC.all.markers <- supercell_FindAllMarkers(\n  ge = GetAssayData(MC.seurat, slot = \"data\"), \n  clusters = MC_list$SCclustering$clustering, \n  supercell_size = MC_list$supercell_size,\n  only.pos = TRUE, \n  min.pct = 0, \n  logfc.threshold = 0.2\n)\ncluster4_markers <- MC.all.markers[[4]]\nMC.top.markers <- cluster4_markers[order(cluster4_markers$logFC, decreasing = T),]\nIdents(MC.seurat) <- \"SCclustering\"\n# genes.to.plot <- MC.seurat.top.markers$gene[MC.seurat.top.markers$cluster == unique(MC.seurat@meta.data[,annotation_column])[1]]\n# genes.to.plot <- MC.top.markers$gene[c(seq(1, 20, 5))]\ngenes.to.plot <- rownames(MC.top.markers)[1:5]\nVlnPlot(MC.seurat, features = genes.to.plot, ncol = 5, pt.size = 0.0)  \n#> Warning: Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped."},{"path":"integration.html","id":"integration","chapter":"7 Integration of metacells","heading":"7 Integration of metacells","text":"section, work Human Cell Lung Atlas core HLCA\ngathering around 580,000 cells 107 individuals distributed 166 samples.aim tutorial show can use metacells analyze large dataset using reasonable amount time memory.\nuse SuperCell via MCAT command line tool.","code":""},{"path":"integration.html","id":"integration_unsupervised","chapter":"7 Integration of metacells","heading":"7.1 Unsupervised integration","text":"section, first perform integration unsupervised mode, .e., without considering single-cell annotation.\nsupervised version, please refer section @ref(integration_supervised).","code":""},{"path":"integration.html","id":"data-loading-3","chapter":"7 Integration of metacells","heading":"7.1.1 Data loading","text":"Please follow section 1.4 retrieve HLCA atlas, divide atlas dataset save splitted data following folder: “data/HLCA/”.","code":""},{"path":"integration.html","id":"setting-up-the-environment-1","chapter":"7 Integration of metacells","heading":"7.1.2 Setting up the environment","text":"First need specify work MetacellAnalysisToolkit conda environment (needed anndata relying reticulate MCAT tool).\nbuild conda environment please follow instructions MetacellAnalysisToolkit github repository.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nSys.setenv(RETICULATE_PYTHON = conda_env)#>           used (Mb) gc trigger (Mb) max used (Mb)\n#> Ncells  649423 34.7    1512985 80.9   704350 37.7\n#> Vcells 1196992  9.2    8388608 64.0  1814779 13.9\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\nlibrary(anndata)\nlibrary(SuperCell)\nlibrary(ggplot2)\n\ncolor.celltypes  <- c('#E5D2DD', '#53A85F', '#F1BB72', '#F3B1A0', '#D6E7A3', '#57C3F3', '#476D87',\n                      '#E95C59', '#E59CC4', '#AB3282', '#23452F', '#BD956A', '#8C549C', '#585658',\n                      '#9FA3A8', '#E0D4CA', '#5F3D69', '#58A4C3', \"#b20000\",'#E4C755', '#F7F398',\n                      '#AA9A59', '#E63863', '#E39A35', '#C1E6F3', '#6778AE', '#91D0BE', '#B53E2B',\n                      '#712820', '#DCC1DD', '#CCE0F5', '#CCC9E6', '#625D9E', '#68A180', '#3A6963',\n                      '#968175')"},{"path":"integration.html","id":"building-metacell","chapter":"7 Integration of metacells","heading":"7.1.3 Building metacell","text":"build metacells MCAT command line using SuperCell (-t SuperCell).\nfacilitate downstream analysis donors build metacells sample dataset (-sample).\nuse 2000 highly variable genes (-f 2000) compute PCA used 50 principal components (-m 50) build k = 30 (-k 30) nearest neighbor graph metacells identified using graining level 50 (-g 50).\nuse adata .h5ad output format (-s adata) faster write lighter store Seurat .rds object.step takes around 20 min multiple cores (-l 6). aware parallel processing requires memory (32 GB memory required 6 cores).limited memory still able process samples reducing number cores (e.g. -l 3) \nsequentially processing samples (just remove -l) slightly longer time.","code":"start=`date +%s`\nfor d in data/HLCA/datasets/*;\ndo cli/MCAT -t SuperCell -i $d/sc_adata.h5ad -o $d -a sample -l 3 -n 50 -f 2000 -k 30 -g 50 -s adata\ndone\necho \"Duration: $((($(date +%s)-$start)/60)) minutes\""},{"path":"integration.html","id":"loading-metacell-objects","chapter":"7 Integration of metacells","heading":"7.1.4 Loading metacell objects","text":"load .h5ad objects directly convert Seurat objects benefit functions framework.\nconsider datasets order one used tutorial run following chunk loading metacell objects.","code":"\nlibrary(anndata)\nadata <- read_h5ad(\"data/HLCA/local.h5ad\",backed = \"r\")\nadata$var_names <- adata$var$feature_name # We will use gene short name for downstream analyses\ndatasets <- unique(adata$obs$dat)\nrm(adata)\ngc()\n\nmetacell.files <- sapply(datasets, FUN = function(x){paste0(\"data/HLCA/datasets/\",x,\"/mc_adata.h5ad\")})\n\nmetacell.objs <- lapply(X = metacell.files, function(X){\n  adata <- read_h5ad(X)\n  countMatrix <- Matrix::t(adata$X)\n  colnames(countMatrix) <- adata$obs_names\n  rownames(countMatrix) <- adata$var_names\n  sobj <- Seurat::CreateSeuratObject(counts = countMatrix,meta.data = adata$obs)\n  sobj <- RenameCells(sobj, add.cell.id = unique(sobj$sample)) # we give unique name to metacells\n  return(sobj)\n})"},{"path":"integration.html","id":"merging-objects-and-basic-quality-control","chapter":"7 Integration of metacells","heading":"7.1.5 Merging objects and basic quality control","text":"Given single-cell metadata, MCAT tool automatically assigns annotations metacells computes purities categorical variables present\nmetadata input single-cell object.Thus, can check purity metacells different levels annotations, well size (number single cells contain).merge object together use Seurat VlnPlot function.can also use box plots.Overall metacells different datasets present good purity third level annotation.","code":"\nunintegrated.mc <- merge(metacell.objs[[1]], metacell.objs[-1])\n\nVlnPlot(unintegrated.mc, features = c(\"size\", \"ann_level_1_purity\"), group.by = 'dataset', pt.size = 0.001, ncol = 2)\nVlnPlot(unintegrated.mc, features = c(\"ann_level_2_purity\", \"ann_level_3_purity\"), group.by = 'dataset', pt.size = 0.001, ncol = 2)\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_2_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_3_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))"},{"path":"integration.html","id":"unintegrated-analysis","chapter":"7 Integration of metacells","heading":"7.1.6 Unintegrated analysis","text":"Let’s first standard dimensionality reduction without batch correction.can see plots batch effect clearly present metacell level metacells clustering datasets inside major cell types.\nLet’s correct .","code":"\nDefaultAssay(unintegrated.mc) <- \"RNA\"\nunintegrated.mc <- NormalizeData(unintegrated.mc)\nunintegrated.mc <- FindVariableFeatures(unintegrated.mc)\nunintegrated.mc <- ScaleData(unintegrated.mc)\nunintegrated.mc <- RunPCA(unintegrated.mc)\nunintegrated.mc <- RunUMAP(unintegrated.mc, dims = 1:30)\n\numap.unintegrated.datasets <- DimPlot(unintegrated.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"unintegrated datasets\")\numap.unintegrated.types <- DimPlot(unintegrated.mc, reduction = \"umap\", group.by = \"ann_level_2\", label = T, repel = T, cols = color.celltypes)+ NoLegend() + ggtitle(\"unintegrated cell types\")\n\numap.unintegrated.datasets + umap.unintegrated.types\n\nremove(unintegrated.mc) # we won't use the unintegrated object anymore\ngc()"},{"path":"integration.html","id":"seurat-integration","chapter":"7 Integration of metacells","heading":"7.1.7 Seurat integration","text":"use standard Seurat_v4 batch correction workflow. original study, use dataset rather donor batch parameter.\nSee method section “Data integration benchmarking” original study details.take less 5 minutes.Check obtained object.can verify sum metacell sizes corresponds original number single-cellsSeurat returns slot \"integrated\" can use downstream analysis.Now can make plots visually compare results unintegrated analysis.Seurat efficiently corrected batch effect data keeping cell type separated, batch correction methods harmony also done job.Note original study, datasets integrated using SCANVI semi-supervised integration using partial annotation obtained dataset prior integration.\ninterested supervised approach metacell level R can look second example section @ref(integration_supervised) using STACAS package.can navigate different annotation levels.","code":"\n\nn.metacells <- sapply(metacell.objs, FUN = function(x){ncol(x)})\nnames(n.metacells) <- datasets\nref.names <- sort(n.metacells,decreasing = T)[1:5]\nref.index <- which(datasets %in% names(ref.names))\n\n# normalize each dataset\nmetacell.objs <- lapply(X = metacell.objs, FUN = function(x) {\n  DefaultAssay(x) <- \"RNA\";\n  x <- RenameCells(x, add.cell.id = unique(x$sample)) # we give unique name to metacells\n  x <- NormalizeData(x)\n  x <- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000)\n  return(x)})\n\nfeatures <- SelectIntegrationFeatures(object.list = metacell.objs)\n\nmetacell.objs <- lapply(X = metacell.objs, FUN = function(x) {\n    x <- ScaleData(x, features = features, verbose = FALSE)\n    x <- RunPCA(x, features = features, verbose = FALSE)\n})\n\nanchors <- FindIntegrationAnchors(object.list = metacell.objs,\n                                       anchor.features = features,\n                                       reduction = \"rpca\",\n                                       reference = ref.index, # the 5 biggest datasets (in term of metacell number) are used as reference\n                                       dims = 1:30)\n\nremove(metacell.objs) # We don't need the object list anymore\ngc()\n\ncombined.mc <- IntegrateData(anchorset = anchors,k.weight = 40) # we have to update the k.weight parameters because the smallest dataset contain less than 100 metacells\ncombined.mc\n#> An object of class Seurat \n#> 30024 features across 11706 samples within 2 assays \n#> Active assay: integrated (2000 features, 2000 variable features)\n#>  1 other assay present: RNA\nsum(combined.mc$size)\n#> [1] 584944\nDefaultAssay(combined.mc) = \"integrated\"\ncombined.mc <- ScaleData(combined.mc, verbose = FALSE)\ncombined.mc <- RunPCA(combined.mc, npcs = 30, verbose = FALSE)\ncombined.mc <- RunUMAP(combined.mc, reduction = \"pca\", dims = 1:30, verbose = FALSE)\ncombined.mc <- RunUMAP(combined.mc, dims = 1:30,reduction =  \"pca\",reduction.name = \"umap\", verbose = FALSE)\numap.integrated.datasets <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"integrated datasets\")\numap.integrated.celltypes <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"ann_level_2\",label = T,repel = T,cols = color.celltypes) + NoLegend() + ggtitle(\"integrated cell types\")\n\numap.integrated.datasets + umap.integrated.celltypes + umap.unintegrated.datasets + umap.unintegrated.types\nlibrary(ggplot2)\n\nDimPlot(combined.mc,group.by = \"ann_level_1\",reduction = \"umap\",label = T,repel = T,cols= color.celltypes) + NoLegend()\n\nDimPlot(combined.mc,group.by = \"ann_level_2\",reduction = \"umap\",label = T,repel = T,cols= color.celltypes) + NoLegend()\n\nDimPlot(combined.mc,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= color.celltypes) + NoLegend()"},{"path":"integration.html","id":"downstream-analysis","chapter":"7 Integration of metacells","heading":"7.1.8 Downstream analysis","text":"","code":""},{"path":"integration.html","id":"clustering-2","chapter":"7 Integration of metacells","heading":"7.1.8.1 Clustering","text":"cluster metacells based corrected PCA space Seurat.","code":"\nDefaultAssay(combined.mc) <- \"integrated\"\ncombined.mc <- FindNeighbors(combined.mc, reduction = \"pca\", dims = 1:30)\ncombined.mc <- FindClusters(combined.mc, resolution = 0.5)\nUMAPPlot(combined.mc, label = T) + NoLegend()"},{"path":"integration.html","id":"deferentially-expressed-gene-deg-analysis.","chapter":"7 Integration of metacells","heading":"7.1.8.2 Deferentially expressed gene (DEG) analysis.","text":"Now let’s found markers cluster 23 ’ve just identified.cluster clearly presents B cell signature marker genes CD19 PAX5By looking metacell annotation (assigned original single-cell metadata MCAT),\ncan verify correctly retrieved B cell lineage cluster.","code":"\nDefaultAssay(combined.mc) <- \"RNA\"\nmarkers23 <- FindMarkers(combined.mc, ident.1 = 23, only.pos = T)\n#> For a more efficient implementation of the Wilcoxon Rank Sum Test,\n#> (default method for FindMarkers) please install the limma package\n#> --------------------------------------------\n#> install.packages('BiocManager')\n#> BiocManager::install('limma')\n#> --------------------------------------------\n#> After installation of limma, Seurat will automatically use the more \n#> efficient implementation (no further action necessary).\n#> This message will be shown once per session\nhead(markers23)\n#>       p_val avg_log2FC pct.1 pct.2 p_val_adj\n#> TCL1A     0  1.3939674 0.695 0.020         0\n#> FCRLA     0  1.0703400 0.962 0.022         0\n#> BLK       0  1.2192942 0.990 0.058         0\n#> FCRL5     0  0.7934100 0.895 0.026         0\n#> PNOC      0  0.5477793 0.924 0.050         0\n#> PAX5      0  0.6089985 0.886 0.024         0\ngenes <-c(\"CD19\",\"PAX5\") # knwon B cells markers\nmarkers23[genes,]\n#>              p_val avg_log2FC pct.1 pct.2     p_val_adj\n#> CD19 1.599543e-207  1.1037564 0.990 0.114 4.482558e-203\n#> PAX5  0.000000e+00  0.6089985 0.886 0.024  0.000000e+00\nVlnPlot(combined.mc, genes, ncol = 1)\nDimPlot(combined.mc[, combined.mc$integrated_snn_res.0.5 == 23],\n        group.by = c(\"ann_level_3\", \"integrated_snn_res.0.5\"),\n        ncol = 2)"},{"path":"integration.html","id":"cell-type-abundances-analyses.","chapter":"7 Integration of metacells","heading":"7.1.8.3 Cell type abundances analyses.","text":"can easily make analysis cell type abundances different clinical variables construct metacell sample.\ntake metacell size account analyses.\ninstance can analyse proportion different epithelial cell types depending smoking status.Samples smokers seem present AT2 cells quick analysis illustrative purposes .\npractice ’s far complex draw conclusion considered variations samples/donors well many technical\n(tissue dissociation protocol, tissue sampling method, single-cell platform, … ) biological (BMI, sex, Age, …) variables.","code":"\nlibrary(reshape2)\ncombined.mc.epith <- combined.mc[,combined.mc$ann_level_1 == \"Epithelial\"]\n#combined.metacells$major_type <- droplevels(combined.metacells$major_type)\nsmpCounts <- aggregate(combined.mc.epith$size, by=list(sample = combined.mc.epith$sample,\n                                                        major_type = combined.mc.epith$ann_level_3,\n                                                        smoking_status = combined.mc.epith$smoking_status),\n                                                        FUN=sum)\n\nremove(combined.mc.epith)\ngc()\n\nggplot(smpCounts,aes(x = smoking_status,fill=major_type)) + geom_bar(position = \"fill\") + scale_fill_manual(values = color.celltypes) + xlab(\"% epithelial cells\")"},{"path":"integration.html","id":"conclusion","chapter":"7 Integration of metacells","heading":"7.1.9 Conclusion","text":"Overall made precise simplification original atlas using metacells built sample separately.\nreducing size original atlas factor 50 load data, make integration correct batch effect\nrecapitulate main different cell types using reasonable amount time memory.\ncontrast, simply loading original single-cell data R using Seurat extremely time-consuming challenging even powerful computers.first example used fully unsupervised workflow use prior biological knowledge.\nAuthors original study made remarkable work annotating hundreds thousands cells atlas.\nsecond example section @ref(integration_supervised) propose supervised workflow using annotation guide metacell\nidentification batch correction.can save results comparison second example.","code":"\nsaveRDS(combined.mc,\"data/HLCA/combined.mc.unsup.rds\")"},{"path":"integration.html","id":"integration_supervised","chapter":"7 Integration of metacells","heading":"7.2 Supervised integration","text":"unsupervised integration example, work Human Cell Lung Atlas core HLCA\ngathering around 580,000 cells 107 individuals distributed 166 samples.Taking advantage single-cell annotation original study build metacells cell type sample \nguide integration cell type label using STACAS.","code":""},{"path":"integration.html","id":"data-loading-4","chapter":"7 Integration of metacells","heading":"7.2.1 Data loading","text":"Please follow section 1.4 retrieve HLCA atlas, divide atlas dataset save splitted data following folder: “data/HLCA/”.","code":""},{"path":"integration.html","id":"setting-up-the-environment-2","chapter":"7 Integration of metacells","heading":"7.2.2 Setting up the environment","text":"First need specify work MetacellAnalysisToolkit conda environment (needed anndata relying reticulate MCAT tool).\nbuild conda environment please follow instructions MetacellAnalysisToolkit github repository.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nSys.setenv(RETICULATE_PYTHON = conda_env)#>           used  (Mb) gc trigger    (Mb)   max used    (Mb)\n#> Ncells 3555047 189.9    6519942   348.3    6519942   348.3\n#> Vcells 6717400  51.3 1799339657 13727.9 2245660962 17133.1\nlibrary(Seurat)\nlibrary(anndata)\nlibrary(SuperCell)\nlibrary(ggplot2)\n\ncolor.celltypes  <- c('#E5D2DD', '#53A85F', '#F1BB72', '#F3B1A0', '#D6E7A3', '#57C3F3', '#476D87',\n                      '#E95C59', '#E59CC4', '#AB3282', '#23452F', '#BD956A', '#8C549C', '#585658',\n                      '#9FA3A8', '#E0D4CA', '#5F3D69', '#58A4C3', \"#b20000\",'#E4C755', '#F7F398',\n                      '#AA9A59', '#E63863', '#E39A35', '#C1E6F3', '#6778AE', '#91D0BE', '#B53E2B',\n                      '#712820', '#DCC1DD', '#CCE0F5', '#CCC9E6', '#625D9E', '#68A180', '#3A6963',\n                      '#968175')"},{"path":"integration.html","id":"constructing-supervised-metacell","chapter":"7 Integration of metacells","heading":"7.2.3 Constructing supervised metacell","text":"Sikkema et al. made remarkable job finely annotating hundreds thousands cells.\nWithin framework re-analysis, let’s now try use prior knowledge obtain slightly better results using supervised workflow.added section 1.4 ann_sample column metadata single cell object.\nnow can use build metacell cell type sample.limited memory still able process samples reducing number cores (e.g. -l 3) \nsequentially processing samples (just remove -l) slightly longer timeThis take around 30 minutes.","code":"for d in data/HLCA/datasets/*;\ndo cli/MCAT -t SuperCell -i $d/sc_adata.h5ad -o $d/sup_mc -a ann_sample -l 3 -n 50 -f 2000 -k 30 -g 50 -s adata\ndone"},{"path":"integration.html","id":"load-metacell-objects","chapter":"7 Integration of metacells","heading":"7.2.4 Load metacell objects","text":"load .h5ad objects directly convert Seurat objects benefit functions framework.\nconsider datasets order one used tutorial run following chunk loading metacell objects.","code":"\nlibrary(anndata)\nadata <- read_h5ad(\"data/HLCA/local.h5ad\",backed = \"r\")\nadata$var_names <- adata$var$feature_name # We will use gene short name for downstream analyses\ndatasets <- unique(adata$obs$dat)\nrm(adata)\ngc()\n\nmetacell.files <- sapply(datasets, FUN = function(x){paste0(\"data/HLCA/datasets/\",x,\"/sup_mc/mc_adata.h5ad\")})\n\nmetacell.objs <- lapply(X = metacell.files, function(X){\n  adata <- read_h5ad(X)\n  countMatrix <- Matrix::t(adata$X)\n  colnames(countMatrix) <- adata$obs_names\n  rownames(countMatrix) <- adata$var_names\n  sobj <- Seurat::CreateSeuratObject(counts = countMatrix,meta.data = adata$obs)\n  sobj <- RenameCells(sobj, add.cell.id = unique(sobj$sample)) # we give unique name to metacells\n  return(sobj)\n})"},{"path":"integration.html","id":"merging-objects-and-basic-quality-control-1","chapter":"7 Integration of metacells","heading":"7.2.5 Merging objects and basic quality control","text":"Given single-cell metadata, MCAT tool automatically assigns annotations metacells \ncomputes purities categorical variables present metadata input single-cell object.Thus, let’s check purity metacells different level annotations, well size (number single cells contain).merge objects together use Seurat VlnPlot function.can also use box plots.Overall using supervised metacells construction obtain pure metacells 3rd level annotation \nimprove metacell purities finer levels compared unsupervised approach (see previous section @ref(integration_unsupervised)).","code":"\nunintegrated.mc <- merge(metacell.objs[[1]], metacell.objs[-1])\n\nVlnPlot(unintegrated.mc[, unintegrated.mc$ann_level_3 != \"None\"], features = c(\"size\", \"ann_level_2_purity\"), group.by = 'dataset', pt.size = 0.001, ncol = 2)\n#> Warning in SingleExIPlot(type = type, data = data[, x, drop = FALSE], idents =\n#> idents, : All cells have the same value of ann_level_2_purity.\nVlnPlot(unintegrated.mc[, unintegrated.mc$ann_level_3 != \"None\"], features = c(\"ann_level_3_purity\", \"ann_level_4_purity\"), group.by = 'dataset', pt.size = 0.001,  ncol=2)\n#> Warning in SingleExIPlot(type = type, data = data[, x, drop = FALSE], idents =\n#> idents, : All cells have the same value of ann_level_3_purity.\np_4 <- ggplot(unintegrated.mc@meta.data, aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45)) + ggtitle(\"sup metacells level 4 purity\") + NoLegend() + ylim(c(0,1))\n\np_finest <- ggplot(unintegrated.mc@meta.data, aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))  + ggtitle(\"sup metacells finest level purity\") + NoLegend() + ylim(c(0,1))\n\np_4 + p_finest\nmeta.data.unsup <- readRDS(\"data/HLCA/combined.mc.unsup.rds\")@meta.data\n\np_4_unsup <- ggplot(meta.data.unsup, aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() +\n    scale_x_discrete(guide = guide_axis(angle = 45)) + ggtitle(\"unsup metacells level 4 purity\") + NoLegend() + ylim(c(0,1))\n\np_finest_unsup <- ggplot(meta.data.unsup, aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))  + ggtitle(\"unsup metacells finest level purity\") + NoLegend() + ylim(c(0,1))\n\np_4_unsup | p_4\np_finest_unsup + p_finest"},{"path":"integration.html","id":"unintegrated-analysis-1","chapter":"7 Integration of metacells","heading":"7.2.6 Unintegrated analysis","text":"Let’s first standard dimensionality reduction without batch correction.can see plots batch effect clearly present metacell level. Let’s correct using supervised approach.","code":"\nDefaultAssay(unintegrated.mc) <- \"RNA\"\nunintegrated.mc <- NormalizeData(unintegrated.mc)\nunintegrated.mc <- FindVariableFeatures(unintegrated.mc)\nunintegrated.mc <- ScaleData(unintegrated.mc)\nunintegrated.mc <- RunPCA(unintegrated.mc)\nunintegrated.mc <- RunUMAP(unintegrated.mc,dims = 1:30)\n\numap.unintegrated.datasets <- DimPlot(unintegrated.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"unintegrated datasets\")\numap.unintegrated.types <- DimPlot(unintegrated.mc,reduction = \"umap\",group.by = \"ann_level_2\",label = T,repel = T,cols = color.celltypes)+ NoLegend() + ggtitle(\"unintegrated cell types\")\n\numap.unintegrated.datasets + umap.unintegrated.types"},{"path":"integration.html","id":"stacas-integration","chapter":"7 Integration of metacells","heading":"7.2.7 STACAS integration","text":"original study, datasets integrated using SCANVI semi-supervised integration using partial annotation obtained dataset prior integration.\nsecond example propose use similar approach R using STACAS. use “ann” labels used construct metacells (3rd level annotation available cell, otherwise 2nd level).noted , original study, use dataset rather donor batch parameter. See method section Data integration benchmarking original study details.Check obtained object:can verify sum metacell sizes correspond original number single-cellsSTACAS directly returns pca slot \"integrated\" can use make UMAP corrected data.Now can make plots visually compare results unintegrated analysis.STACAS efficiently corrected batch effect data keeping cell type separated.can navigate different annotation levels.","code":"\n# Install package if needed\nif (!requireNamespace(\"STACAS\")) remotes::install_github(\"carmonalab/STACAS\", upgrade = \"never\")\nlibrary(STACAS)\n\nt0_integration <- Sys.time()\n\nn.metacells <- sapply(metacell.objs, FUN = function(x){ncol(x)})\nnames(n.metacells) <- datasets\nref.names <- sort(n.metacells,decreasing = T)[1:5]\nref.index <- which(datasets %in% names(ref.names))\n\n# normalize and identify variable features for each dataset independently\nmetacell.objs <- lapply(X = metacell.objs, FUN = function(x) {\n  DefaultAssay(x) <- \"RNA\";\n  x <- RenameCells(x, add.cell.id = unique(x$sample)) # we give unique name to metacells\n  x <- NormalizeData(x)\n  return(x)})\ngc()\n\n\n# Perform a supervised integration of the dataset using STACAS\ncombined.mc <- Run.STACAS(object.list = metacell.objs,\n                          anchor.features = 2000,\n                          min.sample.size = 80,\n                          k.weight = 80, #smallest dataset contains 86 metacells\n                          cell.labels = \"ann\", # Note that by not you can use STACAS in its unsupervised mode\n                          reference = ref.index, # the 5 biggest datasets are used as reference\n                          dims = 1:30)\n\ntf_integration <- Sys.time()\n\ntf_integration - t0_integration\n\nremove(metacell.objs) # We don't need the object list anymore\ngc()\ncombined.mc\n#> An object of class Seurat \n#> 30024 features across 12914 samples within 2 assays \n#> Active assay: integrated (2000 features, 2000 variable features)\n#>  1 other assay present: RNA\n#>  1 dimensional reduction calculated: pca\nsum(combined.mc$size)\n#> [1] 584944\nDefaultAssay(combined.mc) = \"integrated\"\n\ncombined.mc <- RunUMAP(combined.mc, dims = 1:30, reduction =  \"pca\", reduction.name = \"umap\")\numap.stacas.datasets <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"integrated datasets\")\numap.stacas.celltypes <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"ann_level_2\",label = T,repel = T,cols = color.celltypes) + NoLegend() + ggtitle(\"integrated cell types\")\n\numap.stacas.datasets + umap.stacas.celltypes + umap.unintegrated.datasets + umap.unintegrated.types\nlibrary(ggplot2)\n\nDimPlot(combined.mc,group.by = \"ann_level_1\",reduction = \"umap\",cols= color.celltypes)\n\nDimPlot(combined.mc,group.by = \"ann_level_2\",reduction = \"umap\",label = T,repel = T,cols= color.celltypes)\n\nDimPlot(combined.mc,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= color.celltypes) + NoLegend()"},{"path":"integration.html","id":"comparison-with-unsupervised-analysis","chapter":"7 Integration of metacells","heading":"7.2.8 Comparison with unsupervised analysis","text":"can quickly visually compare results unsupervised integration obtained Seurat:Look epithelial cells particular","code":"\ncombined.mc.unsup <- readRDS(\"data/HLCA/combined.mc.unsup.rds\")\n\ncombined.mc$ann_level_3 <- factor(combined.mc$ann_level_3)\nmatched.color.celltypes <- color.celltypes[1:length(levels(combined.mc$ann_level_3))]\nnames(matched.color.celltypes) <- levels(combined.mc$ann_level_3)\n\nlevel3_sup <- DimPlot(combined.mc,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Sup workflow\")\nlevel3_unsup <- DimPlot(combined.mc.unsup,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Unsup workflow\")\n\nlevel3_sup + level3_unsup\nlevel3_sup <- DimPlot(combined.mc[,combined.mc$ann_level_1 == \"Epithelial\"],group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Sup workflow\")\nlevel3_unsup <- DimPlot(combined.mc.unsup[,combined.mc.unsup$ann_level_1 == \"Epithelial\"],group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Unsup workflow\")\n\nlevel3_sup + level3_unsup"},{"path":"integration.html","id":"downstream-analysis-1","chapter":"7 Integration of metacells","heading":"7.2.9 Downstream analysis","text":"can try conduce downstream analyses previous example @ref(integration_unsupervised) (clustering, cell type abundances, DEG …).show interest supervised workflow pure metacell can zoom smooth muscle sub types. Despite low metacell number cell type different subtypes separated UMAP, especially rare FAM83D+ smooth muscles discovered original study.Using DEG analysis can check retrieve markers. MYH11 CNN1 genes canonical smooth muscle markers FAM83D found uniquely consistently expressed rare cell type original study","code":"\ncombined.mc$ann <- factor(combined.mc$ann)\ncolor.celltypes.ann <- color.celltypes[c(1:length(levels(combined.mc$ann)))]\nnames(color.celltypes.ann) <- levels(combined.mc$ann)\n\nDimPlot(combined.mc[,combined.mc$ann_level_2 == \"Smooth muscle\"],group.by = \"ann\",cols = color.celltypes.ann)\nDefaultAssay(combined.mc) <- \"RNA\"\nIdents(combined.mc) <- \"ann\"\nmarkersSmoothMuscle <- FindMarkers(combined.mc,ident.1 = \"Smooth muscle FAM83D+\",only.pos = T)\n\nhead(markersSmoothMuscle)\n#>               p_val avg_log2FC pct.1 pct.2     p_val_adj\n#> MYOCD 1.889342e-175  1.3869594 0.758 0.022 5.294693e-171\n#> ASB5  1.754802e-130  0.2913375 0.303 0.004 4.917658e-126\n#> NMRK2 1.103717e-129  0.4245135 0.273 0.003 3.093057e-125\n#> PLN   1.568445e-124  3.1280687 0.879 0.044 4.395411e-120\n#> HSPB3 7.379856e-121  1.0364463 0.545 0.016 2.068131e-116\n#> CASQ2 4.376973e-117  1.1063566 0.636 0.023 1.226603e-112\n\nmarkersSmoothMuscle[c(\"MYH11\",\"CNN1\",\"FAM83D\"),]\n#>               p_val avg_log2FC pct.1 pct.2    p_val_adj\n#> MYH11  2.596787e-32   4.248525 0.970 0.287 7.277236e-28\n#> CNN1   7.220235e-71   4.623065 0.970 0.106 2.023399e-66\n#> FAM83D 3.561820e-11   2.186449 0.636 0.285 9.981643e-07\n\n# Many classical smooth muscles cells are not annotated at the 3rd level of annotation (labelled None)\nVlnPlot(combined.mc,features = c(\"MYH11\",\"CNN1\",\"FAM83D\"),group.by = \"ann\",ncol = 2,cols = color.celltypes.ann)"},{"path":"integration.html","id":"conclusion-1","chapter":"7 Integration of metacells","heading":"7.2.10 Conclusion","text":"Taking advantage single cell annotation supervised workflow improve precision metacell re-analysis.\ncell annotations given good quality, far case every time, building metacells accordingly \nuse supervised integration workflow preferred.noted used intermediary level annotation supervise analysis, using finer level data resulted\nlonger time metacell building. PLus, obtained metacells per cell type different sample able \nmake efficient supervised batch correction STACAS.precise cost computational efficiency one also try reduce graining level analysis (using graining level 20 instance),conclude, keep mind one hand, certain analysis rare cell type analysis,\nnever achieve level sensitivity metacells compared single-cells.\nhand, certainly won’t able analyze many single-cells easily, may need extremely fine cell-type resolution many analyses.","code":""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
