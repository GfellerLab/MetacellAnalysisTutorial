[{"path":"index.html","id":"about-this-tutorial","chapter":"About this tutorial","heading":"About this tutorial","text":"tutorial, describe different steps build metacells (Baran et al. 2019) single-cell data using three frameworks:\n. SuperCell (Bilous et al. 2022) (tutorial 1.1),\nii. Metacells version 2 (MC2 (Ben-Kiki et al. 2022)) (tutorial 1.2),\niii. SEACells (Persad et al. 2023) (tutorial 1.3).provide examples downstream analyses (section 3) performed metacell level (e.g clustering, differential analysis, marker identification).also show obtain metacells running methods using command line tool provide part MetacellAnalysisToolkit (MATK) github repository.\nrepository also contains MetacellAnalysisToolkit R package provides R functions compute QC\nmetrics visualization functions evaluate quality metacells.chapter 4, use MATK build metacells continuous dataset CD34+ cells use R package visualize constructed metacells.\nuse MetacellAnalysisToolkit R package visualize evaluate quality metacells described chapter 2 4.Finally, using MATK command line tool, show section 5 can use metacells integrate analyze around 580,000 cells 107 individuals distributed 166 samples.","code":""},{"path":"requirements.html","id":"requirements","chapter":"Requirements","heading":"Requirements","text":"chapter describes obtain packages data needed reproduce analyses performed tutorial.","code":""},{"path":"requirements.html","id":"installations","chapter":"Requirements","heading":"0.1 Installations","text":"","code":""},{"path":"requirements.html","id":"using-conda-recommended","chapter":"Requirements","heading":"0.1.1 Using conda (recommended)","text":"build conda environment containing three metacell building tools used tutorial (SuperCell, MC2 SEACells),\nplease follow instructions provided README MetacellAnalysisToolkit github repository.run following lines define python path use.following R packages also installed.\ntutorial developed Seurat V4 also compatible Seurat V5.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nuse_condaenv(conda_env)\nremotes::install_github(\"GfellerLab/SuperCell\",upgrade = \"never\")\nremotes::install_github(\"GfellerLab/MetacellAnalysisToolkit\",upgrade = \"never\")\nremotes::install_github(\"rstudio/reticulate\",upgrade = \"never\")  #temporary fix for reading sparse matrix with R anndata https://github.com/rstudio/reticulate/issues/141\n#install.packages(\"Seurat\") # uncoment to update Seurat to V5 since V5 not yet on conda\n#BiocManager::install('limma',update = F) # uncoment if Seurat V5 used "},{"path":"requirements.html","id":"without-conda","chapter":"Requirements","heading":"0.1.2 Without conda","text":"don’t conda, can use following instructions:Set python virtual environment MC2 SEACells installed:R, install SuperCell package:run python function R, install reticulate:use python libraries installed virtual environment, define RETICULATE_PYTHON variable follow:following R packages also installed.\ntutorial developed Seurat V4 also compatible Seurat V5.","code":"pip install virtualenv\nvirtualenv my_env\nsource my_env/bin/activate\n\n# Installing SEACells\npip install git+https://github.com/dpeerlab/SEACells\n\n# Install MC2\npip install git+https://github.com/tanaylab/metacells\nremotes::install_github(\"GfellerLab/SuperCell\", upgrade = \"never\")\ninstall.packages('reticulate')echo 'RETICULATE_PYTHON=my_env/bin/python' > '.Renviron'\nremotes::install_github(\"GfellerLab/SuperCell\",upgrade = \"never\")\nremotes::install_github(\"GfellerLab/MetacellAnalysisToolkit\",upgrade = \"never\")\nremotes::install_github(\"rstudio/reticulate\",upgrade = \"never\")  #temporary fix for reading sparse matrix with R anndata https://github.com/rstudio/reticulate/issues/141\n#install.packages(\"Seurat\") # uncoment to update Seurat to V5 since V5 not yet on conda\n#BiocManager::install('limma',update = F) # uncoment if Seurat V5 used "},{"path":"requirements.html","id":"bmcite-data","chapter":"Requirements","heading":"0.2 Retrieve a discrete dataset (Bone marrow dataset)","text":"test metacell construction discrete dataset, retrieved “bmcite” dataset SeauratData R package containing around 30’000 cells.data saved following file future analyses R (use SuperCell): “data/bmcite/singlecell_seurat_filtered.rds”.data saved following file future analyses python (use SEACells MC2): “data/bmcite/singlecell_anndata_filtered.h5ad”.","code":"\nlibrary(SeuratData)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> ── Installed datasets ───────────────────────────────────── SeuratData v0.2.2 ──\n#> ✔ bmcite 0.3.0\n#> ────────────────────────────────────── Key ─────────────────────────────────────\n#> ✔ Dataset loaded successfully\n#> ❯ Dataset built with a newer version of Seurat than installed\n#> ❓ Unknown version of Seurat installed\nInstallData(\"bmcite\")\n#> Warning: The following packages are already installed and will not be\n#> reinstalled: bmcite\n\ndata(\"bmcite\")\nbmcite\n#> An object of class Seurat \n#> 17034 features across 30672 samples within 2 assays \n#> Active assay: RNA (17009 features, 2000 variable features)\n#>  1 other assay present: ADT\n#>  1 dimensional reduction calculated: spca\nhead(bmcite@meta.data)\n#>                      orig.ident nCount_RNA nFeature_RNA nCount_ADT nFeature_ADT\n#> a_AAACCTGAGCTTATCG-1     bmcite       7546         2136       1350           25\n#> a_AAACCTGAGGTGGGTT-1     bmcite       1029          437       2970           25\n#> a_AAACCTGAGTACATGA-1     bmcite       1111          429       2474           23\n#> a_AAACCTGCAAACCTAC-1     bmcite       2741          851       4799           25\n#> a_AAACCTGCAAGGTGTG-1     bmcite       2099          843       5434           25\n#> a_AAACCTGCACGGTAGA-1     bmcite       2291          783       4658           25\n#>                           lane  donor      celltype.l1 celltype.l2 RNA.weight\n#> a_AAACCTGAGCTTATCG-1 HumanHTO4 batch1 Progenitor cells    Prog_RBC  0.4827011\n#> a_AAACCTGAGGTGGGTT-1 HumanHTO1 batch1           T cell         gdT  0.2417890\n#> a_AAACCTGAGTACATGA-1 HumanHTO5 batch1           T cell   CD4 Naive  0.5077136\n#> a_AAACCTGCAAACCTAC-1 HumanHTO3 batch1           T cell  CD4 Memory  0.4313079\n#> a_AAACCTGCAAGGTGTG-1 HumanHTO2 batch1          Mono/DC   CD14 Mono  0.5685085\n#> a_AAACCTGCACGGTAGA-1 HumanHTO6 batch1           B cell     Naive B  0.4255879\nbmcite$celltype_simplified <- plyr::revalue(bmcite$celltype.l2, \n                                            c(\"CD8 Effector_1\" = \"Non-Naive CD8 cell\",\n                                              \"CD8 Effector_2\" = \"Non-Naive CD8 cell\",\n                                              \"CD8 Memory_1\" = \"Non-Naive CD8 cell\",\n                                              \"CD8 Memory_2\" = \"Non-Naive CD8 cell\",\n                                              \"CD8 Naive\" = \"Naive T cell\",\n                                              \"CD4 Naive\" = \"Naive T cell\",\n                                              \"CD4 Memory\" = \"Non-Naive CD4 cell\",\n                                              \"Treg\" = \"Non-Naive CD4 cell\",\n                                              \"Naive B\" = \"B cell\",\n                                              \"Memory B\" = \"B cell\",\n                                              \"CD56 bright NK\" = \"NK\",\n                                              \"MAIT\" = \"Unconventional T\",\n                                              \"gdT\" = \"Unconventional T\",\n                                              \"Prog_B 2\" = \"Prog_B\",\n                                              \"Prog_B 1\" = \"Prog_B\",\n                                              \"Prog_Mk\" = \"MEP\",\n                                              \"Prog_RBC\" = \"MEP\"\n                                              ))\nif(packageVersion(\"Seurat\") >= 5) {\n  bmcite[[\"RNA\"]] <- as(object = bmcite[[\"RNA\"]], Class = \"Assay\")\n}\nsaveRDS(bmcite, file = paste0(\"data/bmcite/singlecell_seurat_filtered.rds\"))\nlibrary(anndata)\nadata <- AnnData(X = Matrix::t(bmcite@assays$RNA@counts),\n                 var = data.frame(genes = rownames(bmcite@assays$RNA@counts)),\n                 obs = bmcite@meta.data)\n\nwrite_h5ad(adata, paste0(\"data/bmcite/singlecell_anndata_filtered.h5ad\"))"},{"path":"requirements.html","id":"CD34-data","chapter":"Requirements","heading":"0.3 Retrieve a continuous dataset (CD34 dataset)","text":"test metacell construction continuous dataset, retrieved CD34 dataset provided (Persad et al. 2023):downloaded file used section 4.","code":"mkdir -p data/CD34\nwget -O data/CD34/cd34_multiome_rna.h5ad 'https://dp-lab-data-public.s3.amazonaws.com/SEACells-multiome/cd34_multiome_rna.h5ad' "},{"path":"requirements.html","id":"HLCA-data","chapter":"Requirements","heading":"0.4 Retrieve the lung atlas dataset","text":"dataset used integration large number single-cell datasets level metacells (see section 5).\nConsidering, large size data download, don’t consider running integration analysis, can skip part tutorial.","code":""},{"path":"requirements.html","id":"HLCA-data-download","chapter":"Requirements","heading":"0.4.1 Downloading the atlas","text":"illustrate metacells can used context single-cell data integration,\nused cell atlas human lung (core) available cellxgene.\ndownload data, please choose .h5ad option clicking download button core atlas (3 tissues, 584’944 cells).Save data data/HLCA/ directory.Please note may take time (~45 mins) file quite large (5.6 GB).","code":""},{"path":"requirements.html","id":"splitting-atlas-by-datasets","chapter":"Requirements","heading":"0.4.2 Splitting atlas by datasets","text":"use anndata read backed mode (saving lot memory) whole atlas write one h5ad file dataset.\ntake less 10 minutes.limited time feel free process subset dataset.","code":"\nt0.split <- Sys.time()\n\nlibrary(anndata)\nadata <- read_h5ad(\"data/HLCA/local.h5ad\",backed = \"r\")\nadata$var_names <- adata$var$feature_name # We will use gene short name for downstream analyses\ndatasets <- unique(adata$obs$dat)\n\n# If you are limited in time you can process on half of the datasets (uncomment th following line)\n# datasets <- datasets[1:7]\n\nprint(dim(adata))\n\nlapply(datasets,FUN =  function(x) {\n  dir.create(paste0(\"data/HLCA/datasets/\",x),recursive = T)\n  adata.dataset <- AnnData(X = adata[adata$obs$dataset == x]$raw$X,\n                           var = adata[adata$obs$dataset == x]$var,\n                           obs = adata[adata$obs$dataset == x]$obs)\n  #This will allow us to construct supervised metacell for each cell type in each sample later in the tutorial\n  adata.dataset$obs$ann <- as.character(adata.dataset$obs$ann_level_3)\n  # For cell without an annotation at the 3rd level we will use the second level of annotation\n  adata.dataset$obs$ann[adata.dataset$obs$ann_level_3 == 'None'] = as.character(adata.dataset$obs$ann_level_2[adata.dataset$obs$ann_level_3 == 'None'])\n  adata.dataset$obs$ann_sample <- paste0(adata.dataset$obs$ann,\"_\",adata.dataset$obs$sample)\n  \n  write_h5ad(adata.dataset,paste0(\"data/HLCA/datasets/\",x,\"/sc_adata.h5ad\"))\n}\n)\n\nremove(adata)\ngc()\n\ntf.split <- Sys.time()\ntf.split - t0.split"},{"path":"introduction-to-the-metacell-concept.html","id":"introduction-to-the-metacell-concept","chapter":"Introduction to the metacell concept","heading":"Introduction to the metacell concept","text":"Metacells correspond partitions single-cell data disjoint homogeneous groups highly similar cells followed aggregation profiles (Baran et al. 2019).\nconcept relies assumption variability within metacells corresponds technical noise biologically relevant heterogeneity.Using metacells enables users : () remove noise preserving enhancing biological signal sparse single-cell genomics data ,\n(ii) address computational challenges due large size data.metacell concept.Several studies built upon metacell concept. tutorial, consider three tools providing standalone metacell construction frameworks \ndescribe different steps followed build metacells using tools:\n() SuperCell (Bilous et al. 2022) (tutorial 1.1), (ii) Metacells version 2 (MC2 (Ben-Kiki et al. 2022)) (tutorial 1.2), (iii) SEACells (Persad et al. 2023) (tutorial 1.3).","code":""},{"path":"Metacell-construction-chapter.html","id":"Metacell-construction-chapter","chapter":"1 Constructing metacells","heading":"1 Constructing metacells","text":"chapter, demonstrate metacell construction using three different methods: SuperCell R, MetaCell-2 (MC2) SEACells Pyhton., first use dataset bone marrow cells SeuratData package. dataset contains around 30K cells example dataset well defined cell types.\nexample continuous data, see chapter 4.2.","code":""},{"path":"Metacell-construction-chapter.html","id":"SuperCell-construction","chapter":"1 Constructing metacells","heading":"1.1 SuperCell (R)","text":"section, construct metacells using R package SuperCell.","code":""},{"path":"Metacell-construction-chapter.html","id":"method","chapter":"1 Constructing metacells","heading":"1.1.1 Method","text":"SuperCell method first reduces gene expression space using principal component analysis (PCA) computes euclidean distances based reduced space.\nUsing euclidean distances, single-cell kNN graph built metacells identified applying walktrap community detection algorithm.\nnumber metacells obtained can chosen user defining graining level parameter.code provided section adapted author’s github documentation.\ninformation method, please refer review (Review?) original paper (Bilous et al. 2022).","code":""},{"path":"Metacell-construction-chapter.html","id":"importing-r-packages","chapter":"1 Constructing metacells","heading":"Importing R packages","text":"run SuperCell, following R package needs imported:","code":"\nif(system.file(package='SuperCell') == \"\"){\n  remotes::install_github(\"GfellerLab/SuperCell\", force = TRUE, upgrade = \"never\")\n} \nlibrary(SuperCell)\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nif(packageVersion(\"Seurat\") >= 5) {options(Seurat.object.assay.version = \"v4\"); print(\"you are using seurat v5 with assay option v4\")}"},{"path":"Metacell-construction-chapter.html","id":"data-loading","chapter":"1 Constructing metacells","heading":"1.1.2 Data loading","text":"run SuperCell single-cell dataset composed around 30’000 bone marrow cells.\nPlease follow section 0.2 retrieve data SeuratData package save data following file: “data/bmcite/singlecell_seurat_filtered.rds”.","code":"\nMC_tool = \"SuperCell\"\nproj_name <- \"bmcite\"\nannotation_label <- \"celltype_simplified\"\n  \ncell_types <- c(\"Unconventional T\", \"Naive T cell\", \"Non-Naive CD4 cell\", \"CD14 Mono\", \"B cell\", \"Non-Naive CD8 cell\",\n                \"NK\", \"GMP\", \"CD16 Mono\", \"pDC\", \"cDC2\", \"Prog_B\", \"Plasmablast\", \"HSC\", \"LMPP\", \"Prog_DC\", \"MEP\")\n\ncelltype_colors <- c(\"#1E88E5\", \"#FFC107\", \"#004D40\", \"#9E9D24\",\n                     \"#F06292\", \"#546E7A\", \"#D4E157\", \"#76FF03\", \n                     \"#26A69A\", \"#AB47BC\", \"#D81B60\", \"#42A5F5\",\n                     \"#2E7D32\", \"#FFA726\", \"#5E35B1\", \"#EF5350\",\"#6D4C41\")\nnames(celltype_colors) <- cell_types\n\nsc_data = readRDS(paste0(\"data/\", proj_name, \"/singlecell_seurat_filtered.rds\"))"},{"path":"Metacell-construction-chapter.html","id":"filtering-steps","chapter":"1 Constructing metacells","heading":"1.1.3 Filtering steps","text":"tutorial, data pre-filtered SuperCell require filtering steps.","code":""},{"path":"Metacell-construction-chapter.html","id":"building-metacells","chapter":"1 Constructing metacells","heading":"1.1.4 Building metacells","text":"Metacells construction using SuperCell requires one main input, .e. matrix log-normalized gene expression data used compute PCA subsequently build knn graph metacells identification.\nImportant optional inputs :\n() graining level (gamma parameter),\n(ii) number neighbors consider knn graph (k.knn parameter),\n(iii) number principal components use generate knn graph (n.pc parameter),\n(iv) number variable genes consider PCA (n.var.genes parameter).","code":""},{"path":"Metacell-construction-chapter.html","id":"data-pre-processing","chapter":"1 Constructing metacells","heading":"Data pre-processing","text":"SuperCell builds knn graph based Euclidean distances defined PCA space.\nPCA computation performed log-normalized gene expression data SCimplify SuperCell function.\nfollowing code chunk, use Seurat normalize visualize data:","code":"\nsc_data <- NormalizeData(sc_data, normalization.method = \"LogNormalize\")\nsc_data <- FindVariableFeatures(sc_data, nfeatures = 2000)\nsc_data <- ScaleData(sc_data)\n#> Centering and scaling data matrix\nsc_data <- RunPCA(sc_data, npcs = 50, verbose = F)\nsc_data <- RunUMAP(sc_data, reduction = \"pca\", dims = c(1:30), n.neighbors = 30, verbose = F)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\nUMAPPlot(sc_data, group.by = annotation_label, cols = celltype_colors)"},{"path":"Metacell-construction-chapter.html","id":"setting-up-supercell-parameters","chapter":"1 Constructing metacells","heading":"Setting up SuperCell parameters","text":"tutorial, run SuperCell using 30 first principal components resulting PCA.\nchose graining level 25 number neighbors 15 knn step.","code":"\ngamma = 50 # the requested graining level.\nk_knn = 30 # the number of neighbors considered to build the knn network.\nnb_var_genes = 2000 # number of the top variable genes to use for dimensionality reduction \nnb_pc = 50 # the number of principal components to use.   "},{"path":"Metacell-construction-chapter.html","id":"metacells-identification","chapter":"1 Constructing metacells","heading":"Metacells identification","text":"metacells identified using SCimplify function SuperCell package.SCimplify returns list containing following main elements:\n() single-cell assignments metacells (membership),\n(ii) metacell sizes (supercell_size),\n(iii) single-cell graph (graph.singlecell),\n(iv) metacell graph (graph.supercells),\n(v) genes used metacell identification (genes.use).","code":"\nMC <- SuperCell::SCimplify(Seurat::GetAssayData(sc_data, slot = \"data\"),  # single-cell log-normalized gene expression data\n                           k.knn = k_knn,\n                           gamma = gamma,\n                           # n.var.genes = nb_var_genes,  \n                           n.pc = nb_pc,\n                           genes.use = Seurat::VariableFeatures(sc_data)\n                           )"},{"path":"Metacell-construction-chapter.html","id":"retrieve-aggregated-metacell-data","chapter":"1 Constructing metacells","heading":"Retrieve aggregated metacell data","text":"supercell_GE() function can used generate metacell counts matrix (aggregation gene expression across cells belonging metacell).\nTwo modes can used single-cell aggregation, .e. averaging log-normalized gene expression summing raw counts (using mode parameter).\nNote provide raw counts aggregation tutorial match aggregation steps using PC2 SEAcells (see 1.2 1.3).\nData normalization thus needed downstream analyses metacell counts matrix.","code":"\nMC.GE <- supercell_GE(Seurat::GetAssayData(sc_data, slot = \"counts\"),\n                      MC$membership,\n                      mode =  \"sum\"\n                      )\ndim(MC.GE) \n#> [1] 17009   613"},{"path":"Metacell-construction-chapter.html","id":"annotate-metacells-using-available-annotations","chapter":"1 Constructing metacells","heading":"1.1.5 Annotate metacells (using available annotations)","text":"can assign metacell particular annotation using supercell_assign() function.\ndefault, function assigns metacell cluster largest Jaccard coefficient avoid biases towards rare abundant clusters.\nAlternatively, assignment can performed using relative (method = \"relative\", may cause biases towards small populations) absolute (method = \"absolute\", may cause biases towards large populations) abundance.SuperCell package provides supercell_plot function visualize metacell network (igraph object number nodes corresponds number metacells),\nstored MC list graph.supercells.\nmetacells can colored respect vector annotation.","code":"\nprint(annotation_label)\n#> [1] \"celltype_simplified\"\nMC$annotation <- supercell_assign(clusters = sc_data@meta.data[, annotation_label], # single-cell annotation\n                                  supercell_membership = MC$membership, # single-cell assignment to metacells\n                                  method = \"absolute\"\n                                  )\n\nhead(MC$annotation)\n#>                    1                    2                    3 \n#> \"Non-Naive CD8 cell\" \"Non-Naive CD8 cell\"               \"LMPP\" \n#>                    4                    5                    6 \n#>             \"B cell\"          \"CD14 Mono\" \"Non-Naive CD4 cell\"\nsupercell_plot(\n  MC$graph.supercells, \n  group = MC$annotation, \n  seed = 1, \n  alpha = -pi/2,\n  main  = \"Metacells colored by cell line assignment\"\n)"},{"path":"Metacell-construction-chapter.html","id":"save-output","chapter":"1 Constructing metacells","heading":"1.1.6 Save output","text":"future downstream analyses R (section 3.1), metacell counts can saved Seurat object.\nalso save Seurat object PCA components genes used SCimplify future QC analysis (See 2).can also use supercell_2_Seurat() function SuperCell package.\nfunction takes inputs metacell count matrix (output SuperCell supercell_GE() function) output SuperCell SCimplify() function\noutput Seurat object containing normalized metacells gene expression data well first (N.comp) principal components PCA performed internally using user defined set genes (default genes used metacells constructions).future downstream analyses python (section 3.2), metacell counts can saved Anndata object:","code":"\ncolnames(MC.GE) <- as.character(1:ncol(MC.GE))\nMC.seurat <- CreateSeuratObject(counts = MC.GE, \n                                meta.data = data.frame(size = as.vector(table(MC$membership)))\n                                )\nMC.seurat[[annotation_label]] <- MC$annotation\n\n# save single-cell membership to metacells in the MC.seurat object\nMC.seurat@misc$cell_membership <- data.frame(row.names = names(MC$membership), membership = MC$membership)\nMC.seurat@misc$var_features <- MC$genes.use \n\n# Save the PCA components and genes used in SCimplify  \nPCA.res <- irlba::irlba(scale(Matrix::t(sc_data@assays$RNA@data[MC$genes.use, ])), nv = nb_pc)\npca.x <- PCA.res$u %*% diag(PCA.res$d)\nrownames(pca.x) <- colnames(sc_data@assays$RNA@data)\nMC.seurat@misc$sc.pca <- CreateDimReducObject(\n  embeddings = pca.x,\n  loadings = PCA.res$v,\n  key = \"PC_\",\n  assay = \"RNA\"\n)\nif(packageVersion(\"Seurat\") >= 5) {\n  MC.seurat[[\"RNA\"]] <- as(object = MC.seurat[[\"RNA\"]], Class = \"Assay\")\n}\nprint(paste0(\"Saving metacell object for the \", proj_name, \" dataset using \", MC_tool))\n#> [1] \"Saving metacell object for the bmcite dataset using SuperCell\"\nsaveRDS(MC.seurat, file = paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))\nMC.seurat <- supercell_2_Seurat(\n  SC.GE = MC.GE,\n  SC = MC,\n  fields = c(\"annotation\", \"supercell_size\"), # elements of MC to save as metacell metadata \n  var.genes = MC$genes.use,\n  N.comp = 10\n)\nif(packageVersion(\"Seurat\") >= 5) {\n  MC.seurat[[\"RNA\"]] <- as(object = MC.seurat[[\"RNA\"]], Class = \"Assay\")\n}\nsaveRDS(MC.seurat, file = paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))\nMC.seurat.ad <- anndata::AnnData(\n  X = Matrix::t(Seurat::GetAssayData(MC.seurat, slot = \"counts\")),\n  obs = MC.seurat@meta.data\n)\n\nanndata::write_h5ad(anndata = MC.seurat.ad, filename = paste0('./data/', proj_name, '/metacell_', MC_tool,'.h5ad'))#>             used   (Mb) gc trigger   (Mb)  max used   (Mb)\n#> Ncells   3494496  186.7   11654105  622.4  14567631  778.0\n#> Vcells 177948554 1357.7  438523727 3345.7 438519104 3345.7"},{"path":"Metacell-construction-chapter.html","id":"MC2-construction","chapter":"1 Constructing metacells","heading":"1.2 MC2 (Python)","text":"section, construct metacells using Metacell-2 (MC2) implemented Python.","code":""},{"path":"Metacell-construction-chapter.html","id":"method-1","chapter":"1 Constructing metacells","heading":"1.2.1 Method","text":"Metacell-2 (MC2) python tool construct metacells updated version MetaCell algorithm, introduced concept metacell.\nMC2 applies two-phase divide--conquer approach. Cells randomly divided piles ~10k cells \ninitial metacells built applying MetaCell-like approach per pile, .e. based single-cell kNN graph built\nlog-normalized counts using set highly variable genes.\n, transcriptionally similar metacells grouped metagroup piles identification final metacells outliers identification.\nNote prior metacell identification, MC2 framework recommends gene filtering steps. choice genes used\nmethod high importance assure good quality metacells.code provided section adapted author’s tutorial.\ninformation method, please refer review (Review?) original paper (Ben-Kiki et al. 2022).","code":""},{"path":"Metacell-construction-chapter.html","id":"importing-python-packages","chapter":"1 Constructing metacells","heading":"Importing python packages","text":"run MC2, following python packages need imported:don’t packages installed, please refer section 0.1.","code":"import os\nimport numpy as np\nimport pandas as pd\nimport anndata as ad\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport metacells as mc"},{"path":"Metacell-construction-chapter.html","id":"data-loading-1","chapter":"1 Constructing metacells","heading":"1.2.2 Data loading","text":"run Metacell-2 (MC2) single-cell dataset composed around 30’000 bone marrow cells.\nPlease follow section 0.2 retrieve data SeuratData package save data following file: “data/bmcite/singlecell_anndata_filtered.h5ad”.initialize name anndata (unstructured annotations) object using mc.ut.set_name() function MC2 package.","code":"MC_tool = \"MC2\"\nproj_name = \"bmcite\"\nannotation_label = 'celltype_simplified'\nad = sc.read(os.path.join(\"data\", proj_name, \"singlecell_anndata_filtered.h5ad\"))\nad.var.index = ad.var.genesmc.ut.set_name(ad, proj_name)"},{"path":"Metacell-construction-chapter.html","id":"filtering-steps-1","chapter":"1 Constructing metacells","heading":"1.2.3 Filtering steps","text":"MC2 requires standard filtering steps doublet filtering performed outside MC2 framework.\naddition standard data filtering steps, MC2 package proposes functions filter single-cell data gene cell level (See author’s vignette).\ngene level, filtering steps consist excluding genes based biological knowledge (e.g. mitochrondrial genes) well based expression levels.\nlatter genes include genes zero expression low expression levels “bursty lonely genes” (.e., genes high expression levels correlation gene).\ncell level, filtering performed based cells UMI counts.","code":""},{"path":"Metacell-construction-chapter.html","id":"gene-filtering","chapter":"1 Constructing metacells","heading":"Gene filtering","text":"following code chunk, exclude genes using mc.pl.exclude_genes()function MC2 package.\nBased authors vignette, consider minimal list genes exclude, .e., sex-specific non-coding genes well mitochondrial genes.\ncomplete list genes, iterative approach can used following guidelines MC2 authors second vignette.\nmc.pl.exclude_genes() function filter :\n) known---excluded genes defined user gene names gene names patterns (EXCLUDED_GENE_NAMES EXCLUDED_GENE_PATTERNS parameters respectively),\nii) “bursty lonely genes”.","code":"EXCLUDED_GENE_NAMES = [\"XIST\", \"MALAT1\", \"NEAT1\"] \nEXCLUDED_GENE_PATTERNS = ['MT-.*']\n\nmc.pl.exclude_genes(\n    ad,\n    excluded_gene_names=EXCLUDED_GENE_NAMES,\n    excluded_gene_patterns=EXCLUDED_GENE_PATTERNS,\n    random_seed=123456\n)\n#> set bmcite.var[bursty_lonely_gene]: 1 true (0.005879%) out of 17009 bools\n#> set bmcite.var[properly_sampled_gene]: 17009 true (100%) out of 17009 bools\n#> set bmcite.var[excluded_gene]: 17 true (0.09995%) out of 17009 bools"},{"path":"Metacell-construction-chapter.html","id":"cell-filtering-based-on-umis-counts","chapter":"1 Constructing metacells","heading":"Cell filtering based on UMIs counts","text":"MC2 framework, cells low high UMI content filtered (PROPERLY_SAMPLED_MIN_CELL_TOTAL, PROPERLY_SAMPLED_MAX_CELL_TOTAL variables defining thresholds next code chunk).\nAlso, cell filtering based UMI counts excluded genes also performed(PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION variable).\nSince dataset pre-filtered, lenient cutoffs used tutorial.\nfollowing code chunk defines parameters.\nadapt datasets, advise explore distributions total UMI counts UMI counts excluded genes, recommended described MC2 original vignette.number UMIs excluded genes computed using mc.tl.compute_excluded_gene_umis() function cells filtered using mc.pl.exclude_cells() function.\nAdditional cells can filtered adding cell description columns obs data frame anndata oject. annotation boolean indicating whether cell filtered .\nname column provided mc.pl.exclude_cells() function via additional_cells_masks parameter.performing two-step filtering (genes cells), “cleaned” data can extracted using mc.pl.extract_clean_data() function.","code":"PROPERLY_SAMPLED_MIN_CELL_TOTAL = 200 \nPROPERLY_SAMPLED_MAX_CELL_TOTAL = 10000 \nPROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION = 0.25mc.tl.compute_excluded_gene_umis(ad)\n\nmc.pl.exclude_cells(\n    ad,\n    properly_sampled_min_cell_total=PROPERLY_SAMPLED_MIN_CELL_TOTAL,\n    properly_sampled_max_cell_total=PROPERLY_SAMPLED_MAX_CELL_TOTAL,\n    properly_sampled_max_excluded_genes_fraction=PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION # ,\n    # additional_cells_masks=[\"|doublet_cell\"]\n)\n#> set bmcite.obs[properly_sampled_cell]: 29581 true (96.44%) out of 30672 bools\n#> set bmcite.obs[excluded_cell]: 1091 true (3.557%) out of 30672 bools# Extract clean dataset (with filtered cells and genes)\nad = mc.pl.extract_clean_data(ad)\n#> set bmcite.clean.obs[full_cell_index]: 29581 int32s\n#> set bmcite.clean.var[full_gene_index]: 16992 int32s"},{"path":"Metacell-construction-chapter.html","id":"building-metacells-1","chapter":"1 Constructing metacells","heading":"1.2.4 Building metacells","text":"","code":""},{"path":"Metacell-construction-chapter.html","id":"defining-lateral-genes","chapter":"1 Constructing metacells","heading":"Defining lateral genes","text":"build metacells, need define lateral genes, genes strong biological signal independent cell-state, e.g. cell-cycle genes.\ngenes ignored computing cells similarity building metacells\nconsidered define outlier cells (.e., expression levels lateral genes consistent within metacells).\nfollowing chunk, consider minimal list lateral genes (provided MC2 authors) including cell-cycle ribosomal genes \nmark MC2 object using mc.pl.mark_lateral_genes() function.genes higher variances expected lead false positive outlier identification.\nUsers can mark genes noisy genes using mc.pl.mark_noisy_genes() function.extend list lateral genes, users can use relate_to_lateral_genes function identify genes highly correlated predefined lateral genes.\nuse function described vignette MC2 authors.","code":"\nLATERAL_GENE_NAMES = [\n    \"ACSM3\", \"ANP32B\", \"APOE\", \"AURKA\", \"B2M\", \"BIRC5\", \"BTG2\", \"CALM1\", \"CD63\", \"CD69\", \"CDK4\",\n    \"CENPF\", \"CENPU\", \"CENPW\", \"CH17-373J23.1\", \"CKS1B\", \"CKS2\", \"COX4I1\", \"CXCR4\", \"DNAJB1\",\n    \"DONSON\", \"DUSP1\", \"DUT\", \"EEF1A1\", \"EEF1B2\", \"EIF3E\", \"EMP3\", \"FKBP4\", \"FOS\", \"FOSB\", \"FTH1\",\n    \"G0S2\", \"GGH\", \"GLTSCR2\", \"GMNN\", \"GNB2L1\", \"GPR183\", \"H2AFZ\", \"H3F3B\", \"HBM\", \"HIST1H1C\",\n    \"HIST1H2AC\", \"HIST1H2BG\", \"HIST1H4C\", \"HLA-A\", \"HLA-B\", \"HLA-C\", \"HLA-DMA\", \"HLA-DMB\",\n    \"HLA-DPA1\", \"HLA-DPB1\", \"HLA-DQA1\", \"HLA-DQB1\", \"HLA-DRA\", \"HLA-DRB1\", \"HLA-E\", \"HLA-F\", \"HMGA1\",\n    \"HMGB1\", \"HMGB2\", \"HMGB3\", \"HMGN2\", \"HNRNPAB\", \"HSP90AA1\", \"HSP90AB1\", \"HSPA1A\", \"HSPA1B\",\n    \"HSPA6\", \"HSPD1\", \"HSPE1\", \"HSPH1\", \"ID2\", \"IER2\", \"IGHA1\", \"IGHA2\", \"IGHD\", \"IGHG1\", \"IGHG2\",\n    \"IGHG3\", \"IGHG4\", \"IGHM\", \"IGKC\", \"IGKV1-12\", \"IGKV1-39\", \"IGKV1-5\", \"IGKV3-15\", \"IGKV4-1\",\n    \"IGLC2\", \"IGLC3\", \"IGLC6\", \"IGLC7\", \"IGLL1\", \"IGLL5\", \"IGLV2-34\", \"JUN\", \"JUNB\", \"KIAA0101\",\n    \"LEPROTL1\", \"LGALS1\", \"LINC01206\", \"LTB\", \"MCM3\", \"MCM4\", \"MCM7\", \"MKI67\", \"MT2A\", \"MYL12A\",\n    \"MYL6\", \"NASP\", \"NFKBIA\", \"NUSAP1\", \"PA2G4\", \"PCNA\", \"PDLIM1\", \"PLK3\", \"PPP1R15A\", \"PTMA\",\n    \"PTTG1\", \"RAN\", \"RANBP1\", \"RGCC\", \"RGS1\", \"RGS2\", \"RGS3\", \"RP11-1143G9.4\", \"RP11-160E2.6\",\n    \"RP11-53B5.1\", \"RP11-620J15.3\", \"RP5-1025A1.3\", \"RP5-1171I10.5\", \"RPS10\", \"RPS10-NUDT3\", \"RPS11\",\n    \"RPS12\", \"RPS13\", \"RPS14\", \"RPS15\", \"RPS15A\", \"RPS16\", \"RPS17\", \"RPS18\", \"RPS19\", \"RPS19BP1\",\n    \"RPS2\", \"RPS20\", \"RPS21\", \"RPS23\", \"RPS24\", \"RPS25\", \"RPS26\", \"RPS27\", \"RPS27A\", \"RPS27L\",\n    \"RPS28\", \"RPS29\", \"RPS3\", \"RPS3A\", \"RPS4X\", \"RPS4Y1\", \"RPS4Y2\", \"RPS5\", \"RPS6\", \"RPS6KA1\",\n    \"RPS6KA2\", \"RPS6KA2-AS1\", \"RPS6KA3\", \"RPS6KA4\", \"RPS6KA5\", \"RPS6KA6\", \"RPS6KB1\", \"RPS6KB2\",\n    \"RPS6KC1\", \"RPS6KL1\", \"RPS7\", \"RPS8\", \"RPS9\", \"RPSA\", \"RRM2\", \"SMC4\", \"SRGN\", \"SRSF7\", \"STMN1\",\n    \"TK1\", \"TMSB4X\", \"TOP2A\", \"TPX2\", \"TSC22D3\", \"TUBA1A\", \"TUBA1B\", \"TUBB\", \"TUBB4B\", \"TXN\", \"TYMS\",\n    \"UBA52\", \"UBC\", \"UBE2C\", \"UHRF1\", \"YBX1\", \"YPEL5\", \"ZFP36\", \"ZWINT\"\n]\nLATERAL_GENE_PATTERNS = [\"RP[LS].*\"]  # Ribosomal\n\n# This will mark as \"lateral_gene\" any genes that match the above, if they exist in the clean dataset.\nmc.pl.mark_lateral_genes(\n    ad,\n    lateral_gene_names=LATERAL_GENE_NAMES,\n    lateral_gene_patterns=LATERAL_GENE_PATTERNS,\n)\n#> set bmcite.clean.var[lateral_gene]: 245 true (1.442%) out of 16992 bools\nNOISY_GENE_NAMES = [\n    \"CCL3\", \"CCL4\", \"CCL5\", \"CXCL8\", \"DUSP1\", \"FOS\", \"G0S2\", \"HBB\", \"HIST1H4C\", \"IER2\", \"IGKC\",\n    \"IGLC2\", \"JUN\", \"JUNB\", \"KLRB1\", \"MT2A\", \"RPS26\", \"RPS4Y1\", \"TRBC1\", \"TUBA1B\", \"TUBB\"\n]\n# This will mark as \"noisy_gene\" any genes that match the above, if they exist in the clean dataset.\nmc.pl.mark_noisy_genes(ad, noisy_gene_names=NOISY_GENE_NAMES)\n#> set bmcite.clean.var[noisy_gene]: 20 true (0.1177%) out of 16992 bools"},{"path":"Metacell-construction-chapter.html","id":"define-target_metacell_size-graining-level","chapter":"1 Constructing metacells","heading":"Define target_metacell_size (graining level)","text":"default, MC2 build metacells size 96 cells per metacells.\nUsers can vary target_metacell_size parameter reach desired graining level.","code":"gamma = 75\ntarget_metacell_size = gamma"},{"path":"Metacell-construction-chapter.html","id":"metacells-identification-using-the-divide-and-conquer-approach","chapter":"1 Constructing metacells","heading":"Metacells identification using the divide and conquer approach","text":"construction metacells MC2 performed using mc.pl.divide_and_conquer_pipeline() function.\nNote default cores system used metacells construction.\nchange behavior adapt number cores MC2 authors propose use mc.pl.guess_max_parallel_piles() mc.pl.set_max_parallel_piles() functions\nadapt number processed parallel depending available memory.mc.pl.divide_and_conquer_pipeline() function associates cell metacell defines cell outlier.\nassignments found obs layer anndata object.following code chunk adds columns (named membership) containing single_cell assignments obs attribute single-cell anndata object.\nmembership information required compute metacells quality metrics shown chapter 2.","code":"max_parallel_piles = mc.pl.guess_max_parallel_piles(ad)\nmc.pl.set_max_parallel_piles(max_parallel_piles)\nmc.pl.divide_and_conquer_pipeline(\n    ad,\n    target_metacell_size = target_metacell_size,\n    random_seed = 123456)\n#> set bmcite.clean.var[selected_gene]: * -> False\n#> set bmcite.clean.var[rare_gene]: 10 true (0.05885%) out of 16992 bools\n#> set bmcite.clean.var[rare_gene_module]: 16982 outliers (99.94%) and 10 grouped (0.05885%) out of 16992 int32 elements with 1 groups with mean size 10\n#> set bmcite.clean.obs[cells_rare_gene_module]: 29562 outliers (99.94%) and 19 grouped (0.06423%) out of 29581 int32 elements with 1 groups with mean size 19\n#> set bmcite.clean.obs[rare_cell]: 19 true (0.06423%) out of 29581 bools\n#> set bmcite.clean.var[selected_gene]: 1807 true (10.63%) out of 16992 bools\n#> set bmcite.clean.obs[metacell]: 29581 int32s\n#> set bmcite.clean.obs[dissolved]: 5 true (0.0169%) out of 29581 bools\n#> set bmcite.clean.obs[metacell_level]: 29581 int32s\n\nad.obs.metacell.head\n#> <bound method NDFrame.head of a_AAACCTGAGCTTATCG-1    382\n#> a_AAACCTGAGGTGGGTT-1    148\n#> a_AAACCTGAGTACATGA-1    286\n#> a_AAACCTGCAAACCTAC-1     84\n#> a_AAACCTGCAAGGTGTG-1    202\n#>                        ... \n#> b_TTTGTCATCCGAGCCA-1    389\n#> b_TTTGTCATCCGTAGGC-1    315\n#> b_TTTGTCATCCTCGCAT-1    208\n#> b_TTTGTCATCGCCGTGA-1    287\n#> b_TTTGTCATCGTTTGCC-1    358\n#> Name: metacell, Length: 29581, dtype: int32># make a membership -- index of metacells to which single cells belong to \nad.obs['membership'] = [int(i)+1 if i >= 0 else np.nan for i in ad.obs.metacell] "},{"path":"Metacell-construction-chapter.html","id":"retrieve-aggregated-metacell-data-1","chapter":"1 Constructing metacells","heading":"Retrieve aggregated metacell data","text":"function mc.pl.collect_metacells() used subsequently retrieve anndata object containing data metacells level instead single-cell level.\nfunction store X data matrix anndata object matrix gene fraction (.e., sum gene levels metacell sums 1)\nstore total UMIs per gene per metacell layer total_umis.","code":"\nmc_ad = mc.pl.collect_metacells(ad, name='metacells', random_seed = 123456)\n#> set metacells.obs[grouped]: 401 int64s\n#> set metacells.obs[total_umis]: 401 float64s\n#> set metacells.layers[total_umis]: ndarray 401 X 16992 float32s\n#> set metacells.obs[__zeros_downsample_umis]: 401 int64s\n#> set metacells.layers[zeros]: ndarray 401 X 16992 int32s\n#> set bmcite.clean.obs[metacell_name]: 29581 <U8s\n#> set metacells.var[genes]: 16992 objects\n#> set metacells.var[bursty_lonely_gene]: 0 true (0%) out of 16992 bools\n#> set metacells.var[properly_sampled_gene]: 16992 true (100%) out of 16992 bools\n#> set metacells.var[excluded_gene]: 0 true (0%) out of 16992 bools\n#> set metacells.var[full_gene_index]: 16992 int32s\n#> set metacells.var[lateral_gene]: 245 true (1.442%) out of 16992 bools\n#> set metacells.var[noisy_gene]: 20 true (0.1177%) out of 16992 bools\n#> set metacells.var[selected_gene]: 1807 true (10.63%) out of 16992 bools\n#> set metacells.var[rare_gene]: 10 true (0.05885%) out of 16992 bools\n#> set metacells.var[rare_gene_module]: 16992 int32s\n#> set metacells.obs[metacells_rare_gene_module]: 401 int32s\n#> set metacells.obs[rare_metacell]: 1 true (0.2494%) out of 401 bools\n#> set metacells.uns[outliers]: 5\n#> set metacells.uns[metacells_algorithm]: metacells.0.9.0\nmc_ad.shape\n#> (401, 16992)\nmc_ad.X.sum(axis=1)[:5] \n#> matrix([[1.],\n#>         [1.],\n#>         [1.],\n#>         [1.],\n#>         [1.]], dtype=float32)\nmc_ad.layers['total_umis']\n#> array([[ 2.,  1.,  0., ...,  0.,  0.,  0.],\n#>        [ 1.,  0.,  0., ...,  0.,  0.,  0.],\n#>        [ 5.,  1.,  0., ...,  0.,  0.,  0.],\n#>        ...,\n#>        [ 5.,  0.,  0., ...,  0.,  0.,  0.],\n#>        [ 2.,  2.,  0., ...,  0.,  0.,  0.],\n#>        [10.,  1.,  0., ...,  0.,  0.,  0.]], dtype=float32)"},{"path":"Metacell-construction-chapter.html","id":"annotate-metacells-using-available-annotations-1","chapter":"1 Constructing metacells","heading":"1.2.5 Annotate metacells (using available annotations)","text":"single-cell annotations available original single-cell anndata object. can transfer annotations metacell anndata object\nusing mc.tl.convey_obs_to_group() function associate metacell frequent annotation (categorical) \naveraged annotation (continuous) across single-cells composing metacell\n(use mc.ut.most_frequent np.mean respectively mode paratemer).","code":"# Assign a single value for each metacell based on the cells.\nmc.tl.convey_obs_to_group(\n    adata=ad, gdata=mc_ad,\n    property_name=annotation_label, to_property_name=annotation_label,\n    method=mc.ut.most_frequent  # This is the default, for categorical data\n)\n#> set metacells.obs[celltype_simplified]: 401 <U18s\n\n# Compute the fraction of cells with each possible value in each metacell:\nmc.tl.convey_obs_fractions_to_group(  \n    adata=ad, gdata=mc_ad,\n    property_name=annotation_label, to_property_name=annotation_label\n)\n#> set metacells.obs[celltype_simplified_fraction_of_B cell]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_CD14 Mono]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_CD16 Mono]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_GMP]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_HSC]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_LMPP]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_MEP]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_NK]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Naive T cell]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Non-Naive CD4 cell]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Non-Naive CD8 cell]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Plasmablast]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Prog_B]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Prog_DC]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_Unconventional T]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_cDC2]: 401 float64s\n#> set metacells.obs[celltype_simplified_fraction_of_pDC]: 401 float64s"},{"path":"Metacell-construction-chapter.html","id":"save-output-1","chapter":"1 Constructing metacells","heading":"1.2.6 Save output","text":"future downstream analyses python (section 3.2), save metacell counts Anndata object:future QCs downstream analyses R (section 3.1), save metacell counts Seurat object:","code":"## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object\nmc_ad.uns = ad.uns.copy()\nmc_ad.uns['sc.obs'] = ad.obs.copy()\n\n# save the requested gamma\nmc_ad.uns['gamma'] = gamma\n\n# save metacell size\nmc_ad.obs.rename(columns={'grouped':'size'}, inplace = True)\n\nprint(\"Saving metacell object for the \"+ proj_name+ \" dataset using \"+ MC_tool)\n#> Saving metacell object for the bmcite dataset using MC2\nmc_ad.write_h5ad(os.path.join('./data', proj_name, f'metacell_{MC_tool}.h5ad'))\nlibrary(Seurat)\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nif(packageVersion(\"Seurat\") >= 5) {options(Seurat.object.assay.version = \"v4\"); print(\"you are using seurat v5 with assay option v4\")}\nlibrary(anndata)\nlibrary(reticulate)\n\nadata_mc <- read_h5ad(paste0(\"data/\", py$proj_name, \"/metacell_MC2.h5ad\"))\n\n# Save counts and metadata in a Seurat object\ncountMatrix <-  Matrix::t(adata_mc$X)\ncolnames(countMatrix) <- adata_mc$obs_names\nrownames(countMatrix) <- adata_mc$var_names\nMC.seurat <- CreateSeuratObject(counts = as(countMatrix, 'CsparseMatrix'), meta.data = as.data.frame(adata_mc$obs))\n#> Warning: Invalid name supplied, making object name syntactically valid. New\n#> object name is\n#> sizetotal_umisX__zeros_downsample_umismetacells_rare_gene_modulerare_metacellcelltype_simplifiedcelltype_simplified_fraction_of_B.cellcelltype_simplified_fraction_of_CD14.Monocelltype_simplified_fraction_of_CD16.Monocelltype_simplified_fraction_of_GMPcelltype_simplified_fraction_of_HSCcelltype_simplified_fraction_of_LMPPcelltype_simplified_fraction_of_MEPcelltype_simplified_fraction_of_NKcelltype_simplified_fraction_of_Naive.T.cellcelltype_simplified_fraction_of_Non.Naive.CD4.cellcelltype_simplified_fraction_of_Non.Naive.CD8.cellcelltype_simplified_fraction_of_Plasmablastcelltype_simplified_fraction_of_Prog_Bcelltype_simplified_fraction_of_Prog_DCcelltype_simplified_fraction_of_Unconventional.Tcelltype_simplified_fraction_of_cDC2celltype_simplified_fraction_of_pDC;\n#> see ?make.names for more details on syntax validity\nMC.seurat@misc[[\"var_features\"]] <- rownames(adata_mc$var)[which(adata_mc$var$selected_gene == T)] \n\n# Save membership in misc\nMC.seurat@misc$cell_membership <- py$ad$obs['membership']\nif(packageVersion(\"Seurat\") >= 5) {\n  MC.seurat[[\"RNA\"]] <- as(object = MC.seurat[[\"RNA\"]], Class = \"Assay\")\n}\nsaveRDS(MC.seurat, file = paste0('./data/', py$proj_name, '/metacell_MC2.rds'))"},{"path":"Metacell-construction-chapter.html","id":"SEACells-construction","chapter":"1 Constructing metacells","heading":"1.3 SEACells (Python)","text":"section, construct metacells using SEACells.","code":""},{"path":"Metacell-construction-chapter.html","id":"method-2","chapter":"1 Constructing metacells","heading":"1.3.1 Method","text":"SEAcells method builds single-cell kNN graph Euclidean distance principal component space (SVD scATAC-seq) space.\nDistances graph transformed affinity applying adaptive Gaussian kernel.\naffinity matrix decomposed archetypes (linear combination cells) membership matrices (cells linear combination archetypes).\nSingle cells assigned given metacell based maximum membership value corresponding archetype.code provided section adapted author’s jupyter notebook.\ninformation method, please refer review (Review?) original paper (Persad et al. 2023).","code":""},{"path":"Metacell-construction-chapter.html","id":"importing-python-packages-1","chapter":"1 Constructing metacells","heading":"Importing python packages","text":"run SEACells, following python packages need imported:don’t packages installed, please refer section 0.1.","code":"import os\nimport pandas as pd\nimport scanpy as sc\nimport SEACells\nimport random"},{"path":"Metacell-construction-chapter.html","id":"data-loading-2","chapter":"1 Constructing metacells","heading":"1.3.2 Data loading","text":"Similarly SuperCell MC2, run SEACells single-cell dataset composed around 30’000 bone marrow cells.\nPlease follow section 0.2 retrieve data SeuratData package save data following file: “data/bmcite/singlecell_anndata_filtered.h5ad”.Note since SEACells can take substential amount time run downsampled data 10’000 cells,\ncan comment last line previous code chunk run SEACells cells.","code":"MC_tool = \"SEACells\"\nproj_name = \"bmcite\"\nannotation_label = 'celltype_simplified'\n\nad = sc.read(os.path.join(\"data\", proj_name, \"singlecell_anndata_filtered.h5ad\"))\nad.var.index = ad.var.genes\nad = sc.pp.subsample(ad, n_obs=10000, copy=True)"},{"path":"Metacell-construction-chapter.html","id":"filtering-steps-2","chapter":"1 Constructing metacells","heading":"1.3.3 Filtering steps","text":"tutorial, data pre-filterd SEACells perform additionnal filtering.","code":""},{"path":"Metacell-construction-chapter.html","id":"building-metacells-2","chapter":"1 Constructing metacells","heading":"1.3.4 Building metacells","text":"Metacells construction using SEACells requires 2 main inputs: ) anndata object (build_kernel_on parameter), \nii) key indicating matrix obsm attribute anndata object considered compute kernel needed archetypal analysis (build_kernel_on parameter).\nImportant optional inputs : number metacells identify (n_SEACells parameter), used input archetypal analysis,\nii) number neighbors consider knn graph (n_neighbors parameter).","code":""},{"path":"Metacell-construction-chapter.html","id":"data-pre-processing-1","chapter":"1 Constructing metacells","heading":"Data pre-processing","text":"following code chunk saves raw counts filtered data raw attribute anndata object.\nraw counts used later metacells aggregation.build kernel archetypal analysis, SEACells requires lower-dimensionnal embedding data (example using PCA scRNA-Seq data SVD scATAC-Seq data).\nnext code chunk, follow standard pre-processing steps prior PCA computation, .e., data normalization, log transformation, identification highly variable genes.\nPCA components saved obsm attribute anndata object.","code":"raw_ad = sc.AnnData(ad.X)\nraw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names\nad.raw = raw_ad# Normalize cells, log transform and compute highly variable genes\nsc.pp.normalize_per_cell(ad, 10000)\nsc.pp.log1p(ad)\nsc.pp.highly_variable_genes(ad, n_top_genes=2000)\n\n# Compute principal components  \nn_comp    = 30\nsc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True)\n\n# Run UMAP for visualization\nsc.pp.neighbors(ad)\nsc.tl.umap(ad)"},{"path":"Metacell-construction-chapter.html","id":"setting-up-seacells-parameters","chapter":"1 Constructing metacells","heading":"Setting up SEACells parameters","text":"tutorial, use SEACells model 30 first principal components resulting PCA build knn graph used compute kernel.\nnumber neighbors considered knn graph can fixed using n_neighbors parameter (15).\nmentioned previously, users provide input number metacells required (n_SEACells parameter). number can defined ratio number single cells desired graining level (gamma parameter following code chunk).\nexample, choose graining level 50.","code":"build_kernel_on = 'X_pca' # key in ad.obsm to use for computing metacells\nn_waypoint_eigs = 10      # Number of eigenvalues to consider when initializing metacells\nn_neighbors = 15 # Number of neighbors used for graph construction \ngamma = 50   # the requested graining level\nn_SEACells = int(ad.shape[0]/gamma) # the requested number of metacells  "},{"path":"Metacell-construction-chapter.html","id":"initializing-the-seacells-model","chapter":"1 Constructing metacells","heading":"Initializing the SEACells model","text":"SEACells model initialized previously defined parameters using SEACells.core.SEACells function.Kernel computation performed using mconstruct_kernel_matrix function.Metacells initialized using initialize_archetypes function.\nSEACells archetypes initialization based cells sampling thus stochastic. User can fix seed reproducible results.\ncheck archetypes evenly spread, users can visualize using plot.plot_initialization function.","code":"model = SEACells.core.SEACells(ad,\n                  build_kernel_on = build_kernel_on,\n                  n_SEACells = n_SEACells,\n                  n_waypoint_eigs = n_waypoint_eigs,\n                  n_neighbors = n_neighbors,\n                  convergence_epsilon = 1e-3,\n                  verbose = True)\n#> Welcome to SEACells!model.construct_kernel_matrix()\n#> Computing kNN graph using scanpy NN ...\n#> Computing radius for adaptive bandwidth kernel...\n#>   0%|          | 0/10000 [00:00<?, ?it/s]\n#> Making graph symmetric...\n#> Parameter graph_construction = union being used to build KNN graph...\n#> Computing RBF kernel...\n#>   0%|          | 0/10000 [00:00<?, ?it/s]\n#> Building similarity LIL matrix...\n#>   0%|          | 0/10000 [00:00<?, ?it/s]\n#> Constructing CSR matrix...\n#> \n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/scipy/sparse/_index.py:143: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil_matrix is more efficient.\n#>   self._set_arrayXarray(i, j, x)\nM = model.kernel_matrix# set seed for reproducibility\n# random.seed(123)\n\n# Initialize archetypes\nmodel.initialize_archetypes()\n#> Building kernel on X_pca\n#> Computing diffusion components from X_pca for waypoint initialization ... \n#> Done.\n#> Sampling waypoints ...\n#> Done.\n#> Selecting 184 cells from waypoint initialization.\n#> Initializing residual matrix using greedy column selection\n#> Initializing f and g...\n#> Selecting 16 cells from greedy initialization.\n#> \n#> \n  0%|          | 0/26 [00:00<?, ?it/s]\n 38%|###8      | 10/26 [00:00<00:00, 92.87it/s]\n 77%|#######6  | 20/26 [00:00<00:00, 90.85it/s]\n100%|##########| 26/26 [00:00<00:00, 92.20it/s]\n# Visualize the initialization \nSEACells.plot.plot_initialization(ad, model, plot_basis='X_umap') "},{"path":"Metacell-construction-chapter.html","id":"fitting-the-seacells-model-to-identify-metacells","chapter":"1 Constructing metacells","heading":"Fitting the SEACells model to identify metacells","text":"identification archetypes iterative process. example, fixed minimum maximum number iteration 10 50 respectively.\ncheck model convergence using plot_convergence function.final archetypes identified, can assign single-cell one metacell (hard assignments).\nassignments (membership) can retrieved using get_hard_assignments function extracted anndata object using ad.obs[\"SEACell\"].\ntutorial, consider hard assignments. However, SEACells package also provides option retrieve soft assignments (multiple weighted assignments cell) using get_soft_assignments function.\ndetails soft assignments, please refer SEACell paper original author’s jupyter notebook.","code":"model.fit(min_iter = 10, max_iter = 100)\n#> Randomly initialized A matrix.\n#> Setting convergence threshold at 0.17973\n#> Starting iteration 1.\n#> Completed iteration 1.\n#> Starting iteration 10.\n#> Completed iteration 10.\n#> Converged after 11 iterations.\nmodel.plot_convergence()membership = model.get_hard_assignments()\nmembership.head\n#> <bound method NDFrame.head of                           SEACell\n#> index                            \n#> b_TGACTTTGTGTTTGGT-1   SEACell-16\n#> a_TTCTCCTTCCGCGCAA-1   SEACell-35\n#> a_ACTATCTTCTTGAGAC-1  SEACell-134\n#> b_GTTCTCGAGTAACCCT-1  SEACell-112\n#> b_ACCCACTGTGGGTCAA-1   SEACell-20\n#> ...                           ...\n#> b_AGGGTGATCGCATGAT-1  SEACell-179\n#> b_TCATTTGTCATATCGG-1  SEACell-142\n#> a_ATCGAGTGTAGCGCTC-1   SEACell-43\n#> a_CCACGGAAGAATCTCC-1   SEACell-25\n#> b_TGTCCCATCCATGAAC-1  SEACell-171\n#> \n#> [10000 rows x 1 columns]>\nad.obs[\"SEACell\"].head\n#> <bound method NDFrame.head of index\n#> b_TGACTTTGTGTTTGGT-1     SEACell-16\n#> a_TTCTCCTTCCGCGCAA-1     SEACell-35\n#> a_ACTATCTTCTTGAGAC-1    SEACell-134\n#> b_GTTCTCGAGTAACCCT-1    SEACell-112\n#> b_ACCCACTGTGGGTCAA-1     SEACell-20\n#>                            ...     \n#> b_AGGGTGATCGCATGAT-1    SEACell-179\n#> b_TCATTTGTCATATCGG-1    SEACell-142\n#> a_ATCGAGTGTAGCGCTC-1     SEACell-43\n#> a_CCACGGAAGAATCTCC-1     SEACell-25\n#> b_TGTCCCATCCATGAAC-1    SEACell-171\n#> Name: SEACell, Length: 10000, dtype: object>"},{"path":"Metacell-construction-chapter.html","id":"retrieve-aggregated-metacell-data-2","chapter":"1 Constructing metacells","heading":"Retrieve aggregated metacell data","text":"core.summarize_by_SEACell function can used generate metacell count matrix (aggregation counts across cells belonging metacell).","code":"mc_ad = SEACells.core.summarize_by_SEACell(ad, SEACells_label='SEACell', summarize_layer='raw', celltype_label=annotation_label)\n#> \n  0%|          | 0/200 [00:00<?, ?it/s]\n  2%|2         | 5/200 [00:00<00:04, 41.08it/s]\n  5%|5         | 10/200 [00:00<00:04, 42.65it/s]\n  8%|7         | 15/200 [00:00<00:04, 43.14it/s]\n 10%|#         | 20/200 [00:00<00:04, 43.80it/s]\n 12%|#2        | 25/200 [00:00<00:04, 43.63it/s]\n 15%|#5        | 30/200 [00:00<00:03, 44.28it/s]\n 18%|#7        | 35/200 [00:00<00:03, 43.78it/s]\n 20%|##        | 40/200 [00:00<00:03, 44.36it/s]\n 22%|##2       | 45/200 [00:01<00:03, 44.19it/s]\n 25%|##5       | 50/200 [00:01<00:03, 43.67it/s]\n 28%|##7       | 55/200 [00:01<00:03, 44.14it/s]\n 30%|###       | 60/200 [00:01<00:03, 44.71it/s]\n 32%|###2      | 65/200 [00:01<00:03, 44.34it/s]\n 35%|###5      | 70/200 [00:01<00:02, 44.62it/s]\n 38%|###7      | 75/200 [00:01<00:02, 45.00it/s]\n 40%|####      | 80/200 [00:01<00:02, 45.14it/s]\n 42%|####2     | 85/200 [00:01<00:02, 45.70it/s]\n 45%|####5     | 90/200 [00:02<00:02, 45.57it/s]\n 48%|####7     | 95/200 [00:02<00:02, 45.68it/s]\n 50%|#####     | 100/200 [00:02<00:02, 45.93it/s]\n 52%|#####2    | 105/200 [00:02<00:02, 46.01it/s]\n 55%|#####5    | 110/200 [00:02<00:01, 45.38it/s]\n 57%|#####7    | 115/200 [00:02<00:01, 45.28it/s]\n 60%|######    | 120/200 [00:02<00:01, 45.17it/s]\n 62%|######2   | 125/200 [00:02<00:01, 45.62it/s]\n 65%|######5   | 130/200 [00:02<00:01, 46.11it/s]\n 68%|######7   | 135/200 [00:03<00:01, 46.18it/s]\n 70%|#######   | 140/200 [00:03<00:01, 46.45it/s]\n 72%|#######2  | 145/200 [00:03<00:01, 46.97it/s]\n 75%|#######5  | 150/200 [00:03<00:01, 46.77it/s]\n 78%|#######7  | 155/200 [00:03<00:00, 47.49it/s]\n 80%|########  | 160/200 [00:03<00:00, 47.37it/s]\n 82%|########2 | 165/200 [00:03<00:00, 47.35it/s]\n 85%|########5 | 170/200 [00:03<00:00, 47.54it/s]\n 88%|########7 | 175/200 [00:03<00:00, 47.55it/s]\n 90%|######### | 180/200 [00:03<00:00, 47.90it/s]\n 92%|#########2| 185/200 [00:04<00:00, 48.28it/s]\n 95%|#########5| 190/200 [00:04<00:00, 48.68it/s]\n 98%|#########7| 195/200 [00:04<00:00, 49.00it/s]\n100%|##########| 200/200 [00:04<00:00, 49.23it/s]\n100%|##########| 200/200 [00:04<00:00, 45.95it/s]"},{"path":"Metacell-construction-chapter.html","id":"annotate-metacells","chapter":"1 Constructing metacells","heading":"Annotate metacells","text":"Note providing annotation celltype_label parameter SEACells.core.summarize_by_SEACell function\nallowed us annotate metacells common cell type metacell.","code":""},{"path":"Metacell-construction-chapter.html","id":"visualize-metacells","chapter":"1 Constructing metacells","heading":"1.3.5 Visualize metacells","text":"visualize metacells, can project metacells single-cell UMAP representation using plot.plot_2D included SEACells package.","code":"SEACells.plot.plot_2D(ad, key='X_umap', colour_metacells=True)"},{"path":"Metacell-construction-chapter.html","id":"save-output-2","chapter":"1 Constructing metacells","heading":"Save output","text":"future downstream analyses python (section 3.2), save metacell counts Anndata object:future downstream analyses R (section 3.1), save metacell counts Seurat object:","code":"print(\"Saving metacell object for the \"+ proj_name+ \" dataset using \"+ MC_tool)\n#> Saving metacell object for the bmcite dataset using SEACells\n\n# Save metacell sizes \nlabel_df = ad.obs[['SEACell']].reset_index()\nmc_ad.obs = mc_ad.obs.join(pd.DataFrame(label_df.groupby('SEACell').count().iloc[:, 0]).rename(columns={'index':'size'}))\n\n# save pca used to compute metacells\nmc_ad.uns['var_features']=ad.var_names[ad.var.highly_variable].tolist()\nmc_ad.uns['sc.pca']=ad.obsm['X_pca'] \nmc_ad.uns['sc.umap']=ad.obsm['X_umap'] \nmc_ad.write_h5ad(os.path.join('./data', proj_name, f'metacell_{MC_tool}.h5ad'))\nlibrary(Seurat)\nlibrary(Seurat)\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nif(packageVersion(\"Seurat\") >= 5) {options(Seurat.object.assay.version = \"v4\"); print(\"you are using seurat v5 with assay option v4\")}\nlibrary(anndata)\nlibrary(reticulate)\n\nadata_mc <- read_h5ad(paste0(\"data/\", py$proj_name, \"/metacell_SEACells.h5ad\"))\n\n# Save counts and metadata in a Seurat object\ncountMatrix <-  Matrix::t(adata_mc$X)\ncolnames(countMatrix) <- adata_mc$obs_names\nrownames(countMatrix) <- adata_mc$var_names\nMC.seurat <- CreateSeuratObject(counts = as(countMatrix, 'CsparseMatrix'), meta.data = as.data.frame(adata_mc$obs))\n# MC.seurat@misc[[\"sc.pca\"]] <- adata_mc$uns$sc.pca\n# MC.seurat@misc[[\"sc.umap\"]] <- adata_mc$uns$sc.umap\nMC.seurat@misc[[\"var_features\"]] <- adata_mc$uns$var_features \npca.res <- adata_mc$uns$sc.pca\nrownames(pca.res) <- rownames(py$ad$obs)\nMC.seurat@misc$sc.pca <- CreateDimReducObject(\n  embeddings = pca.res,\n  key = \"PC_\",\n  assay = \"RNA\"\n)\n#> Warning: No columnames present in cell embeddings, setting to 'PC_1:30'\n# Save membership in misc\nMC.seurat@misc$cell_membership <- data.frame(row.names = rownames(py$membership), membership = py$membership$SEACell)\nif(packageVersion(\"Seurat\") >= 5) {\n  MC.seurat[[\"RNA\"]] <- as(object = MC.seurat[[\"RNA\"]], Class = \"Assay\")\n}\nsaveRDS(MC.seurat, file = paste0('./data/', py$proj_name, '/metacell_SEACells.rds'))"},{"path":"QCs.html","id":"QCs","chapter":"2 Metacells’ QCs","heading":"2 Metacells’ QCs","text":"Different metrics proposed previous metacell studies evaluate quality metacells.\npropose R package called MetacellAnalysisToolkit, compute visualize metrics.\npackage also provides function visualize metacells projected single-cell space.Import packages:explore metacells QCs, need load:\n() single-cell data used build metacells \n(ii) metacell data saved Seurat object (see chapter 1).","code":"\nlibrary(MetacellAnalysisToolkit)\nlibrary(Seurat)\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nif(packageVersion(\"Seurat\") >= 5){options(Seurat.object.assay.version = \"v4\"); print(\"you are using seurat v5 with assay option v4\")}\nMC_tool = \"SuperCell\"\nproj_name = \"bmcite\"\nannotation_label = \"celltype_simplified\"\n\ncell_types <- c(\"Unconventional T\", \"Naive T cell\", \"Non-Naive CD4 cell\", \"CD14 Mono\", \"B cell\", \"Non-Naive CD8 cell\",\n                \"NK\", \"GMP\", \"CD16 Mono\", \"pDC\", \"cDC2\", \"Prog_B\", \"Plasmablast\", \"HSC\", \"LMPP\", \"Prog_DC\", \"MEP\")\n\ncelltype_colors <- c(\"#1E88E5\", \"#FFC107\", \"#004D40\", \"#9E9D24\",\n                     \"#F06292\", \"#546E7A\", \"#D4E157\", \"#76FF03\", \n                     \"#26A69A\", \"#AB47BC\", \"#D81B60\", \"#42A5F5\",\n                     \"#2E7D32\", \"#FFA726\", \"#5E35B1\", \"#EF5350\",\"#6D4C41\")\nnames(celltype_colors) <-cell_types\n\n# Load the single-cell data \nsc_data = readRDS(paste0(\"data/\", proj_name, \"/singlecell_seurat_filtered.rds\"))\n# Load the metacell data \nmc_data = readRDS(paste0('data/', proj_name, '/metacell_', MC_tool,'.rds'))"},{"path":"QCs.html","id":"quantitative-metrics","chapter":"2 Metacells’ QCs","heading":"2.1 Quantitative metrics","text":"","code":""},{"path":"QCs.html","id":"purity","chapter":"2 Metacells’ QCs","heading":"2.1.1 Purity","text":"available, cell annotations can used annotate metacell abundant cell category (e.g. cell type) composing metacell (see chapter 1).\nalso allows us compute metacell purity. annotation considered cell type, purity metacell proportion abundant\ncell type within metacell (Bilous et al. 2022).","code":"\nmembership_df <- mc_data@misc$cell_membership\nmc_data$purity <- mc_purity(membership = membership_df$membership, annotation = sc_data@meta.data[, annotation_label])\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"purity\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"purity\", split.by = annotation_label)"},{"path":"QCs.html","id":"compactness","chapter":"2 Metacells’ QCs","heading":"2.1.2 Compactness","text":"compactness metacell variance components within metacell (Persad et al. 2023).\nlower compactness value better.metric well separation metric computed based low embedding single-cell data (e.g., PCA).\nNote important use embedding used initially construct metacells.\nnext chunk, retrieve principal components computed metacell construction\n(chapter 1 principal components saved Seurat objects containing metacell data)\nrun UMAP visualization.can compute compactness metacell using PCA components.can also compute compactness metacell using diffusion map components computed based PCA axes, suggested (Persad et al. 2023).\ncompute diffusion map components, can use function get_dim_reduc() MetacellAnalysisTookit R package.","code":"\nsc_data@reductions[[\"pca\"]] <- mc_data@misc$sc.pca\nsc_data <- RunUMAP(sc_data, reduction = \"pca\", dims = c(1:30), n.neighbors = 15, verbose = F, min.dist = 0.5)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\nUMAPPlot(sc_data, group.by = annotation_label, reduction = \"umap\", cols=celltype_colors)\nmc_data$compactness <- mc_compactness(cell.membership = membership_df, \n                                      sc.obj = sc_data,\n                                      sc.reduction = \"pca\", \n                                      dims = 1:30)\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"compactness\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"compactness\", split.by = annotation_label)\n# we run diffufion maps on the pca axes saved in the seurat object. Note that a matrix containing the PCA components can be provided as well\ndiffusion_comp <- get_diffusion_comp(sc.obj = sc_data, sc.reduction = \"pca\", dims = 1:30)\n#> Error in python_config_impl(python) : \n#>   Error running '/users/agabrie4/.virtualenvs/r-reticulate/bin/python': No such file.\n#> The Python installation used to create the virtualenv has been moved or removed:\n#>   '/usr/bin'\n#> Warning: The following arguments are not used: layer\n#> Computing diffusion maps ...\nmc_data$compactness <- mc_compactness(cell.membership = membership_df, \n                                      sc.obj = sc_data,\n                                      sc.reduction = diffusion_comp, \n                                      dims = 1:ncol(diffusion_comp))\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"compactness\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"compactness\", split.by = annotation_label)"},{"path":"QCs.html","id":"separation","chapter":"2 Metacells’ QCs","heading":"2.1.3 Separation","text":"separation metacell distance closest metacell (Persad et al. 2023).\nhigher separation value better.Note compactness separation metrics correlated, better compactness results worse separation vice versa.\nMetacells dense regions better compactness worse separation,\nmetacells sparse regions better separation worse compactness.","code":"\nmc_data$separation <- mc_separation(cell.membership = membership_df, \n                                    sc.obj = sc_data, \n                                    sc.reduction = \"pca\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"separation\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"separation\", split.by = annotation_label)\nmc_data$separation <- mc_separation(cell.membership = membership_df, \n                                    sc.obj = sc_data, \n                                    sc.reduction = diffusion_comp)\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"separation\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"separation\", split.by = annotation_label)\nlibrary(ggplot2)\nggplot(data.frame(compactness = log(mc_data$compactness), separation = log(mc_data$separation)), \n       aes(x=compactness, y=separation)) + \n  geom_point()+\n  geom_smooth(method=lm) + ggpubr::stat_cor(method = \"pearson\")\n#> `geom_smooth()` using formula = 'y ~ x'"},{"path":"QCs.html","id":"inv","chapter":"2 Metacells’ QCs","heading":"2.1.4 INV","text":"inner normalized variance (INV) metacell mean-normalized variance gene expression within metacell (Ben-Kiki et al. 2022).\nlower INV value better.\nNote metric latent-space independent.","code":"\nmc_data$INV <- mc_INV(cell.membership = membership_df, sc.obj = sc_data, group.label = \"membership\")\n#> Computing INV ...\n#> Warning in asMethod(object): sparse->dense coercion: allocating vector of size\n#> 3.9 GiB\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"INV\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"INV\", split.by = annotation_label)"},{"path":"QCs.html","id":"size-distribution","chapter":"2 Metacells’ QCs","heading":"2.2 Size distribution","text":"size metacell corresponds number single cells contains.\nhomogeneous metacell size distribution ideal downstream analyses, since larger metacells express genes,\nconfound analyses. heterogeneous size distributions obtained recommend weighted downstream analyses described section 3.3.","code":"\n# Seurat::VlnPlot(mc_data, features = \"size\", pt.size = 2)\n# Seurat::VlnPlot(mc_data, features = \"size\", pt.size = 2, group.by = annotation_label)\nhist(mc_data$size, main = \"Size distribution\", xlab = \"Size\", breaks = 50)\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"size\")\nqc_boxplot(mc.obj = mc_data, qc.metrics = \"size\", split.by = annotation_label) "},{"path":"QCs.html","id":"representativeness-of-metacells","chapter":"2 Metacells’ QCs","heading":"2.3 Representativeness of metacells","text":"visualize metacells, can project metacells single-cell UMAP representation using mc_projection() function (adapted plot.plot_2D() SEACells package).\ngood metacell partition reproduce overall structure single-cell data uniformly representing latent space.\nuse function need data single-cell level (least low-dimensional embedding data) single-cell membership metacell.default size metacells dots proportionnal size metacells.\nMetacells can also colored continuous variable one QC metrics computed previous chunks:","code":"\n\nmc_projection(\n  sc.obj = sc_data, \n  mc.obj = mc_data,\n  cell.membership = membership_df,\n  sc.reduction = \"umap\", \n  sc.label = unlist(annotation_label), # single cells will be colored according the sc.label  \n  metacell.label = unlist(annotation_label) # metacells cell will be colored according the metacell.label\n  )\nmc_projection(\n  sc.obj = sc_data, \n  mc.obj = mc_data, \n  cell.membership = membership_df,\n  sc.reduction = \"umap\", \n  sc.label = unlist(annotation_label), # single cells will be colored according the sc.label  \n  continuous_metric = TRUE,\n  metric = \"compactness\"\n  )"},{"path":"downstream-analysis.html","id":"downstream-analysis","chapter":"3 Downstream analysis of metacells","heading":"3 Downstream analysis of metacells","text":"chapter, run standard advanced downstream analyses metacells instead single-cell data.\ntreat metacell single cell, neglecting information size metacell (.e., number containing single cells).\ninterested sample-weighted analysis, metacell size taken account, see section 3.3.","code":""},{"path":"downstream-analysis.html","id":"standard-analysis-R","chapter":"3 Downstream analysis of metacells","heading":"3.1 Standard analysis (R)","text":"tutorial, standard analyses include dimensionality reduction, clustering differential expression using Seurat framework.","code":"\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nwilcox.test <- \"wilcox\"\nif(packageVersion(\"Seurat\") >= 5) {\n  options(Seurat.object.assay.version = \"v4\") \n  wilcox.test <- \"wilcox_limma\"\n  print(\"you are using seurat v5 with assay option v4\")}\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\nlibrary(ggplot2)"},{"path":"downstream-analysis.html","id":"load-metacell-seurat-object","chapter":"3 Downstream analysis of metacells","heading":"3.1.1 Load metacell Seurat object","text":"use Seurat objects containing metacells counts data annotation (e.g. cell-type annotation) \nproceed standard Seurat downstream analyses.\nSeurat objects containing metacells counts data annotation generated end sections 1.1\nobjects can also generated using command line described chapter 4","code":"\nMC_tool = \"SuperCell\"\nproj_name = \"bmcite\"\nannotation_column = \"celltype_simplified\"\n\ncell_types <- c(\"Unconventional T\", \"Naive T cell\", \"Non-Naive CD4 cell\", \"CD14 Mono\", \"B cell\", \"Non-Naive CD8 cell\",\n                \"NK\", \"GMP\", \"CD16 Mono\", \"pDC\", \"cDC2\", \"Prog_B\", \"Plasmablast\", \"HSC\", \"LMPP\", \"Prog_DC\", \"MEP\")\n\ncelltype_colors <- c(\"#1E88E5\", \"#FFC107\", \"#004D40\", \"#9E9D24\",\n                     \"#F06292\", \"#546E7A\", \"#D4E157\", \"#76FF03\", \n                     \"#26A69A\", \"#AB47BC\", \"#D81B60\", \"#42A5F5\",\n                     \"#2E7D32\", \"#FFA726\", \"#5E35B1\", \"#EF5350\",\"#6D4C41\")\nnames(celltype_colors) <- cell_types\nMC.seurat = readRDS(paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))"},{"path":"downstream-analysis.html","id":"dimensionality-reduction","chapter":"3 Downstream analysis of metacells","heading":"3.1.2 Dimensionality reduction","text":"single-cells, normalize raw counts (aggregated raw counts) identify variable features metacells gene expression data.\nBased features, run PCA use first principal components obtain two dimensional representation data using UMAP.","code":"\nIdents(MC.seurat) <- annotation_column\nMC.seurat <- NormalizeData(MC.seurat)\nMC.seurat <- FindVariableFeatures(MC.seurat, selection.method = \"vst\", nfeatures = 2000)\nMC.seurat <- ScaleData(MC.seurat)\n#> Centering and scaling data matrix\nMC.seurat <- RunPCA(MC.seurat, verbose = F)\nMC.seurat <- RunUMAP(MC.seurat, dims = 1:30, verbose = F, min.dist = 1)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\n\ndata <- cbind(Embeddings(MC.seurat, reduction = \"umap\"),\n              data.frame(size = MC.seurat$size,\n                         cell_type = MC.seurat@meta.data[, annotation_column]))\ncolnames(data)[1:2] <- c(\"umap_1\", \"umap_2\")\np_annot <- ggplot(data, aes(x= umap_1, y=umap_2, color = cell_type)) + geom_point(aes(size=size)) +\n  ggplot2::scale_size_continuous(range = c(0.5,  0.5*max(log((data$size))))) +\n   ggplot2::scale_color_manual(values = celltype_colors) +\n  theme_classic() + guides(color=guide_legend(ncol=2))\np_annot\n#DimPlot(MC.seurat, reduction = \"umap\", cols = celltype_colors, pt.size = log1p(MC.seurat$size))"},{"path":"downstream-analysis.html","id":"clustering","chapter":"3 Downstream analysis of metacells","heading":"3.1.3 Clustering","text":"cluster metacells using Seurat clustering steps visualize clusters using UMAP:","code":"\nMC.seurat <- FindNeighbors(MC.seurat, reduction = \"pca\", dims = 1:30)\n#> Computing nearest neighbor graph\n#> Computing SNN\nMC.seurat <- FindClusters(MC.seurat, resolution = 1)\n#> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n#> \n#> Number of nodes: 613\n#> Number of edges: 13076\n#> \n#> Running Louvain algorithm...\n#> Maximum modularity in 10 random starts: 0.8557\n#> Number of communities: 13\n#> Elapsed time: 0 seconds\ndata <- cbind(Embeddings(MC.seurat, reduction = \"umap\"),\n              data.frame(size = MC.seurat$size,\n                         cluster = MC.seurat$seurat_clusters))\n\ncolnames(data)[1:2] <- c(\"umap_1\", \"umap_2\")\np_cluster <- ggplot(data, aes(x= umap_1, y=umap_2, color = cluster)) + geom_point(aes(size=size)) +\n  ggplot2::scale_size_continuous(range = c(0.5, 0.5*max(log1p((data$size))))) +\n  theme_classic() + guides(color=guide_legend(ncol=2))\np_cluster"},{"path":"downstream-analysis.html","id":"differential-expression-analysis","chapter":"3 Downstream analysis of metacells","heading":"3.1.4 Differential expression analysis","text":"perform differential analysis identify markers cluster 8 example using FindMarkers function.\nsee known NK markers part differentially expressed genes.Let’s visualize markers different clusters using vviolin plots:can verify identification NK cell cluster comparing metacell annotation metacell clustering.","code":"\n# Set idents to metacell clusters\nIdents(MC.seurat) <- \"seurat_clusters\"\n\ncells_markers <- FindMarkers(MC.seurat, ident.1 = \"8\", only.pos = TRUE, logfc.threshold = 0.25, min.pct = 0.1, test.use = wilcox.test, pseudocount.use = 1)\nnk_markers <- c(\"KLRF1\", \"PRF1\", \"IL2RB\", \"NKG7\", \"GNLY\", \"NCAM1\")\ncells_markers[nk_markers, ]\n#>              p_val avg_log2FC pct.1 pct.2    p_val_adj\n#> KLRF1 8.154407e-29  3.1480827 1.000 0.395 1.386983e-24\n#> PRF1  3.710227e-29  2.8961725 1.000 0.360 6.310726e-25\n#> IL2RB 1.988774e-29  1.8908169 0.972 0.315 3.382705e-25\n#> NKG7  3.186981e-23  3.9829930 1.000 0.875 5.420736e-19\n#> GNLY  9.632043e-24  4.8479611 1.000 0.891 1.638314e-19\n#> NCAM1 1.612098e-61  0.5074414 0.889 0.057 2.742018e-57\nVlnPlot(MC.seurat, nk_markers, ncol = 3, pt.size = 0.0)\np_cluster + p_annot"},{"path":"downstream-analysis.html","id":"visualize-gene-gene-correlation","chapter":"3 Downstream analysis of metacells","heading":"3.1.5 Visualize gene-gene correlation","text":"can use supercell_GeneGenePlot function SuperCell package visualize correlation marker genes cell-type:\n() single-cell level \n(ii) metacell level., load single-cell data metacells derived .visualize gene-gene correlation single-cell level:visualize gene-gene correlation metacell level:","code":"\nprint(proj_name)\n#> [1] \"bmcite\"\nsc_data <- readRDS(paste0(\"data/\", proj_name, \"/singlecell_seurat_filtered.rds\"))\nsc_data <- NormalizeData(sc_data, normalization.method = \"LogNormalize\")\ncells_markers <- cells_markers[order(cells_markers$avg_log2FC, decreasing = T),]\ngene_x <- nk_markers[1:3] \ngene_y <- nk_markers[4:6]\n\nalpha <- 0.7\n\np.sc <- SuperCell::supercell_GeneGenePlot(\n  GetAssayData(sc_data, slot = \"data\"),\n  gene_x = gene_x,\n  gene_y = gene_y,\n  clusters = sc_data@meta.data[, annotation_column],\n  sort.by.corr = F,\n  alpha = alpha,\n  color.use = celltype_colors\n)\np.sc$p \n\np.MC <- SuperCell::supercell_GeneGenePlot(GetAssayData(MC.seurat, slot = \"data\"),\n                                          gene_x = gene_x,\n                                          gene_y = gene_y,\n                                          clusters = MC.seurat@meta.data[, annotation_column],\n                                          sort.by.corr = F, supercell_size = MC.seurat$size,\n                                          alpha = alpha,\n                                          color.use = celltype_colors)\np.MC$p "},{"path":"downstream-analysis.html","id":"standard-analysis-Py","chapter":"3 Downstream analysis of metacells","heading":"3.2 Standard analysis (Python)","text":"section, standard analysis includes dimensionality reduction, clustering, differential expression etc using Scanpy framework.","code":"import os\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nsc.settings.verbosity = 1 MC_tool = \"SEACells\"\nproj_name = \"bmcite\"\nannotation_column = \"celltype_simplified\"\nadata = sc.read(os.path.join('./data', proj_name, f'metacell_{MC_tool}.h5ad'))"},{"path":"downstream-analysis.html","id":"dimensionality-reduction-1","chapter":"3 Downstream analysis of metacells","heading":"3.2.1 Dimensionality reduction","text":"","code":"adata.var_names_make_unique()  # this is unnecessary if using `var_names='gene_ids'` in `sc.read_10x_mtx`\n\nsc.pp.normalize_per_cell(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes=2000)\n\n# Freeze the state of the AnnData object for later use in differential testing and visualizations of gene expression\nadata.raw = adata # step needd only if I use regress_out steps\n\n# Compute PCA (highly variable genes will be used)\nsc.tl.pca(adata, svd_solver='arpack')\n\n# Compute the neighbor graph\nsc.pp.neighbors(adata, n_neighbors=15, n_pcs=30)\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/distances.py:1063: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/distances.py:1071: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/distances.py:1086: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/umap_.py:660: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n\n# Run umap\nsc.tl.umap(adata)\n\n# Plot metacells in the UMAP space\nsc.pl.umap(adata, color=[annotation_column], size = 100)\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n#>   cax = scatter("},{"path":"downstream-analysis.html","id":"clustering-1","chapter":"3 Downstream analysis of metacells","heading":"3.2.2 Clustering","text":"Perform clustering metacell data.","code":"# run laiden graph-clustering\nsc.tl.leiden(adata, neighbors_key = \"neighbors\", resolution = 2)\n\n# plot the metacells in the UMAP space and color by cluster\nsc.pl.umap(adata, color=['leiden'], size = 100)\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n#>   cax = scatter("},{"path":"downstream-analysis.html","id":"differential-expression-analysis-1","chapter":"3 Downstream analysis of metacells","heading":"3.2.3 Differential expression analysis","text":"Identify marker genes group metacells.\nvisualize top markers NK Tcells (cluster 6).","code":"# Identify marker genes\nsc.tl.rank_genes_groups(adata, 'leiden', method='wilcoxon')\nsc.pl.rank_genes_groups(adata, n_genes=25, sharey=False)\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/scanpy/plotting/_tools/__init__.py:397: UserWarning: Attempting to set identical low and high ylims makes transformation singular; automatically expanding.\n#>   ax.set_ylim(ymin, ymax)\n# Show the top marker genes\nprint(pd.DataFrame(adata.uns['rank_genes_groups']['names']).head(5))\n#>          0      1        2  ...         12      13        14\n#> 0  S100A12   KLF1    CRYGD  ...    SLC25A5  SH2D1B   TNFRSF4\n#> 1     VCAN  SMIM1   SMIM24  ...     EIF4A3   CD247      AQP3\n#> 2     RBP7   UROS   SPINK2  ...      STMN1    MATK     TRADD\n#> 3   S100A9   MPC2    BAALC  ...       PTMA   KLRF1    PBXIP1\n#> 4     CD14  GATA1  NGFRAP1  ...  HNRNPA2B1    HOPX  TNFRSF25\n#> \n#> [5 rows x 15 columns]\n\n# Visualize marker genes\nsc.pl.violin(adata, ['KLRF1', 'IL2RB', 'GNLY'], groupby=annotation_column, size = 2, rotation = 90)sc.pl.violin(adata, ['KLRF1', 'IL2RB', 'GNLY'], groupby='leiden', size = 2, rotation = 90)"},{"path":"downstream-analysis.html","id":"weighted-analysis","chapter":"3 Downstream analysis of metacells","heading":"3.3 Sample-weighted analysis","text":"","code":"\nlibrary(Seurat)\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nif(packageVersion(\"Seurat\") >= 5) {options(Seurat.object.assay.version = \"v4\"); print(\"you are using seurat v5 with assay option v4\")}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(SuperCell)"},{"path":"downstream-analysis.html","id":"load-metacell-seurat-object-1","chapter":"3 Downstream analysis of metacells","heading":"3.3.1 Load metacell Seurat object","text":"use Seurat objects containing metacells counts data annotation (e.g. cell-type annotation) \nproceed downstream analyses considering size metacells.\nSeurat objects containing metacells counts data annotation generated end sections 1.1\nobjects can also generated using command line described chapter 4","code":"\nMC_tool = \"SuperCell\"\nproj_name = \"bmcite\"\nannotation_column = \"celltype_simplified\"\n\ncell_types <- c(\"Unconventional T\", \"Naive T cell\", \"Non-Naive CD4 cell\", \"CD14 Mono\", \"B cell\", \"Non-Naive CD8 cell\",\n                \"NK\", \"GMP\", \"CD16 Mono\", \"pDC\", \"cDC2\", \"Prog_B\", \"Plasmablast\", \"HSC\", \"LMPP\", \"Prog_DC\", \"MEP\")\n\ncelltype_colors <- c(\"#1E88E5\", \"#FFC107\", \"#004D40\", \"#9E9D24\",\n                     \"#F06292\", \"#546E7A\", \"#D4E157\", \"#76FF03\", \n                     \"#26A69A\", \"#AB47BC\", \"#D81B60\", \"#42A5F5\",\n                     \"#2E7D32\", \"#FFA726\", \"#5E35B1\", \"#EF5350\",\"#6D4C41\")\nnames(celltype_colors) <-cell_types\nMC.seurat = readRDS(paste0('./data/', proj_name, '/metacell_', MC_tool,'.rds'))"},{"path":"downstream-analysis.html","id":"dimensionality-reduction-2","chapter":"3 Downstream analysis of metacells","heading":"3.3.2 Dimensionality reduction","text":"single-cells, normalize raw counts (aggregated raw counts) identify variable features metacells gene expression data.\nBased features, run sample weighted PCA using function supercell_prcomp SuperCell R package\nuse first principal components obtain two dimensionnal representation data using UMAP.\nUsing supercell_DimPlot function SuperCell R package can visualize metacells sized UMAP space.","code":"\nMC.seurat <- NormalizeData(MC.seurat, normalization.method = \"LogNormalize\")\nMC.seurat <- FindVariableFeatures(MC.seurat)\n\nMC_list <- list(N.SC = ncol(MC.seurat),\n                supercell_size = MC.seurat$size)\nMC_list$PCA <- SuperCell::supercell_prcomp(\n  Matrix::t(GetAssayData(MC.seurat, slot = \"data\")),\n  genes.use = VariableFeatures(MC.seurat),  # or a new set of HVG can be computed\n  supercell_size = MC_list$supercell_size, # provide this parameter to run sample-weighted version of PCA,\n  k = 30\n)\n\nMC_list$UMAP <- supercell_UMAP(\n  SC = MC_list,\n  PCA_name = \"PCA\",\n  n.comp = 30, n_neighbors = 15, min_dist=0.5\n)\n\nsupercell_DimPlot(SC = MC_list,\n  groups = MC.seurat@meta.data[, annotation_column],\n  dim.name = \"UMAP\",\n  title = paste0(\"UMAP of metacells colored by cell type assignment\"), color.use = celltype_colors\n) "},{"path":"downstream-analysis.html","id":"clustering-2","chapter":"3 Downstream analysis of metacells","heading":"3.3.3 Clustering","text":"cluster metacells using function supercell_cluster SuperCell R package perform clustering step visualize clusters UMAP space:","code":"\n# compute distance among metacells\nD  <- dist(MC_list$PCA$x)\n\n# cluster metacells\nMC_list$SCclustering  <- supercell_cluster(D = D, k = 20, supercell_size = MC_list$supercell_size)\nMC.seurat$SCclustering <- MC_list$SCclustering$clustering\n\n# Plot clustering result\nsupercell_DimPlot(\n  MC_list,\n  groups = factor(MC_list$SCclustering$clustering),\n  dim.name = \"UMAP\",\n  title = paste0(\"UMAP of metacells colored by metacell clustering\")\n) "},{"path":"downstream-analysis.html","id":"differential-expression-analysis-2","chapter":"3 Downstream analysis of metacells","heading":"3.3.4 Differential expression analysis","text":"perform diffrential analysis identify markers clusters using supercell_FindAllMarkers function SuperCell package.select markers cluster 10:visualize top 5 markers cluster 10 see top marker genes cluster contain marker genes natural killer cells GZMB GNLY.","code":"\n# Compute upregulated genes in each cell line (versus other cells)\nMC.all.markers <- supercell_FindAllMarkers(\n  ge = GetAssayData(MC.seurat, slot = \"data\"),\n  clusters = MC_list$SCclustering$clustering,\n  supercell_size = MC_list$supercell_size,\n  only.pos = TRUE,\n  min.pct = 0,\n  logfc.threshold = 0.2\n)\ncluster_markers <- MC.all.markers[[10]]\nMC.top.markers <- cluster_markers[order(cluster_markers$logFC, decreasing = T),]\nhead(MC.top.markers)\n#>       p.value adj.p.value pct.1     pct.2    logFC w.mean.1   w.mean.2\n#> GNLY        0           0     1 0.9741092 3.484511 4.638771 0.52164265\n#> NKG7        0           0     1 0.9633099 2.901688 4.043199 0.50527916\n#> GZMB        0           0     1 0.7012332 2.561807 2.825672 0.14386314\n#> KLRF1       0           0     1 0.6096614 2.241533 2.358953 0.08974488\n#> KLRD1       0           0     1 0.6235607 2.209200 2.513078 0.16453203\n#> CST7        0           0     1 0.7604756 2.122370 2.736890 0.29031145\nIdents(MC.seurat) <- \"SCclustering\"\ngenes.to.plot <- rownames(MC.top.markers)[1:5]\nVlnPlot(MC.seurat, features = genes.to.plot, ncol = 5, pt.size = 0.0)  \n#> Warning: Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped.\n#> Groups with fewer than two data points have been dropped."},{"path":"command-line.html","id":"command-line","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4 Metacell Analysis Toolkit (MATK)","text":"provide command line tool allowing users build metacells using either tool (MC2, SuperCell SEACells) provided dataset.\ncommand line tool takes multiple parameters input, e.g., number neighbors considered knn, number components used, graining level.\nexample required benchmark setting.use toolkit analyse differentiating hematopoietic stem cells (Human CD34+).\nNote retrieved RNA data 10X multiome experiment won’t analyse ATAC modality.\nretrieve data, please refer section 0.3.","code":""},{"path":"command-line.html","id":"setting-up-the-environment","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.1 Setting up the environment","text":"Please skip step use conda requirements section.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nSys.setenv(RETICULATE_PYTHON = conda_env)\nlibrary(SuperCell)\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\n# If you have Seurat V5 installed, specify that you want to analyze Seurat V4 objects\nif(packageVersion(\"Seurat\") >= 5) {options(Seurat.object.assay.version = \"v4\"); print(\"you are using seurat v5 with assay option v4\")}\nlibrary(anndata)\nlibrary(MetacellAnalysisToolkit)\nlibrary(ggplot2)"},{"path":"command-line.html","id":"MC-continuous","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.2 Metacell building","text":"use MATK bash command line build metacells MetaCell2 SuperCell.\ncall MATK command line, please define path gihub cloned repository optained github repository.","code":""},{"path":"command-line.html","id":"building-metacell-with-metacell2-mc2","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.2.1 Building metacell with MetaCell2 (MC2)","text":"use MetaCell2 (-t MetaCell) identify metacells gamma 50 (-g 50). specify want Seurat .rds object ouput (-s seurat).","code":"#git clone https://github.com/GfellerLab/MetacellAnalysisToolkit\nMATK_path=MetacellAnalysisToolkit/\n${MATK_path}/cli/MATK -t MetaCell -i data/CD34/cd34_multiome_rna.h5ad -o data/CD34/MC2/ -g 50 -s seurat\n#> MetaCell\n#> data/CD34/cd34_multiome_rna.h5ad\n#> Identifying metacells...\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/distances.py:1063: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/distances.py:1071: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/distances.py:1086: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/umap/umap_.py:660: NumbaDeprecationWarning:  [1mThe 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. [0m\n#>   @numba.jit()\n#> set metacells.var[bursty_lonely_gene]: 0 true (0%) out of 12464 bools\n#> set metacells.var[properly_sampled_gene]: 12464 true (100%) out of 12464 bools\n#> set metacells.var[excluded_gene]: 2 true (0.01605%) out of 12464 bools\n#> set metacells.obs[properly_sampled_cell]: 6881 true (100%) out of 6881 bools\n#> set metacells.obs[excluded_cell]: 0 true (0%) out of 6881 bools\n#> set hca_bm.one-pass.clean.obs[full_cell_index]: 6881 int32s\n#> set hca_bm.one-pass.clean.var[full_gene_index]: 12462 int32s\n#> set hca_bm.one-pass.clean.var[lateral_gene]: 215 true (1.725%) out of 12462 bools\n#> set hca_bm.one-pass.clean.var[noisy_gene]: 14 true (0.1123%) out of 12462 bools\n#> set hca_bm.one-pass.clean.var[selected_gene]: * -> False\n#> set hca_bm.one-pass.clean.var[rare_gene]: 0 true (0%) out of 12462 bools\n#> set hca_bm.one-pass.clean.var[rare_gene_module]: 12462 int32 elements with all outliers (100%)\n#> set hca_bm.one-pass.clean.obs[cells_rare_gene_module]: 6881 int32 elements with all outliers (100%)\n#> set hca_bm.one-pass.clean.obs[rare_cell]: 0 true (0%) out of 6881 bools\n#> set hca_bm.one-pass.clean.var[selected_gene]: 1275 true (10.23%) out of 12462 bools\n#> set hca_bm.one-pass.clean.obs[metacell]: 6881 int32s\n#> set hca_bm.one-pass.clean.obs[dissolved]: 0 true (0%) out of 6881 bools\n#> set hca_bm.one-pass.clean.obs[metacell_level]: 6881 int32s\n#> input is \" data/CD34/cd34_multiome_rna.h5ad\n#> Output dir is \" data/CD34/MC2/\n#> gamma is \" 50.0\n#> Pre filter cells is False\n#> Clean: 6881 cells, 12462 genes\n#> Identify137.62metacells using MetaCell2\n#> set metacells.obs[grouped]: 140 int64s\n#> set metacells.obs[total_umis]: 140 float64s\n#> set metacells.layers[total_umis]: ndarray 140 X 12462 float32s\n#> set metacells.obs[__zeros_downsample_umis]: 140 int64s\n#> set metacells.layers[zeros]: ndarray 140 X 12462 int32s\n#> set hca_bm.one-pass.clean.obs[metacell_name]: 6881 <U8s\n#> set metacells.var[highly_variable]: 2499 true (20.05%) out of 12462 bools\n#> set metacells.var[bursty_lonely_gene]: 0 true (0%) out of 12462 bools\n#> set metacells.var[properly_sampled_gene]: 12462 true (100%) out of 12462 bools\n#> set metacells.var[excluded_gene]: 0 true (0%) out of 12462 bools\n#> set metacells.var[full_gene_index]: 12462 int32s\n#> set metacells.var[lateral_gene]: 215 true (1.725%) out of 12462 bools\n#> set metacells.var[noisy_gene]: 14 true (0.1123%) out of 12462 bools\n#> set metacells.var[selected_gene]: 1275 true (10.23%) out of 12462 bools\n#> set metacells.var[rare_gene]: 0 true (0%) out of 12462 bools\n#> set metacells.var[rare_gene_module]: 12462 int32s\n#> set metacells.obs[metacells_rare_gene_module]: 140 int32s\n#> set metacells.obs[rare_metacell]: 0 true (0%) out of 140 bools\n#> set metacells.uns[outliers]: 4\n#> set metacells.uns[metacells_algorithm]: metacells.0.9.0\n#> Assign metadata to metacells and compute purities...\n#> Save results as seurat...\n#> \n#>     WARNING: The R package \"reticulate\" only fixed recently\n#>     an issue that caused a segfault when used with rpy2:\n#>     https://github.com/rstudio/reticulate/pull/1188\n#>     Make sure that you use a version of that package that includes\n#>     the fix.\n#>     Done."},{"path":"command-line.html","id":"building-metacell-with-supercell","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.2.2 Building metacell with SuperCell","text":"use SuperCell (-t SuperCell) identify metacells gamma 50 (-g 50). specify want Seurat .rds object ouput (-s seurat).\nuse 2000 highly variable genes (HVGs, -f 2000) compute PCA use 50 components (-n 50) make k = 30 knn (-k 30) graph identify metacells.","code":"MATK_path=MetacellAnalysisToolkit/\n${MATK_path}/cli/MATK -t SuperCell -i data/CD34/cd34_multiome_rna.h5ad -o data/CD34/SuperCell/ -f 2000 -g 50 -n 50 -k 30 -s seurat\n#> SuperCell\n#> data/CD34/cd34_multiome_rna.h5ad\n#> Identifying metacells...\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0 \n#> Attaching SeuratObject\n#> $ARGS\n#> character(0)\n#> \n#> $input\n#> [1] \"data/CD34/cd34_multiome_rna.h5ad\"\n#> \n#> $outdir\n#> [1] \"data/CD34/SuperCell/\"\n#> \n#> $nPCs\n#> [1] 50\n#> \n#> $nFeatures\n#> [1] 2000\n#> \n#> $gamma\n#> [1] 50\n#> \n#> $output\n#> [1] \"seurat\"\n#> \n#> $k.knn\n#> [1] 30\n#> \n#> $isNorm\n#> [1] FALSE\n#> \n#> $cores\n#> [1] 1\n#> \n#> Error in python_config_impl(python) : \n#>   Error running '/users/agabrie4/.virtualenvs/r-reticulate/bin/python': No such file.\n#> The Python installation used to create the virtualenv has been moved or removed:\n#>   '/usr/bin'\n#>            used  (Mb) gc trigger  (Mb) max used  (Mb)\n#> Ncells  3026514 161.7    4680197 250.0  4680197 250.0\n#> Vcells 33595099 256.4  112485812 858.2 91298259 696.6\n#> Normalize data...Identify Metacells...\n#> Identify 138 metacells using SuperCell...\n#> \n#> Assign metadata to metacells and compute purities...\n#> Done."},{"path":"command-line.html","id":"short-downstream-analysis-of-the-metacells","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.3 Short downstream analysis of the metacells","text":"","code":""},{"path":"command-line.html","id":"metacell2-metacells","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.3.1 MetaCell2 metacells","text":"load object obtained MATKWe Normalize metacells data, identify HVGs, make classical dimensionality reduction (first PCA vizualisation UMAP).Plot results using Seurat.correctly retrieve two main differentiation path CD34+ cells.\none hand, Megakaryocyte Erythrocyte Progenitor (MEP) fate GATA2 GATA1 transcription factor expression.\n, Lymphoid Myeloid Multipotent Progenitor (LMPP) fate SPI1 transcription factor expression.","code":"\ncd34.metacell <- readRDS(\"data/CD34/MC2/mc_Seurat.rds\")\ncd34.metacell\n#> An object of class Seurat \n#> 12462 features across 140 samples within 1 assay \n#> Active assay: RNA (12462 features, 0 variable features)\ncd34.metacell <- NormalizeData(cd34.metacell)\ncd34.metacell <- FindVariableFeatures(cd34.metacell)\ncd34.metacell <- ScaleData(cd34.metacell)\n#> Centering and scaling data matrix\ncd34.metacell <- RunPCA(cd34.metacell)\n#> PC_ 1 \n#> Positive:  NUP210, MIS18BP1, LCP1, IQGAP1, P4HB, SLC2A4RG, COLGALT1, GRB2, ARHGEF18, BRI3BP \n#>     RBL1, AGTPBP1, GGA2, TTC7A, PTPRE, IL17RA, CLEC12A, SLC4A7, CEP128, ARHGAP26 \n#>     LINC01572, UVRAG, LCORL, LRP8, MAP3K1, PDE3B, UBE2E2, GEN1, NSD2, SND1 \n#> Negative:  RPL34, MEIS1, NKAIN2, CHRM3, LAPTM4B, RPL11, ANGPT1, PRKG1, INPP4B, NRIP1 \n#>     RPS2, PDZD2, CRHBP, GPC5, NPR3, PRKG2, ITGA9, CASC15, BEX2, ST8SIA6 \n#>     YES1, DAPK1, ITGA9-AS1, MSI2, MED12L, NFATC2, HMGA2, RPS18, SLC8A3, CHRM3-AS2 \n#> PC_ 2 \n#> Positive:  TFR2, GATA1, UROD, KLF1, DNPH1, ANK1, TIMM13, PRDX2, XACT, ADAMTS3 \n#>     MYC, EPOR, RYR3, TMEM14C, PLIN2, CNRIP1, KEL, CSF1, PTH2R, CYTOR \n#>     MPST, P2RX5, SPTBN2, ELOVL6, SLC40A1, CXADR, SLC39A3, ZFPM1, NMNAT3, FADS2 \n#> Negative:  AKAP13, VIM, CD74, PRKCB, STK17B, CYTH1, HLA-DQB1, DOCK10, SBF2, RASSF2 \n#>     PRKCE, TSC22D3, PLCB1, CD44, ANKRD44, DST, HDAC9, PDE4B, HLA-DRA, TCF4 \n#>     CALCRL, IDS, TGFBR2, SLCO3A1, POU2F2, AKNA, NEGR1, YPEL5, FYN, COL24A1 \n#> PC_ 3 \n#> Positive:  MYL12A, CARD11, PLP2, CCDC69, LGMN, CTSB, CST3, ARL4C, LIME1, PCED1B \n#>     CYTH4, CDKN2D, IQSEC1, RNASE6, IGFLR1, CYB561A3, NCF1, PCED1B-AS1, SPIB, FAM160A1 \n#>     CCDC50, MPEG1, RUBCNL, CYBB, GABARAP, LY96, UGCG, TGFBI, IGF2R, HLA-DMA \n#> Negative:  ANKRD28, LRMDA, EREG, SNHG25, IRAK3, FNDC3B, PCBP3, CSF3R, RAB44, AZU1 \n#>     GPI, MTUS2, SLC22A15, SLC22A4, DENND3, ATP8B4, ELANE, ERLIN1, MARC1, TENT5A \n#>     SLC36A4, DSTYK, IL1RAP, RFX8, MS4A3, MFSD10, PKP2, CEP170, RAB27A, HGF \n#> PC_ 4 \n#> Positive:  EVI5, TET2, CPQ, FCGRT, SRGN, DENND4A, THEMIS2, RNH1, SUCLG2, PIP5K1B \n#>     NR4A2, S100A6, FAM102B, CD4, FGD4, EMP3, CPPED1, EHBP1L1, NID1, AOAH \n#>     ARHGEF12, PHTF1, GRASP, ZNF385A, PRKCA, RIPOR3, PRKAR2B, SAT1, CHD7, KCNQ1 \n#> Negative:  SMIM24, IGLL1, PHGDH, SPARC, LGALS3BP, ITM2C, MZB1, CD69, IGFBP7, SPINK2 \n#>     LAT2, TMIGD2, C1QTNF4, RPLP1, DOCK1, GYPC, ARMH1, CDK6, ADA, SDK2 \n#>     FLT3, PIK3R1, BAALC, PLCB1, SATB1, LRRC26, ARHGAP25, CYFIP2, LNCAROD, PROM1 \n#> PC_ 5 \n#> Positive:  CIT, C21orf58, NUF2, KIF15, SPC25, DIAPH3, SMC4, NDC80, CDCA5, RRM2 \n#>     ESCO2, CDC25C, DEPDC1B, RTKN2, HIST1H4C, MELK, MFGE8, SKA3, KIF20B, NUSAP1 \n#>     NCAPG, ESPL1, EXO1, TACC3, RRM1, NCAPG2, PLK4, E2F8, KIF11, CDK1 \n#> Negative:  SOX4, ACTG1, MIR181A1HG, LINC00173, MED13L, IGFBP7, IL2RG, HCST, SLC43A2, SATB1 \n#>     ABHD17B, ARPP21, TMSB10, TRPM2, LAT2, DNTT, SLC45A3, MYO1G, S100Z, SMAD7 \n#>     REEP5, RPLP1, LINC01934, TNFRSF21, RBMS3, WDR66, MZB1, COBL, CDK6, MOB1B\ncd34.metacell <- RunUMAP(cd34.metacell,dims = c(1:50), min.dist = 0.5)\n#> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\n#> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\n#> This message will be shown once per session\n#> 10:56:31 UMAP embedding parameters a = 0.583 b = 1.334\n#> 10:56:31 Read 140 rows and found 50 numeric columns\n#> 10:56:31 Using Annoy for neighbor search, n_neighbors = 30\n#> 10:56:31 Building Annoy index with metric = cosine, n_trees = 50\n#> 0%   10   20   30   40   50   60   70   80   90   100%\n#> [----|----|----|----|----|----|----|----|----|----|\n#> **************************************************|\n#> 10:56:31 Writing NN index file to temp file /tmp/39866097/Rtmpi2ZhHh/file389b370d888bf\n#> 10:56:31 Searching Annoy index using 1 thread, search_k = 3000\n#> 10:56:31 Annoy recall = 100%\n#> 10:56:31 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n#> 10:56:32 Initializing from normalized Laplacian + noise (using irlba)\n#> 10:56:32 Commencing optimization for 500 epochs, with 4956 positive edges\n#> 10:56:32 Optimization finished\numap.metacell <- UMAPPlot(cd34.metacell,group.by = \"celltype\",label = T)\numap.metacell\ngenes <- c(\"CD34\",\"GATA2\",\"GATA1\",\"SPI1\")\nmarker.metacell.umaps <- lapply(genes, FUN = function(x){\n  plot <- FeaturePlot(cd34.metacell, features = x)\n  }\n)\nmarker.metacell.umaps\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]\ndata <- cbind(umap.metacell$data, cd34.metacell$size)\ncolnames(data)[1:2] <- c(\"umap_1\", \"umap_2\")\ncolnames(data)[length(colnames(data))] <- \"size\"\nggplot(data,aes(x = umap_1, y = umap_2, color = celltype)) + geom_point(aes(size=size)) + theme_classic()\nlapply(marker.metacell.umaps,FUN = function(x){\n  data <- cbind(x$data,cd34.metacell$size)\n  colnames(data)[1:2] <- c(\"umap_1\", \"umap_2\")\n  colnames(data)[length(colnames(data))] <- \"size\"\n  gene <- colnames(data)[length(colnames(data))-1]\n  ggplot(data,aes(x = umap_1, y = umap_2, size=size, colour = .data[[gene]])) + geom_point() + \n    scale_color_gradientn(colors =  c(\"lightgrey\", \"blue\"), \n                          guide = \"colorbar\")  +\n  theme_classic() + ggtitle(gene)\n} )\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]"},{"path":"command-line.html","id":"supercell-metacells","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.3.2 SuperCell metacells","text":"can metacells obtained SuperCellWe load object obtained MATKWe Normalize supercells data, identify HVGs, make classical dimensionality reduction (first PCA vizualisation UMAP).Plot results using Seurat.","code":"\ncd34.supercell <- readRDS(\"data/CD34/SuperCell/mc_Seurat.rds\")\ncd34.supercell\n#> An object of class Seurat \n#> 12464 features across 138 samples within 1 assay \n#> Active assay: RNA (12464 features, 0 variable features)\ncd34.supercell <- NormalizeData(cd34.supercell)\ncd34.supercell <- FindVariableFeatures(cd34.supercell)\ncd34.supercell <- ScaleData(cd34.supercell)\n#> Centering and scaling data matrix\ncd34.supercell <- RunPCA(cd34.supercell)\n#> PC_ 1 \n#> Positive:  TST, NECTIN1, PCLAF, BLVRB, CD36, S100A6, CCDC26, PPP1R14A, PMP22, ANK1 \n#>     ECE1, KLF1, KEL, PLIN2, KCNH2, ADAMTS3, EPOR, CKS1B, HBD, CSF1 \n#>     PRKAR2B, HES6, GATA1, H2AFX, CXADR, APOC1, CENPM, TFR2, APOE, CSF2RB \n#> Negative:  PRKCH, MIR99AHG, RBPMS, CD109, LINC01122, CRHBP, FAM169A, SCML4, ADGRG6, GUCY1A1 \n#>     ABLIM1, NRIP1, MEIS1, SGCZ, NBEA, TMEM163, RORA, MAGI2, PRDM16, ROBO4 \n#>     FGD5, RABGAP1, RNF220, L3MBTL4, ITGA9, SPTBN1, PTPRM, PROM1, MPPED2, IL12RB2 \n#> PC_ 2 \n#> Positive:  PRKCE, GAS7, SPNS3, HDAC9, AFF3, CRYBG1, CYTH1, NEGR1, RUNX2, LRRFIP1 \n#>     MAP3K8, PDE4B, RASGEF1B, RAB11FIP1, FLT3, PRAG1, FAM107B, ITGAL, TIMP2, SDK2 \n#>     HLA-DMB, PLD4, IRF8, APP, LGALS1, AHNAK, ARL4C, PAG1, ZFP36, TSPOAP1 \n#> Negative:  STON2, TAL1, ZNF385D, MYH10, ALDH1A1, VPS37B, CDC42BPA, SLC40A1, DNAJC6, ST8SIA6 \n#>     CYTL1, UROD, PHTF1, TNIK, ABO, NFIA, PIP5K1B, PDZD2, SORBS1, ZNF385D-AS2 \n#>     TRIM58, ICAM4, XACT, ZFPM1, GATA1, HNRNPLL, ARHGEF12, TFR2, RYR3, MINPP1 \n#> PC_ 3 \n#> Positive:  EXT1, RGS1, CARD11, MAPRE2, P2RY14, TMEM59, LGMN, JCHAIN, CCND3, SETBP1 \n#>     CYTH4, CD37, IGF2R, ITM2B, HLA-DMA, ADAM19, LIME1, IL18R1, PMEPA1, HLA-DRA \n#>     UGCG, HLA-DPA1, RASD1, LINC01226, SLC9A7, CDKN2D, HLA-DPB1, SPIB, FAM160A1, TSBP1 \n#> Negative:  FNDC3B, RAB44, SLC22A4, AZU1, PLPPR3, RFX8, PLD1, RAB27A, LRMDA, ELANE \n#>     PCBP3, HGF, CST7, NT5DC3, C16orf74, CTSG, MTUS2, SLC22A15, YBX3, CFD \n#>     MPO, IL1RAP, MS4A3, SLC1A3, AFF2, PRTN3, LYST, NR6A1, IGFBP2, CSF3R \n#> PC_ 4 \n#> Positive:  IGLL1, PHGDH, LGALS3BP, TSPAN7, SMIM24, PTPRD, NDC80, SKA3, MXD3, BAALC \n#>     SPC25, SPARC, CDKN3, FANCD2, KIF2C, FBXO43, ESCO2, RAD51AP1, CDCA5, CDK1 \n#>     PRDX1, ARHGAP11B, ITGA6, DEPDC1B, MYLK, BAALC-AS1, TPX2, MREG, MYO5C, SPC24 \n#> Negative:  KCNQ1, OSCAR, GRASP, ADAM8, ADAP1, FCGRT, FGD4, KDM7A, CTSH, CD86 \n#>     NR4A2, CD4, ENTPD1, LYZ, VDR, NAMPT, HCK, CSTA, ITGAX, PER1 \n#>     GABARAPL1, MNDA, FAM102B, CFP, ZNF503, TNFAIP2, PPARD, LRP1, NLRP12, RETN \n#> PC_ 5 \n#> Positive:  DNTT, LINC00426, GABPB1-AS1, SCN3A, VPREB1, LTB, LINC01237, ARPP21, MME, PCAT14 \n#>     CD79A, CD96, ERGIC1, CYGB, IL7R, EBF1, LINC00173, CD79B, LINC01934, UMODL1 \n#>     SCAI, ATP1A3, LGALS3BP, C5orf56, RETREG1, SLC43A2, SIDT1, LINC01375, SPON1, COBL \n#> Negative:  AURKB, TOP2A, DEPDC1B, UBE2C, CDCA3, CKAP2L, ASPM, NUSAP1, KIF4A, KIF14 \n#>     KIFC1, PRC1, GTSE1, CIT, KIF18B, NUF2, CDK1, KIF15, KIF11, FOXM1 \n#>     BIRC5, CCNA2, CDC25C, MKI67, TUBB4B, CDCA8, TPX2, CENPE, KIF23, CDCA2\ncd34.supercell <- RunUMAP(cd34.supercell,dims = c(1:50),min.dist = 0.5)\n#> 10:56:37 UMAP embedding parameters a = 0.583 b = 1.334\n#> 10:56:37 Read 138 rows and found 50 numeric columns\n#> 10:56:37 Using Annoy for neighbor search, n_neighbors = 30\n#> 10:56:37 Building Annoy index with metric = cosine, n_trees = 50\n#> 0%   10   20   30   40   50   60   70   80   90   100%\n#> [----|----|----|----|----|----|----|----|----|----|\n#> **************************************************|\n#> 10:56:37 Writing NN index file to temp file /tmp/39866097/Rtmpi2ZhHh/file389b3552e344d\n#> 10:56:37 Searching Annoy index using 1 thread, search_k = 3000\n#> 10:56:37 Annoy recall = 100%\n#> 10:56:37 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n#> 10:56:38 Initializing from normalized Laplacian + noise (using irlba)\n#> 10:56:38 Commencing optimization for 500 epochs, with 4504 positive edges\n#> 10:56:38 Optimization finished\numap.supercell <- UMAPPlot(cd34.supercell,group.by = \"celltype\",label = T)\numap.supercell\ngenes <- c(\"CD34\",\"GATA2\",\"GATA1\",\"SPI1\")\nmarker.supercell.umaps <- lapply(genes, FUN = function(x){\n  plot <- FeaturePlot(cd34.supercell, features = x)\n  }\n)\nmarker.supercell.umaps\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]\ndata <- cbind(umap.supercell$data,cd34.supercell$size)\ncolnames(data)[1:2] <- c(\"umap_1\", \"umap_2\")\ncolnames(data)[length(colnames(data))] <- \"size\"\nggplot(data,aes(x = umap_1, y = umap_2, color = celltype)) + geom_point(aes(size=size)) + theme_classic()\nlapply(marker.supercell.umaps,FUN = function(x){\n  data <- cbind(x$data,cd34.supercell$size)\n  colnames(data)[1:2] <- c(\"umap_1\", \"umap_2\")\n  colnames(data)[length(colnames(data))] <- \"size\"\n  gene <- colnames(data)[length(colnames(data))-1]\n  ggplot(data,aes(x = umap_1, y = umap_2, size=size,colour = .data[[gene]])) + geom_point() + \n    scale_color_gradientn(colors =  c(\"lightgrey\", \"blue\"), \n                          guide = \"colorbar\")  +\n  theme_classic() + ggtitle(gene)\n} )\n#> [[1]]#> \n#> [[2]]#> \n#> [[3]]#> \n#> [[4]]"},{"path":"command-line.html","id":"qc-with-the-metacellanalysistoolkit-package","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.4 QC with the MetacellAnalysisToolkit package","text":"","code":""},{"path":"command-line.html","id":"loading-single-cell-data","chapter":"4 Metacell Analysis Toolkit (MATK)","heading":"4.4.1 Loading single-cell data","text":"First need load single cell data make classical dimentionality reduction analysis.Plot single cell data.Now can plot metacells MetaCell2 single-cell space.metacells obtained SuperCell.can compute compactness separation metacells single cell pca.\ncan use approach SEACells computing metrics diffusion map obtained pca using get_diffusion_comp function \nrun mc_compactnness mc_separation functions obtain compactness separation metrics.First MetaCell2 metacellsComparison MetaCell2 SuperCell compactness (lower better).Comparison MetaCell2 SuperCell INV (lower better).","code":"\ncd34.singlecells <- read_h5ad(\"data/CD34/cd34_multiome_rna.h5ad\")\n#> Error in python_config_impl(python) : \n#>   Error running '/users/agabrie4/.virtualenvs/r-reticulate/bin/python': No such file.\n#> The Python installation used to create the virtualenv has been moved or removed:\n#>   '/usr/bin'\ncd34.singlecells <- CreateSeuratObject(counts = Matrix::t(cd34.singlecells$X),meta.data = cd34.singlecells$obs)\ncd34.singlecells <- NormalizeData(cd34.singlecells)\nif(packageVersion(\"Seurat\") >= 5) {\n  cd34.singlecells[[\"RNA\"]] <- as(object = cd34.singlecells[[\"RNA\"]], Class = \"Assay\")\n}\ncd34.singlecells <- FindVariableFeatures(cd34.singlecells)\ncd34.singlecells <- ScaleData(cd34.singlecells)\n#> Centering and scaling data matrix\ncd34.singlecells <- RunPCA(cd34.singlecells)\n#> PC_ 1 \n#> Positive:  NKAIN2, MEIS1, CRHBP, INPP4B, CALN1, CHRM3, AVP, PCDH9, GPC5, PRKG1 \n#>     ANGPT1, MECOM, MIR99AHG, PRKG2, PBX1, PRKCH, SKAP1, PREX2, ZNF385D, THRB \n#>     IL12A-AS1, RBPMS, HLF, LIMCH1, LINC01122, ST8SIA6, TMEM163, MED12L, CABLES1, PDZD2 \n#> Negative:  DIAPH3, POLQ, RRM2, ASPM, TUBB, MKI67, TOP2A, CIT, TUBA1B, BRIP1 \n#>     NUSAP1, CLSPN, ATAD2, SHCBP1, H2AFZ, STMN1, TMPO, KIF15, NCAPG2, DTL \n#>     CENPF, GTSE1, KNL1, PCLAF, HMGN2, ACTB, UHRF1, ZNF367, MELK, AURKB \n#> PC_ 2 \n#> Positive:  PLCB1, NEGR1, PRKCE, AFF3, ATP8B4, SAMHD1, CD44, UBE2E2, MPO, PTPRE \n#>     TTC7A, FLT3, ARHGAP26, GAS7, VIM, RELL1, AKAP13, RAB11FIP1, RUNX2, HDAC9 \n#>     PLD4, ADGRE5, SLC8A1, KLF6, IRF8, SFMBT2, CD74, RBM47, GAB2, SDK2 \n#> Negative:  ANK1, RYR3, XACT, ITGA2B, APOC1, EEF1A1, TFR2, CPB1, KLF1, RPS3 \n#>     APOE, PTH2R, RPL7A, KCNH2, RPS6, BLVRB, FAM178B, KEL, ZNF385D, GATA1 \n#>     ADAMTS3, SLC40A1, RPS5, EEF1B2, RPS3A, RPL13A, CSF1, RPL8, CNRIP1, HBD \n#> PC_ 3 \n#> Positive:  CD74, HLA-DRA, HLA-DRB1, FAM160A1, ACTG1, JCHAIN, EEF1A1, HLA-DPA1, ARL4C, TGFBI \n#>     BLNK, TMSB4X, SPIB, PLXNA4, RPL13A, LGMN, CORO1A, RPS5, SCT, RPS3 \n#>     RNASE6, RPS3A, LIME1, CUX2, ADAM19, PLD4, CST3, IRF7, CARD11, RPL28 \n#> Negative:  AZU1, FNDC3B, ELANE, MPO, LRMDA, PRTN3, KCNQ5, LYST, AFF2, SLC22A15 \n#>     F13A1, EREG, CFD, PLPPR3, ATP8B4, ZEB2, PCBP3, PDE3B, IL1RAP, ACSM3 \n#>     ZNF804A, CSF3R, SLC39A11, PLD1, DENND4A, ANXA1, CTSG, RREB1, TFRC, DGKG \n#> PC_ 4 \n#> Positive:  SPINK2, CALN1, PLCB1, INPP4B, NKAIN2, ANGPT1, ATP8B4, CHRM3, MEIS1, DIAPH3 \n#>     PHGDH, MIR924HG, SMIM24, MDK, TOP2A, CSF3R, ASPM, C1QTNF4, KIF15, TYMS \n#>     PRKCH, NUSAP1, TUBA1B, RRM2, CIT, TK1, CDCA5, POLQ, NDC80, AURKB \n#> Negative:  SAMHD1, CD36, SULF2, ANK1, FAM160A1, TGFBI, CST3, RYR3, RAB11FIP1, S100A6 \n#>     APOC1, XACT, IRF8, RNASE6, FCER1G, PLXNA4, LYZ, CPB1, APOE, UGCG \n#>     FAM178B, GPR183, CSF2RB, RBM47, PIK3R5, MPEG1, CUX2, MICAL2, SLC8A1, CYBB \n#> PC_ 5 \n#> Positive:  MECOM, PCDH9, PRKG1, ASPM, PLXDC2, THRB, SKAP1, PHTF1, ZNF385D, PRKG2 \n#>     SETBP1, PBX1, GPC5, LIMCH1, TOP2A, MED12L, MKI67, GTSE1, ELL2, PTK2 \n#>     PREX2, CENPE, AURKB, CRHBP, DNM3, KIF18B, NUSAP1, HLF, CIT, DIAPH3 \n#> Negative:  GAPDH, RPS19, IGLL1, RPLP0, C1QTNF4, RPL28, RPL13A, RPL18A, RPS24, EEF1A1 \n#>     GYPC, PRSS57, RPLP2, SMIM24, RPS8, RPL35, MIR181A1HG, RPS3, RPL27A, RPL14 \n#>     RPL7, RPS6, RPL6, RPL8, RPL32, RACK1, ACTG1, RPL29, RPS3A, RPL7A\ncd34.singlecells <- RunUMAP(cd34.singlecells,dims = c(1:50))\n#> 10:56:53 UMAP embedding parameters a = 0.9922 b = 1.112\n#> 10:56:53 Read 6881 rows and found 50 numeric columns\n#> 10:56:53 Using Annoy for neighbor search, n_neighbors = 30\n#> 10:56:53 Building Annoy index with metric = cosine, n_trees = 50\n#> 0%   10   20   30   40   50   60   70   80   90   100%\n#> [----|----|----|----|----|----|----|----|----|----|\n#> **************************************************|\n#> 10:56:53 Writing NN index file to temp file /tmp/39866097/Rtmpi2ZhHh/file389b35f3fd462\n#> 10:56:53 Searching Annoy index using 1 thread, search_k = 3000\n#> 10:56:55 Annoy recall = 100%\n#> 10:56:55 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n#> 10:56:56 Initializing from normalized Laplacian + noise (using irlba)\n#> 10:56:56 Commencing optimization for 500 epochs, with 293954 positive edges\n#> 10:57:04 Optimization finished\nUMAPPlot(cd34.singlecells,group.by = \"celltype\",label = T)\nmc_projection(\n  sc.obj = cd34.singlecells,\n  mc.obj = cd34.metacell,\n  cell.membership = cd34.metacell@misc$membership,\n  sc.reduction = \"umap\",\n  sc.label = \"celltype\", # single cells will be colored according the sc.label\n  metacell.label = \"celltype\" # metacells cell will be colored according the metacell.label\n  ) + theme_classic()\nmc_projection(\n  sc.obj = cd34.singlecells,\n  mc.obj = cd34.supercell,\n  cell.membership = cd34.supercell@misc$cell_membership,\n  sc.reduction = \"umap\",\n  sc.label = \"celltype\", # single cells will be colored according the sc.label\n  metacell.label = \"celltype\" # metacells cell will be colored according the metacell.label\n  ) + theme_classic()\ndiffusion_comp <- get_diffusion_comp(sc.obj = cd34.singlecells, sc.reduction = \"pca\", dims = 1:50)\n#> Warning: The following arguments are not used: layer\n#> Computing diffusion maps ...\ncd34.metacell$compactness <- mc_compactness(cell.membership = cd34.metacell@misc$cell_membership, \n                                            sc.obj = cd34.singlecells,\n                                            group.label = \"metacell_name\",\n                                            sc.reduction = diffusion_comp,\n                                            dims = 1:ncol(diffusion_comp))\n\nqc_boxplot(mc.obj = cd34.metacell, qc.metrics = \"compactness\")\ncd34.metacell$separation <- mc_separation(cell.membership = cd34.metacell@misc$cell_membership,\n                                          sc.obj = cd34.singlecells,\n                                          group.label = \"metacell_name\",\n                                          sc.reduction = diffusion_comp,\n                                          dims =  1:ncol(diffusion_comp))\n\nqc_boxplot(mc.obj = cd34.metacell, qc.metrics = \"separation\")\ncd34.supercell$compactness <- mc_compactness(cell.membership = cd34.supercell@misc$cell_membership, \n                                            sc.obj = cd34.singlecells,\n                                            sc.reduction = diffusion_comp, \n                                            dims = 1:ncol(diffusion_comp))\n\nqc_boxplot(mc.obj = cd34.supercell, qc.metrics = \"compactness\")\ncd34.supercell$separation <- mc_separation(cell.membership = cd34.supercell@misc$cell_membership, \n                                          sc.obj = cd34.singlecells,\n                                          sc.reduction = diffusion_comp,\n                                          dims =  1:ncol(diffusion_comp))\n\nqc_boxplot(mc.obj = cd34.supercell, qc.metrics = \"separation\")\ncd34.supercell$INV <- mc_INV(cell.membership = cd34.supercell@misc$cell_membership, sc.obj = cd34.singlecells)\n#> Computing INV ...\ncd34.metacell$INV <- mc_INV(cell.membership = cd34.metacell@misc$cell_membership, sc.obj = cd34.singlecells, group.label = \"metacell_name\")\n#> Computing INV ...\ncd34.metacell$tool <- \"MetaCell2\"\ncd34.supercell$tool <- \"SuperCell\"\ndata.metrics <- rbind(cd34.metacell@meta.data[,c(\"tool\",\"INV\",\"compactness\",\"separation\")],\n                      cd34.supercell@meta.data[,c(\"tool\",\"INV\",\"compactness\",\"separation\")])\n\nggplot(data.metrics,aes(y=compactness,x=tool,fill = tool)) + geom_boxplot()\nggplot(data.metrics,aes(y=separation,x=tool,fill = tool)) + geom_boxplot()\nggplot(data.metrics,aes(y=INV,x=tool,fill = tool)) + geom_boxplot()"},{"path":"integration.html","id":"integration","chapter":"5 Integration of metacells","heading":"5 Integration of metacells","text":"section, work Human Cell Lung Atlas core HLCA\ngathering around 580,000 cells 107 individuals distributed 166 samples.aim tutorial show can use metacells analyze large dataset using reasonable amount time memory.\nuse SuperCell via MCAT command line tool.first perform integration unsupervised mode (5.1), .e., without considering single-cell annotation. , demonstrate supervised integration (5.2).","code":""},{"path":"integration.html","id":"integration-unsupervised","chapter":"5 Integration of metacells","heading":"5.1 Unsupervised integration","text":"section, first perform integration unsupervised mode, .e., without considering single-cell annotation.\nsupervised version, please refer section 5.2.","code":""},{"path":"integration.html","id":"data-loading-3","chapter":"5 Integration of metacells","heading":"5.1.1 Data loading","text":"Please follow section 0.4.1 retrieve HLCA atlas, divide atlas dataset save splitted data following folder: “data/HLCA/”.","code":""},{"path":"integration.html","id":"setting-up-the-environment-1","chapter":"5 Integration of metacells","heading":"5.1.2 Setting up the environment","text":"First need specify work MetacellAnalysisToolkit conda environment (needed anndata relying reticulate MATK tool).\nbuild conda environment please follow instructions MetacellAnalysisToolkit github repository.\nPlease skip step use conda requirements section.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nSys.setenv(RETICULATE_PYTHON = conda_env)#>           used  (Mb) gc trigger (Mb) max used (Mb)\n#> Ncells 1912851 102.2    3088062  165  3088062  165\n#> Vcells 3338476  25.5    8388608   64  5498779   42\nlibrary(Seurat)\n#> The legacy packages maptools, rgdal, and rgeos, underpinning this package\n#> will retire shortly. Please refer to R-spatial evolution reports on\n#> https://r-spatial.org/r/2023/05/15/evolution4.html for details.\n#> This package is now running under evolution status 0\n#> Attaching SeuratObject\nlibrary(anndata)\nlibrary(SuperCell)\nlibrary(ggplot2)\nwilcox.test <- \"wilcox\"\nif(packageVersion(\"Seurat\") >= 5) {\n  options(Seurat.object.assay.version = \"v4\") \n  wilcox.test <- \"wilcox_limma\"\n  print(\"you are using seurat v5 with assay option v4\")}\n\ncolor.celltypes  <- c('#E5D2DD', '#53A85F', '#F1BB72', '#F3B1A0', '#D6E7A3', '#57C3F3', '#476D87',\n                      '#E95C59', '#E59CC4', '#AB3282', '#23452F', '#BD956A', '#8C549C', '#585658',\n                      '#9FA3A8', '#E0D4CA', '#5F3D69', '#58A4C3', \"#b20000\", '#E4C755', '#F7F398',\n                      '#AA9A59', '#E63863', '#E39A35', '#C1E6F3', '#6778AE', '#91D0BE', '#B53E2B',\n                      '#712820', '#DCC1DD', '#CCE0F5', '#CCC9E6', '#625D9E', '#68A180', '#3A6963',\n                      '#968175')"},{"path":"integration.html","id":"building-metacell","chapter":"5 Integration of metacells","heading":"5.1.3 Building metacell","text":"build metacells MATK command line using SuperCell (-t SuperCell).\nfacilitate downstream analysis donors build metacells sample dataset (-sample).\nuse 2000 highly variable genes (-f 2000) compute PCA used 50 principal components (-m 50) build k = 30 (-k 30) nearest neighbor graph metacells identified using graining level 50 (-g 50).\nuse adata .h5ad output format (-s adata) faster write lighter store Seurat .rds object.step takes around 20 min multiple cores (-l 6). aware parallel processing requires memory (32 GB memory required 6 cores).limited memory still able process samples reducing number cores (e.g. -l 3) \nsequentially processing samples (just remove -l) slightly longer time.call MATK command line, please define path gihub cloned repository optained github repository.","code":"#git clone https://github.com/GfellerLab/MetacellAnalysisToolkit\nMATK_path=MetacellAnalysisToolkit/\nstart=`date +%s`\nfor d in data/HLCA/datasets/*;\ndo ${MATK_path}cli/MATK -t SuperCell -i $d/sc_adata.h5ad -o $d -a sample -l 6 -n 50 -f 2000 -k 30 -g 50 -s adata\ndone\necho \"Duration: $((($(date +%s)-$start)/60)) minutes\""},{"path":"integration.html","id":"loading-metacell-objects","chapter":"5 Integration of metacells","heading":"5.1.4 Loading metacell objects","text":"load .h5ad objects directly convert Seurat objects benefit functions framework.\nconsider datasets order one used tutorial run following chunk loading metacell objects.","code":"\nlibrary(anndata)\nadata <- read_h5ad(\"data/HLCA/local.h5ad\",backed = \"r\")\nadata$var_names <- adata$var$feature_name # We will use gene short name for downstream analyses\ndatasets <- unique(adata$obs$dat)\nrm(adata)\ngc()\n\nmetacell.files <- sapply(datasets, FUN = function(x){paste0(\"data/HLCA/datasets/\",x,\"/mc_adata.h5ad\")})\n\nmetacell.objs <- lapply(X = metacell.files, function(X){\n  adata <- read_h5ad(X)\n  countMatrix <- Matrix::t(adata$X)\n  colnames(countMatrix) <- adata$obs_names\n  rownames(countMatrix) <- adata$var_names\n  sobj <- Seurat::CreateSeuratObject(counts = countMatrix,meta.data = adata$obs)\n  if(packageVersion(\"Seurat\") >= 5){sobj[[\"RNA\"]] <- as(object = sobj[[\"RNA\"]], Class = \"Assay\")}\n  sobj <- RenameCells(sobj, add.cell.id = unique(sobj$sample)) # we give unique name to metacells\n  return(sobj)\n})"},{"path":"integration.html","id":"merging-objects-and-basic-quality-control","chapter":"5 Integration of metacells","heading":"5.1.5 Merging objects and basic quality control","text":"Given single-cell metadata, MATK tool automatically assigns annotations metacells computes purities categorical variables present\nmetadata input single-cell object.Thus, can check purity metacells different levels annotations, well size (number single cells contain).merge object together use Seurat VlnPlot function.can also use box plots.Overall metacells different datasets present good purity third level annotation.","code":"\nunintegrated.mc <- merge(metacell.objs[[1]], metacell.objs[-1])\n\nVlnPlot(unintegrated.mc, features = c(\"size\", \"ann_level_1_purity\"), group.by = 'dataset', pt.size = 0.001, ncol = 2)\nVlnPlot(unintegrated.mc, features = c(\"ann_level_2_purity\", \"ann_level_3_purity\"), group.by = 'dataset', pt.size = 0.001, ncol = 2)\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_2_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_3_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\nggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))"},{"path":"integration.html","id":"unintegrated-analysis","chapter":"5 Integration of metacells","heading":"5.1.6 Unintegrated analysis","text":"Let’s first standard dimensionality reduction without batch correction.can see plots batch effect clearly present metacell level metacells clustering datasets inside major cell types.\nLet’s correct .","code":"\nDefaultAssay(unintegrated.mc) <- \"RNA\"\nunintegrated.mc <- NormalizeData(unintegrated.mc)\nunintegrated.mc <- FindVariableFeatures(unintegrated.mc)\nunintegrated.mc <- ScaleData(unintegrated.mc)\nunintegrated.mc <- RunPCA(unintegrated.mc)\nunintegrated.mc <- RunUMAP(unintegrated.mc, dims = 1:30)\n\numap.unintegrated.datasets <- DimPlot(unintegrated.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"unintegrated datasets\")\numap.unintegrated.types <- DimPlot(unintegrated.mc, reduction = \"umap\", group.by = \"ann_level_2\", label = T, repel = T, cols = color.celltypes)+ NoLegend() + ggtitle(\"unintegrated cell types\")\n\numap.unintegrated.datasets + umap.unintegrated.types\n\nremove(unintegrated.mc) # we won't use the unintegrated object anymore\ngc()"},{"path":"integration.html","id":"seurat-integration","chapter":"5 Integration of metacells","heading":"5.1.7 Seurat integration","text":"use standard Seurat_v4 batch correction workflow. original study, use dataset rather donor batch parameter.\nSee method section “Data integration benchmarking” original study details.take less 5 minutes.Check obtained object.can verify sum metacell sizes corresponds original number single-cellsSeurat returns slot \"integrated\" can use downstream analysis.Now can make plots visually compare results unintegrated analysis.Seurat efficiently corrected batch effect data keeping cell type separated, batch correction methods harmony also done job.Note original study, datasets integrated using SCANVI semi-supervised integration using partial annotation obtained dataset prior integration.\ninterested supervised approach metacell level R can look second example section 5.2 using STACAS package.can navigate different annotation levels.","code":"\n\nn.metacells <- sapply(metacell.objs, FUN = function(x){ncol(x)})\nnames(n.metacells) <- datasets\nref.names <- sort(n.metacells,decreasing = T)[1:5]\nref.index <- which(datasets %in% names(ref.names))\n\n# normalize each dataset\nmetacell.objs <- lapply(X = metacell.objs, FUN = function(x) {\n  DefaultAssay(x) <- \"RNA\";\n  x <- RenameCells(x, add.cell.id = unique(x$sample)) # we give unique name to metacells\n  x <- NormalizeData(x)\n  x <- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000)\n  return(x)})\n\nfeatures <- SelectIntegrationFeatures(object.list = metacell.objs)\n\nmetacell.objs <- lapply(X = metacell.objs, FUN = function(x) {\n    x <- ScaleData(x, features = features, verbose = FALSE)\n    x <- RunPCA(x, features = features, verbose = FALSE)\n})\n\nanchors <- FindIntegrationAnchors(object.list = metacell.objs,\n                                       anchor.features = features,\n                                       reduction = \"rpca\",\n                                       reference = ref.index, # the 5 biggest datasets (in term of metacell number) are used as reference\n                                       dims = 1:30)\n\nremove(metacell.objs) # We don't need the object list anymore\ngc()\n\ncombined.mc <- IntegrateData(anchorset = anchors,k.weight = 40) # we have to update the k.weight parameters because the smallest dataset contain less than 100 metacells\ncombined.mc\n#> An object of class Seurat \n#> 30024 features across 11706 samples within 2 assays \n#> Active assay: integrated (2000 features, 2000 variable features)\n#>  1 other assay present: RNA\nsum(combined.mc$size)\n#> [1] 584944\nDefaultAssay(combined.mc) = \"integrated\"\ncombined.mc <- ScaleData(combined.mc, verbose = FALSE)\ncombined.mc <- RunPCA(combined.mc, npcs = 30, verbose = FALSE)\ncombined.mc <- RunUMAP(combined.mc, reduction = \"pca\", dims = 1:30, verbose = FALSE)\ncombined.mc <- RunUMAP(combined.mc, dims = 1:30,reduction =  \"pca\",reduction.name = \"umap\", verbose = FALSE)\numap.integrated.datasets <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"integrated datasets\")\numap.integrated.celltypes <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"ann_level_2\",label = T,repel = T,cols = color.celltypes) + NoLegend() + ggtitle(\"integrated cell types\")\n\numap.integrated.datasets + umap.integrated.celltypes + umap.unintegrated.datasets + umap.unintegrated.types\nlibrary(ggplot2)\n\nDimPlot(combined.mc,group.by = \"ann_level_1\",reduction = \"umap\",label = T,repel = T,cols= color.celltypes) + NoLegend()\n\nDimPlot(combined.mc,group.by = \"ann_level_2\",reduction = \"umap\",label = T,repel = T,cols= color.celltypes) + NoLegend()\n\nDimPlot(combined.mc,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= color.celltypes) + NoLegend()"},{"path":"integration.html","id":"downstream-analysis-1","chapter":"5 Integration of metacells","heading":"5.1.8 Downstream analysis","text":"","code":""},{"path":"integration.html","id":"clustering-3","chapter":"5 Integration of metacells","heading":"5.1.8.1 Clustering","text":"cluster metacells based corrected PCA space Seurat.","code":"\nDefaultAssay(combined.mc) <- \"integrated\"\ncombined.mc <- FindNeighbors(combined.mc, reduction = \"pca\", dims = 1:30)\ncombined.mc <- FindClusters(combined.mc, resolution = 0.5)\nUMAPPlot(combined.mc, label = T) + NoLegend()"},{"path":"integration.html","id":"deferentially-expressed-gene-deg-analysis.","chapter":"5 Integration of metacells","heading":"5.1.8.2 Deferentially expressed gene (DEG) analysis.","text":"can find obtained clusters correspond B cells annotated original study (4th level annotation)Now let’s found markers cluster.cluster clearly presents B cell signature marker genes CD19 PAX5By looking metacell annotation (assigned original single-cell metadata MATK),\ncan verify correctly retrieved B cell lineage cluster.","code":"\nb.clust <- names(which.max(table(combined.mc$ann_level_4, combined.mc$integrated_snn_res.0.5)[\"B cells\", ]))\nb.clust\n#> [1] \"23\"\nDefaultAssay(combined.mc) <- \"RNA\"\n\nmarkersB <- FindMarkers(combined.mc, ident.1 = b.clust, only.pos = T, logfc.threshold = 0.25, test.use =  wilcox.test)\nhead(markersB)\n#>       p_val avg_log2FC pct.1 pct.2 p_val_adj\n#> TCL1A     0  1.3939363 0.695 0.020         0\n#> FCRLA     0  1.0706003 0.962 0.022         0\n#> BLK       0  1.2209493 0.990 0.058         0\n#> FCRL5     0  0.7922142 0.886 0.027         0\n#> PNOC      0  0.5425023 0.924 0.050         0\n#> PAX5      0  0.6124840 0.895 0.023         0\ngenes <-c(\"CD19\",\"PAX5\") # knwon B cells markers\nmarkersB[genes,]\n#>              p_val avg_log2FC pct.1 pct.2     p_val_adj\n#> CD19 6.500657e-208   1.104315 0.990 0.113 1.821744e-203\n#> PAX5  0.000000e+00   0.612484 0.895 0.023  0.000000e+00\nVlnPlot(combined.mc, genes, ncol = 1)\nDimPlot(combined.mc[, combined.mc$integrated_snn_res.0.5 == b.clust],\n        group.by = c(\"ann_level_4\",\"integrated_snn_res.0.5\"),\n        ncol = 2)"},{"path":"integration.html","id":"cell-type-abundances-analyses.","chapter":"5 Integration of metacells","heading":"5.1.8.3 Cell type abundances analyses.","text":"can easily make analysis cell type abundances different clinical variables construct metacell sample.\ntake metacell size account analyses.\ninstance can analyse proportion different epithelial cell types depending smoking status.Samples smokers seem present AT2 cells quick analysis illustrative purposes .\npractice ’s far complex draw conclusion considered variations samples/donors well many technical\n(tissue dissociation protocol, tissue sampling method, single-cell platform, … ) biological (BMI, sex, Age, …) variables.","code":"\nlibrary(reshape2)\ncombined.mc.epith <- combined.mc[,combined.mc$ann_level_1 == \"Epithelial\"]\n#combined.metacells$major_type <- droplevels(combined.metacells$major_type)\nsmpCounts <- aggregate(combined.mc.epith$size, by=list(sample = combined.mc.epith$sample,\n                                                       major_type = combined.mc.epith$ann_level_3,\n                                                       smoking_status = combined.mc.epith$smoking_status),\n                       FUN = sum)\n\ncontingencyTable <- xtabs(x ~ major_type + smoking_status, data = smpCounts)\nfreqMatrix <- apply(contingencyTable, 1, FUN = function(x){x/colSums(contingencyTable)})\n# res <- chisq.test(contingencyTable)\n# Roe <- res$observed/res$expected\nfreqMatrix_df <- melt(freqMatrix)\n\nremove(combined.mc.epith)\ngc()\n\nggplot(freqMatrix_df, aes(y=value,x = smoking_status,fill=major_type))  + geom_bar(stat=\"identity\", position=\"fill\") + scale_fill_manual(values = color.celltypes) + scale_y_continuous(labels = scales::percent) + ylab(\"% epithelial cells\")"},{"path":"integration.html","id":"conclusion","chapter":"5 Integration of metacells","heading":"5.1.9 Conclusion","text":"Overall made precise simplification original atlas using metacells built sample separately.\nreducing size original atlas factor 50 load data, make integration correct batch effect\nrecapitulate main different cell types using reasonable amount time memory.\ncontrast, simply loading original single-cell data R using Seurat extremely time-consuming challenging even powerful computers.first example used fully unsupervised workflow use prior biological knowledge.\nAuthors original study made remarkable work annotating hundreds thousands cells atlas.\nsecond example section 5.2 propose supervised workflow using annotation guide metacell\nidentification batch correction.can save results comparison second example.","code":"\nsaveRDS(combined.mc,\"data/HLCA/combined.mc.unsup.rds\")"},{"path":"integration.html","id":"integration-supervised","chapter":"5 Integration of metacells","heading":"5.2 Supervised integration","text":"unsupervised integration example, work Human Cell Lung Atlas core HLCA\ngathering around 580,000 cells 107 individuals distributed 166 samples.Taking advantage single-cell annotation original study build metacells cell type sample \nguide integration cell type label using STACAS.","code":""},{"path":"integration.html","id":"data-loading-4","chapter":"5 Integration of metacells","heading":"5.2.1 Data loading","text":"Please follow section 0.4.1 retrieve HLCA atlas, divide atlas dataset save splitted data following folder: “data/HLCA/”.","code":""},{"path":"integration.html","id":"setting-up-the-environment-2","chapter":"5 Integration of metacells","heading":"5.2.2 Setting up the environment","text":"First need specify work MetacellAnalysisToolkit conda environment (needed anndata relying reticulate MATK tool).\nbuild conda environment please follow instructions MetacellAnalysisToolkit github repository.\nPlease skip step use conda requirements section.","code":"\nlibrary(reticulate)\nconda_env <-  conda_list()[reticulate::conda_list()$name == \"MetacellAnalysisToolkit\",\"python\"]\n\nSys.setenv(RETICULATE_PYTHON = conda_env)#>           used  (Mb) gc trigger    (Mb)   max used    (Mb)\n#> Ncells 3607736 192.7    6649217   355.2    6649217   355.2\n#> Vcells 6815916  52.1 1894377494 14453.0 2366896489 18058.0\nlibrary(Seurat)\nlibrary(anndata)\nlibrary(SuperCell)\nlibrary(ggplot2)\n\nwilcox.test <- \"wilcox\"\nif(packageVersion(\"Seurat\") >= 5) {\n  options(Seurat.object.assay.version = \"v4\") \n  wilcox.test <- \"wilcox_limma\"\n  print(\"you are using seurat v5 with assay option v4\")}\n\ncolor.celltypes  <- c('#E5D2DD', '#53A85F', '#F1BB72', '#F3B1A0', '#D6E7A3', '#57C3F3', '#476D87',\n                      '#E95C59', '#E59CC4', '#AB3282', '#23452F', '#BD956A', '#8C549C', '#585658',\n                      '#9FA3A8', '#E0D4CA', '#5F3D69', '#58A4C3', \"#b20000\", '#E4C755', '#F7F398',\n                      '#AA9A59', '#E63863', '#E39A35', '#C1E6F3', '#6778AE', '#91D0BE', '#B53E2B',\n                      '#712820', '#DCC1DD', '#CCE0F5', '#CCC9E6', '#625D9E', '#68A180', '#3A6963',\n                      '#968175')"},{"path":"integration.html","id":"constructing-supervised-metacell","chapter":"5 Integration of metacells","heading":"5.2.3 Constructing supervised metacell","text":"Sikkema et al. made remarkable job finely annotating hundreds thousands cells.\nWithin framework re-analysis, let’s now try use prior knowledge obtain slightly better results using supervised workflow.added section 0.4 ann_sample column metadata single cell object.\nnow can use build metacell cell type sample.limited memory still able process samples reducing number cores (e.g. -l 3) \nsequentially processing samples (just remove -l) slightly longer timeThis take around 30 minutes.call MATK command line, please define path gihub cloned repository optained github repository.","code":"#git clone https://github.com/GfellerLab/MetacellAnalysisToolkit\nMATK_path=MetacellAnalysisToolkit/\nfor d in data/HLCA/datasets/*;\ndo ${MATK_path}cli/MATK -t SuperCell -i $d/sc_adata.h5ad -o $d/sup_mc -a ann_sample -l 6 -n 50 -f 2000 -k 30 -g 50 -s adata\ndone"},{"path":"integration.html","id":"load-metacell-objects","chapter":"5 Integration of metacells","heading":"5.2.4 Load metacell objects","text":"load .h5ad objects directly convert Seurat objects benefit functions framework.\nconsider datasets order one used tutorial run following chunk loading metacell objects.","code":"\nlibrary(anndata)\nadata <- read_h5ad(\"data/HLCA/local.h5ad\",backed = \"r\")\nadata$var_names <- adata$var$feature_name # We will use gene short name for downstream analyses\ndatasets <- unique(adata$obs$dat)\nrm(adata)\ngc()\n\nmetacell.files <- sapply(datasets, FUN = function(x){paste0(\"data/HLCA/datasets/\",x,\"/sup_mc/mc_adata.h5ad\")})\n\nmetacell.objs <- lapply(X = metacell.files, function(X){\n  adata <- read_h5ad(X)\n  countMatrix <- Matrix::t(adata$X)\n  colnames(countMatrix) <- adata$obs_names\n  rownames(countMatrix) <- adata$var_names\n  sobj <- Seurat::CreateSeuratObject(counts = countMatrix,meta.data = adata$obs)\n  if(packageVersion(\"Seurat\") >= 5) {sobj[[\"RNA\"]] <- as(object = sobj[[\"RNA\"]], Class = \"Assay\")}\n  sobj <- RenameCells(sobj, add.cell.id = unique(sobj$sample)) # we give unique name to metacells\n  return(sobj)\n})"},{"path":"integration.html","id":"merging-objects-and-basic-quality-control-1","chapter":"5 Integration of metacells","heading":"5.2.5 Merging objects and basic quality control","text":"Given single-cell metadata, MATK tool automatically assigns annotations metacells \ncomputes purities categorical variables present metadata input single-cell object.Thus, let’s check purity metacells different level annotations, well size (number single cells contain).merge objects together use Seurat VlnPlot function.can also use box plots.Overall using supervised metacells construction obtain pure metacells 3rd level annotation \nimprove metacell purities finer levels compared unsupervised approach (see previous section 5.1).","code":"\nunintegrated.mc <- merge(metacell.objs[[1]], metacell.objs[-1])\n\nVlnPlot(unintegrated.mc[, unintegrated.mc$ann_level_3 != \"None\"], features = c(\"size\", \"ann_level_2_purity\"), group.by = 'dataset', pt.size = 0.001, ncol = 2)\n#> Warning in SingleExIPlot(type = type, data = data[, x, drop = FALSE], idents =\n#> idents, : All cells have the same value of ann_level_2_purity.\nVlnPlot(unintegrated.mc[, unintegrated.mc$ann_level_3 != \"None\"], features = c(\"ann_level_3_purity\", \"ann_level_4_purity\"), group.by = 'dataset', pt.size = 0.001,  ncol=2)\n#> Warning in SingleExIPlot(type = type, data = data[, x, drop = FALSE], idents =\n#> idents, : All cells have the same value of ann_level_3_purity.\np_4 <- ggplot(unintegrated.mc@meta.data, aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45)) + ggtitle(\"sup metacells level 4 purity\") + NoLegend() + ylim(c(0,1))\n\np_finest <- ggplot(unintegrated.mc@meta.data, aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))  + ggtitle(\"sup metacells finest level purity\") + NoLegend() + ylim(c(0,1))\n\np_4 + p_finest\nmeta.data.unsup <- readRDS(\"data/HLCA/combined.mc.unsup.rds\")@meta.data\n\np_4_unsup <- ggplot(meta.data.unsup, aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() +\n    scale_x_discrete(guide = guide_axis(angle = 45)) + ggtitle(\"unsup metacells level 4 purity\") + NoLegend() + ylim(c(0,1))\n\np_finest_unsup <- ggplot(meta.data.unsup, aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() +\n  scale_x_discrete(guide = guide_axis(angle = 45))  + ggtitle(\"unsup metacells finest level purity\") + NoLegend() + ylim(c(0,1))\n\np_4_unsup | p_4\np_finest_unsup + p_finest"},{"path":"integration.html","id":"unintegrated-analysis-1","chapter":"5 Integration of metacells","heading":"5.2.6 Unintegrated analysis","text":"Let’s first standard dimensionality reduction without batch correction.can see plots batch effect clearly present metacell level. Let’s correct using supervised approach.","code":"\nDefaultAssay(unintegrated.mc) <- \"RNA\"\nunintegrated.mc <- NormalizeData(unintegrated.mc)\nunintegrated.mc <- FindVariableFeatures(unintegrated.mc)\nunintegrated.mc <- ScaleData(unintegrated.mc)\nunintegrated.mc <- RunPCA(unintegrated.mc)\nunintegrated.mc <- RunUMAP(unintegrated.mc,dims = 1:30)\n\numap.unintegrated.datasets <- DimPlot(unintegrated.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"unintegrated datasets\")\numap.unintegrated.types <- DimPlot(unintegrated.mc,reduction = \"umap\",group.by = \"ann_level_2\",label = T,repel = T,cols = color.celltypes)+ NoLegend() + ggtitle(\"unintegrated cell types\")\n\numap.unintegrated.datasets + umap.unintegrated.types"},{"path":"integration.html","id":"stacas-integration","chapter":"5 Integration of metacells","heading":"5.2.7 STACAS integration","text":"original study, datasets integrated using SCANVI semi-supervised integration using partial annotation obtained dataset prior integration.\nsecond example propose use similar approach R using STACAS. use “ann” labels used construct metacells (3rd level annotation available cell, otherwise 2nd level).noted , original study, use dataset rather donor batch parameter. See method section Data integration benchmarking original study details.Check obtained object:can verify sum metacell sizes correspond original number single-cellsSTACAS directly returns pca slot \"integrated\" can use make UMAP corrected data.Now can make plots visually compare results unintegrated analysis.STACAS efficiently corrected batch effect data keeping cell type separated.can navigate different annotation levels.","code":"\n# Install package if needed\nif (!requireNamespace(\"STACAS\")) remotes::install_github(\"carmonalab/STACAS\", upgrade = \"never\")\nlibrary(STACAS)\n\nt0_integration <- Sys.time()\n\nn.metacells <- sapply(metacell.objs, FUN = function(x){ncol(x)})\nnames(n.metacells) <- datasets\nref.names <- sort(n.metacells,decreasing = T)[1:5]\nref.index <- which(datasets %in% names(ref.names))\n\n# normalize and identify variable features for each dataset independently\nmetacell.objs <- lapply(X = metacell.objs, FUN = function(x) {\n  DefaultAssay(x) <- \"RNA\";\n  x <- RenameCells(x, add.cell.id = unique(x$sample)) # we give unique name to metacells\n  x <- NormalizeData(x)\n  return(x)})\ngc()\n\n\n# Perform a supervised integration of the dataset using STACAS\ncombined.mc <- Run.STACAS(object.list = metacell.objs,\n                          anchor.features = 2000,\n                          min.sample.size = 80,\n                          k.weight = 80, #smallest dataset contains 86 metacells\n                          cell.labels = \"ann\", # Note that by not you can use STACAS in its unsupervised mode\n                          reference = ref.index, # the 5 biggest datasets are used as reference\n                          dims = 1:30)\n\ntf_integration <- Sys.time()\n\ntf_integration - t0_integration\n\nremove(metacell.objs) # We don't need the object list anymore\ngc()\ncombined.mc\n#> An object of class Seurat \n#> 30024 features across 12914 samples within 2 assays \n#> Active assay: integrated (2000 features, 2000 variable features)\n#>  1 other assay present: RNA\n#>  1 dimensional reduction calculated: pca\nsum(combined.mc$size)\n#> [1] 584944\nDefaultAssay(combined.mc) = \"integrated\"\n\ncombined.mc <- RunUMAP(combined.mc, dims = 1:30, reduction =  \"pca\", reduction.name = \"umap\")\numap.stacas.datasets <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"dataset\") + NoLegend() + ggtitle(\"integrated datasets\")\numap.stacas.celltypes <- DimPlot(combined.mc,reduction = \"umap\",group.by = \"ann_level_2\",label = T,repel = T,cols = color.celltypes) + NoLegend() + ggtitle(\"integrated cell types\")\n\numap.stacas.datasets + umap.stacas.celltypes + umap.unintegrated.datasets + umap.unintegrated.types\nlibrary(ggplot2)\n\nDimPlot(combined.mc,group.by = \"ann_level_1\",reduction = \"umap\",cols= color.celltypes)\n\nDimPlot(combined.mc,group.by = \"ann_level_2\",reduction = \"umap\",label = T,repel = T,cols= color.celltypes)\n\nDimPlot(combined.mc,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= color.celltypes) + NoLegend()"},{"path":"integration.html","id":"comparison-with-unsupervised-analysis","chapter":"5 Integration of metacells","heading":"5.2.8 Comparison with unsupervised analysis","text":"can quickly visually compare results unsupervised integration obtained Seurat:Look epithelial cells particular","code":"\ncombined.mc.unsup <- readRDS(\"data/HLCA/combined.mc.unsup.rds\")\n\ncombined.mc$ann_level_3 <- factor(combined.mc$ann_level_3)\nmatched.color.celltypes <- color.celltypes[1:length(levels(combined.mc$ann_level_3))]\nnames(matched.color.celltypes) <- levels(combined.mc$ann_level_3)\n\nlevel3_sup <- DimPlot(combined.mc,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Sup workflow\")\nlevel3_unsup <- DimPlot(combined.mc.unsup,group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Unsup workflow\")\n\nlevel3_sup + level3_unsup\nlevel3_sup <- DimPlot(combined.mc[,combined.mc$ann_level_1 == \"Epithelial\"],group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Sup workflow\")\nlevel3_unsup <- DimPlot(combined.mc.unsup[,combined.mc.unsup$ann_level_1 == \"Epithelial\"],group.by = \"ann_level_3\",reduction = \"umap\",label = T, repel = T,cols= matched.color.celltypes) + NoLegend() + ggtitle(\"Unsup workflow\")\n\nlevel3_sup + level3_unsup"},{"path":"integration.html","id":"downstream-analysis-2","chapter":"5 Integration of metacells","heading":"5.2.9 Downstream analysis","text":"can try conduce downstream analyses previous example 5.1 (clustering, cell type abundances, DEG …).show interest supervised workflow pure metacell can zoom smooth muscle sub types. Despite low metacell number cell type different subtypes separated UMAP, especially rare FAM83D+ smooth muscles discovered original study.Using DEG analysis can check retrieve markers. MYH11 CNN1 genes canonical smooth muscle markers FAM83D found uniquely consistently expressed rare cell type original study","code":"\ncombined.mc$ann <- factor(combined.mc$ann)\ncolor.celltypes.ann <- color.celltypes[c(1:length(levels(combined.mc$ann)))]\nnames(color.celltypes.ann) <- levels(combined.mc$ann)\n\nDimPlot(combined.mc[,combined.mc$ann_level_2 == \"Smooth muscle\"],group.by = \"ann\",cols = color.celltypes.ann)\nDefaultAssay(combined.mc) <- \"RNA\"\nIdents(combined.mc) <- \"ann\"\nmarkersSmoothMuscle <- FindMarkers(combined.mc,ident.1 = \"Smooth muscle FAM83D+\",only.pos = T, logfc.threshold = 0.25, test.use =  wilcox.test)\n\nhead(markersSmoothMuscle)\n#>               p_val avg_log2FC pct.1 pct.2     p_val_adj\n#> MYOCD 4.887974e-176  1.3879478 0.758 0.022 1.369806e-171\n#> NMRK2 1.092465e-129  0.4261093 0.273 0.003 3.061523e-125\n#> PLN   4.060884e-124  3.1234083 0.879 0.044 1.138022e-119\n#> HSPB3 7.779955e-121  1.0321301 0.545 0.016 2.180255e-116\n#> CASQ2 9.830136e-117  1.1149385 0.636 0.023 2.754797e-112\n#> ASB5  2.233460e-107  0.2845419 0.273 0.004 6.259049e-103\n\nmarkersSmoothMuscle[c(\"MYH11\",\"CNN1\",\"FAM83D\"),]\n#>               p_val avg_log2FC pct.1 pct.2    p_val_adj\n#> MYH11  2.489777e-32   4.250912 0.970 0.286 6.977351e-28\n#> CNN1   6.519506e-71   4.627342 0.970 0.106 1.827026e-66\n#> FAM83D 3.395734e-11   2.189551 0.636 0.284 9.516205e-07\n\n# Many classical smooth muscles cells are not annotated at the 3rd level of annotation (labelled None)\nVlnPlot(combined.mc,features = c(\"MYH11\",\"CNN1\",\"FAM83D\"),group.by = \"ann\",ncol = 2,cols = color.celltypes.ann)"},{"path":"integration.html","id":"conclusion-1","chapter":"5 Integration of metacells","heading":"5.2.10 Conclusion","text":"Taking advantage single cell annotation supervised workflow improve precision metacell re-analysis.\ncell annotations given good quality, far case every time, building metacells accordingly \nuse supervised integration workflow preferred.noted used intermediary level annotation supervise analysis, using finer level data resulted\nlonger time metacell building. PLus, obtained metacells per cell type different sample able \nmake efficient supervised batch correction STACAS.precise cost computational efficiency one also try reduce graining level analysis (using graining level 20 instance),conclude, keep mind one hand, certain analysis rare cell type analysis,\nnever achieve level sensitivity metacells compared single-cells.\nhand, certainly won’t able analyze many single-cells easily, may need extremely fine cell-type resolution many analyses.","code":""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
