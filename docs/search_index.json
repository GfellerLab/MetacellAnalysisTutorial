[["index.html", "Metacell Tutorial Chapter 1 About", " Metacell Tutorial Mariia Bilous, Léonard Hérault, Aurélie Gabriel, David Gfeller 2023-07-12 Chapter 1 About The structure of this tutorial. "],["book-structure.html", "1.1 Book structure", " 1.1 Book structure Book consists of several Chapters (i.e., first-level headings). Each chapter is in separate .Rmd file in the root folder, with a name in XY_text.Rmd format, with XY being numbers. Each Chapter consists of sections and sup-sections (i.e., second-level and lower heading), files for which are located in ./sub_pages. Sub-pages and chapters may also call functional_chunks, which are located in ./functional_chunks and represent parts of code that can be repetitively run (e.g., load_anndata, save_mc_anndata etc). When the book is rendered, the included sub_pages and functional_chunks are basically inserted in the Chapter as inline code. The only challenge is the relative path of the files and resulting outputs, such as plots. To resolve this issue, currently, I manually set up the project folder as a knitting root directory in each sub-file (i.e., sub_pages and functional_chunks) as knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) . Also, in my RStudio settings, I have the following setting Tools -&gt; Global Options... -&gt; R Markdown -&gt; Evaluate chunk in directory -&gt; Project. Note: each chapters runs in a new R session and they do not share the environment, thus, we need to provide global knit options for each chapter, otherwise they are lost. I do it with a source('./R/config.R') in the beginning of each chapter. "],["installation-and-requirements.html", "1.2 Installation and requirements", " 1.2 Installation and requirements R requirements install.packages(&#39;rprojroot&#39;) # to reset work directory to the Project root install.packages(&#39;bookdown&#39;) # to render book To run MC2 and SEACells in RStudio, we need install.packages(&#39;reticulate&#39;) # to run Python Then, we need to setup virtual environment pip install virtualenv cd &lt;Path_to_Metacell_tutorial&gt; virtualenv my_env source my_env/bin/activate # Installing SEACells, pip install installs old version, that does not work for me, thus install from git git clone https://github.com/dpeerlab/SEACells.git cd SEACells python setup.py install cd .. pip install -r SEACells_requirements.txt # here some packages have wrong/non-existing vision, so I manually changed their versions pip install ipywidgets pip install jupyter pip install metacells # in project dir echo &#39;RETICULATE_PYTHON=my_env/bin/python&#39; &gt; &#39;.Renviron&#39; # restart RStudio and open &#39;Metacell_tutorial.Rproj&#39; "],["render-book.html", "1.3 Render book", " 1.3 Render book The function to render book is bookdown::render_book(), this will take some time, as it will execute all the chunks in the book, there is an option to cache some chunks, but we have to make sure that cached chunks do not share variables with non-cached chunks (it will raise an error anyway). bookdown::preview_chapter() renders a chapter. "],["get-data.html", "1.4 Get data", " 1.4 Get data To get 3k PBMCs, use scanpy datasets af follows import scanpy as sc import os adata = sc.datasets.pbmc3k() adata_proc = sc.datasets.pbmc3k_processed() adata = adata[adata_proc.obs_names].copy() adata.obs = adata_proc.obs.copy() adata.uns = adata_proc.uns.copy() adata.obsm = adata_proc.obsm.copy() adata.obsp = adata_proc.obsp.copy() sc.pl.embedding(adata, &#39;X_umap&#39;, color=&#39;louvain&#39;) #&gt; /Users/mariiabilous/Documents/PhD/UNIL/R/Metacell_tutorial/my_env_mc2/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via &#39;c&#39;. Parameters &#39;cmap&#39; will be ignored #&gt; cax = scatter( directory = os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;) if not os.path.exists(directory): os.makedirs(directory) adata.write_h5ad(os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;, &quot;singlecell_anndata_filtered.h5ad&quot;)) "],["the-metacell-concept.html", "Chapter 2 The metacell concept", " Chapter 2 The metacell concept See chapters 2.1, 2.2, 2.3 "],["MC2.html", "2.1 Metacell (MC2)", " 2.1 Metacell (MC2) "],["SuperCell.html", "2.2 SuperCell", " 2.2 SuperCell "],["SEACells.html", "2.3 SEACells", " 2.3 SEACells "],["constructing-metacells-for-a-discrete-data.html", "Chapter 3 Constructing metacells (for a ‘discrete’ data)", " Chapter 3 Constructing metacells (for a ‘discrete’ data) In this chapter, we will demonstrate metacell construction using three different methods. MetaCell-2 (MC2) and SEACells in Pyhton and SuperCell in R. For this, we will use a dataset of PBMCs from study. This dataset contains 30K cells and … This is an example of a complex dataset with well defined cells types. For an example of more continuous data, see chapter ?? #&gt; findfont: Font family [&#39;Raleway&#39;] not found. Falling back to DejaVu Sans. #&gt; findfont: Font family [&#39;Lato&#39;] not found. Falling back to DejaVu Sans. "],["mc2-python.html", "3.1 MC2 (Python)", " 3.1 MC2 (Python) Here we construct metacells using Metacell-2 (MC2). The code is adapted from the author’s tutorial. Imports import os import numpy as np import pandas as pd import anndata as ad import scanpy as sc import matplotlib.pyplot as plt import seaborn as sns import metacells as mc import sys sys.path.append(&#39;./mc_QC/&#39;) import mc_QC Parameters MC_tool = &quot;MC2&quot; gamma = 50 # graining level # Here we can modify dataset proj_name = [&quot;cell_lines&quot;, &quot;3k_pbmc&quot;][1] annotation_label = {&#39;cell_lines&#39;:&#39;cell_line&#39;, &#39;3k_pbmc&#39;:&#39;louvain&#39;}[proj_name] # name of annotation field (obs) Load data ## here code to download dataset and store it at f&#39;Metacell_tutorial/data/{proj_name}/singlecell_anndata_filtered.h5ad&#39; # Load pre-filtered data data_folder = os.path.join(&quot;./data/&quot;, proj_name) # here path to folder with adata ad = sc.read(os.path.join(data_folder, &quot;singlecell_anndata_filtered.h5ad&quot;)) Setup MC object mc.ut.set_name(ad, proj_name) Gene filtering according to MC2 excluded_gene_names = [] # for example, [&#39;IGHMBP2&#39;, &#39;IGLL1&#39;, &#39;IGLL5&#39;, &#39;IGLON5&#39;, &#39;NEAT1&#39;, &#39;TMSB10&#39;, &#39;TMSB4X&#39;] excluded_gene_patterns = [&#39;MT-.*&#39;] mc.pl.analyze_clean_genes(ad, excluded_gene_names=excluded_gene_names, excluded_gene_patterns=excluded_gene_patterns, random_seed=123456) #&gt; set 3k_pbmc.var[properly_sampled_gene]: 16579 true (50.64%) out of 32738 bools #&gt; set 3k_pbmc.var[excluded_gene]: 13 true (0.03971%) out of 32738 bools #&gt; set 3k_pbmc.var[noisy_lonely_gene]: 0 true (0%) out of 32738 bools mc.pl.pick_clean_genes(ad) #&gt; set 3k_pbmc.var[clean_gene]: 16566 true (50.6%) out of 32738 bools Cell fintering Since our data is pre-processed and low-quality cells have been already filtered out, this step is not applicable to our data, but we keep this chunk so that you can apply cell filtering to a newly generated dataset. The first round of cell cleaning usually implies filltering out cell with very low and very hight UMI content. The second round includes cell filtering based on mitochondrial and/or ribosomal content. We will skip both steps as our data have been pre-filtered and will use very lenient cutoffs (properly_sampled_min_cell_total, properly_sampled_max_cell_total and properly_sampled_max_excluded_genes_fraction) such that all the cells are kept for the metacell construction. ### The first round (high/low UMIs) properly_sampled_min_cell_total = 200 # setup for the dataset that will be used properly_sampled_max_cell_total = 10000 # setup for the dataset that will be used total_umis_of_cells = mc.ut.get_o_numpy(ad, name=&#39;__x__&#39;, sum=True) df_umis = pd.DataFrame(total_umis_of_cells, columns = [&#39;total_UMIs&#39;]) plt.figure() sns.histplot(data=df_umis, x=&quot;total_UMIs&quot;) plt.xlabel(&#39;UMIs&#39;) plt.ylabel(&#39;Density&#39;) plt.axvline(x=properly_sampled_min_cell_total, color=&#39;darkgreen&#39;) plt.axvline(x=properly_sampled_max_cell_total, color=&#39;crimson&#39;) plt.show() too_small_cells_count = sum(total_umis_of_cells &lt; properly_sampled_min_cell_total) too_large_cells_count = sum(total_umis_of_cells &gt; properly_sampled_max_cell_total) too_small_cells_percent = 100.0 * too_small_cells_count / len(total_umis_of_cells) too_large_cells_percent = 100.0 * too_large_cells_count / len(total_umis_of_cells) print(f&quot;Will exclude %s (%.2f%%) cells with less than %s UMIs&quot; % (too_small_cells_count, too_small_cells_percent, properly_sampled_min_cell_total)) #&gt; Will exclude 0 (0.00%) cells with less than 200 UMIs print(f&quot;Will exclude %s (%.2f%%) cells with more than %s UMIs&quot; % (too_large_cells_count, too_large_cells_percent, properly_sampled_max_cell_total)) #&gt; Will exclude 0 (0.00%) cells with more than 10000 UMIs ## The second round (content of non-clean genes, e.g., mito-genes) properly_sampled_max_excluded_genes_fraction = 0.25 excluded_genes_data = mc.tl.filter_data(ad, var_masks=[&#39;~clean_gene&#39;])[0] excluded_umis_of_cells = mc.ut.get_o_numpy(excluded_genes_data, name=&#39;__x__&#39;, sum=True) excluded_fraction_of_umis_of_cells = excluded_umis_of_cells / total_umis_of_cells df_umis = pd.DataFrame(excluded_fraction_of_umis_of_cells, columns = [&#39;frac_excl_genes_UMIs&#39;]) plt.figure() sns.histplot(df_umis, x = &#39;frac_excl_genes_UMIs&#39;) plt.xlabel(&#39;Fraction of excluded gene UMIs&#39;) plt.ylabel(&#39;Density&#39;) plt.axvline(x=properly_sampled_max_excluded_genes_fraction, color=&#39;crimson&#39;) plt.show() too_excluded_cells_count = sum(excluded_fraction_of_umis_of_cells &gt; properly_sampled_max_excluded_genes_fraction) too_excluded_cells_percent = 100.0 * too_excluded_cells_count / len(total_umis_of_cells) print(f&quot;Will exclude %s (%.2f%%) cells with more than %.2f%% excluded gene UMIs&quot; % (too_excluded_cells_count, too_excluded_cells_percent, 100.0 * properly_sampled_max_excluded_genes_fraction)) #&gt; Will exclude 0 (0.00%) cells with more than 25.00% excluded gene UMIs mc.pl.analyze_clean_cells( ad, properly_sampled_min_cell_total=properly_sampled_min_cell_total, properly_sampled_max_cell_total=properly_sampled_max_cell_total, properly_sampled_max_excluded_genes_fraction=properly_sampled_max_excluded_genes_fraction ) #&gt; set 3k_pbmc.obs[properly_sampled_cell]: 2638 true (100%) out of 2638 bools mc.pl.pick_clean_cells(ad) #&gt; set 3k_pbmc.obs[clean_cell]: 2638 true (100%) out of 2638 bools # Extract clean dataset (with filtered cells and genes) ad = mc.pl.extract_clean_data(ad) #&gt; set 3k_pbmc.clean.obs[full_cell_index]: 2638 int64s #&gt; set 3k_pbmc.clean.var[full_gene_index]: 16566 int64s Running MC2 Metacell-2 uses its own feature selection approach (i.e., selection of genes used to build metacells). Additionally, we can explicitly specify which features to use by providing two arguments: feature_gene_names - genes that have to be used forbidden_gene_names - genes to exclude. In contrast to the SuperCell and SEACells, Metacell-2 does not allow to explicitly obtain metacell data at a user-defined graining level. Instead, to vary graining level, we have to vary a target_metacell_size parameter, that is 160000 by default. Here we provide a chunk to calibrate this value to get a desired graining level. Please, increase or decrease scale if the obtained graining level gamma_obtained is lower or larger than the requested one (gamma). Estimate target_metacell_size (gamma) print(f&#39;The requested graining level is {gamma}, lets estimate the target_metacell_size that should result in such graining level.&#39;) #&gt; The requested graining level is 50, lets estimate the target_metacell_size that should result in such graining level. scale = 2 # increase or decrease if the obtained graining level (`gamma_obtained`) is significantly &gt; or &lt; then the requested one `gamma` N_c = ad.shape[0] # estimated mean UMI content in downsampled data est_downsample_UMI = np.quantile(np.array(total_umis_of_cells), 0.05) target_metacell_size = int(est_downsample_UMI * gamma * scale) target_metacell_size #&gt; 101455 Aggregate metacells mc.pl.divide_and_conquer_pipeline( ad, #feature_gene_names = feature_gene_names, # comment this line to allow Metacell2 selecting features #forbidden_gene_names = forbidden_gene_names, # comment this line to allow Metacell2 selecting features target_metacell_size = target_metacell_size, random_seed = 123456) #&gt; set 3k_pbmc.clean.var[rare_gene]: 0 true (0%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[rare_gene_module]: 16566 int32 elements with all outliers (100%) #&gt; set 3k_pbmc.clean.obs[cells_rare_gene_module]: 2638 int32 elements with all outliers (100%) #&gt; set 3k_pbmc.clean.obs[rare_cell]: 0 true (0%) out of 2638 bools #&gt; set 3k_pbmc.clean.layers[downsampled]: csr_matrix 2638 X 16566 float32s (1218892 &gt; 0) #&gt; set 3k_pbmc.clean.uns[downsample_samples]: 989 #&gt; set 3k_pbmc.clean.var[high_top3_gene]: 552 true (3.332%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[high_total_gene]: 4519 true (27.28%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[high_relative_variance_gene]: 3027 true (18.27%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[feature_gene]: 293 true (1.769%) out of 16566 bools #&gt; set 3k_pbmc.clean.obsp[obs_similarity]: ndarray 2638 X 2638 float32s #&gt; set 3k_pbmc.clean.obsp[obs_outgoing_weights]: csr_matrix 2638 X 2638 float32s (119842 &gt; 0) #&gt; set 3k_pbmc.clean.obs[seed]: 491 outliers (18.61%) out of 2638 int32 elements with 60 groups with mean size 35.78 #&gt; set 3k_pbmc.clean.obs[candidate]: 0 outliers (0%) out of 2638 int32 elements with 63 groups with mean size 41.87 #&gt; set 3k_pbmc.clean.var[gene_deviant_votes]: 936 positive (5.65%) out of 16566 int32s #&gt; set 3k_pbmc.clean.obs[cell_deviant_votes]: 899 positive (34.08%) out of 2638 int32s #&gt; set 3k_pbmc.clean.obs[dissolved]: 10 true (0.3791%) out of 2638 bools #&gt; set 3k_pbmc.clean.obs[metacell]: 909 outliers (34.46%) out of 2638 int64 elements with 62 groups with mean size 27.89 #&gt; set 3k_pbmc.clean.obs[outlier]: 909 true (34.46%) out of 2638 bools #&gt; set 3k_pbmc.clean.uns[pre_directs]: 0 #&gt; set 3k_pbmc.clean.uns[directs]: 1 #&gt; set 3k_pbmc.clean.var[pre_high_total_gene]: * &lt;- 0 #&gt; set 3k_pbmc.clean.var[high_total_gene]: 4519 positive (27.28%) out of 16566 int32s #&gt; set 3k_pbmc.clean.var[pre_high_relative_variance_gene]: * &lt;- 0 #&gt; set 3k_pbmc.clean.var[high_relative_variance_gene]: 3027 positive (18.27%) out of 16566 int32s #&gt; set 3k_pbmc.clean.var[forbidden_gene]: * &lt;- False #&gt; set 3k_pbmc.clean.var[pre_feature_gene]: * &lt;- 0 #&gt; set 3k_pbmc.clean.var[feature_gene]: 293 positive (1.769%) out of 16566 int32s #&gt; set 3k_pbmc.clean.var[pre_gene_deviant_votes]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_cell_directs]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[cell_directs]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_pile]: * &lt;- -1 #&gt; set 3k_pbmc.clean.obs[pile]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_candidate]: * &lt;- -1 #&gt; set 3k_pbmc.clean.obs[pre_cell_deviant_votes]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_dissolved]: * &lt;- False #&gt; set 3k_pbmc.clean.obs[pre_metacell]: * &lt;- -1 ## make anndata of metacells mc_ad = mc.pl.collect_metacells(ad, name=&#39;metacells&#39;) #&gt; set metacells.var[excluded_gene]: 0 true (0%) out of 16566 bools #&gt; set metacells.var[clean_gene]: 16566 true (100%) out of 16566 bools #&gt; set metacells.var[forbidden_gene]: 0 true (0%) out of 16566 bools #&gt; set metacells.var[pre_feature_gene]: 0 positive (0%) out of 16566 int32s #&gt; set metacells.var[feature_gene]: 293 positive (1.769%) out of 16566 int32s #&gt; set metacells.obs[pile]: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] #&gt; set metacells.obs[candidate]: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 15 ] Here we estimate whether a deviation of the obtained gamma is acceptable, and if not, suggest to increase or decrease scale parameter to get better graining level. gamma_obtained = ad.shape[0]/mc_ad.shape[0] print(gamma_obtained) #&gt; 42.54838709677419 gamma_dev = (gamma_obtained - gamma)/gamma if abs(gamma_dev) &lt; 0.3: gamma_dev = 0 if gamma_dev &lt; 0: print(&quot;Increase `target_metacell_size` parameter by increasing `scale` and re-run metacell divide_and_conquer_pipeline() to get larger graining level&quot;) elif gamma_dev &gt; 0: print(&quot;Deacrease `target_metacell_size` parameter by decreasing `scale` and re-run metacell divide_and_conquer_pipeline() to get smaller graining level&quot;) elif gamma_dev == 0: print(&quot;The obtained graining level is acceptable, no need to re-run the metacell divide_and_conquer_pipeline() with a new `target_metacell_size` &quot;) #&gt; The obtained graining level is acceptable, no need to re-run the metacell divide_and_conquer_pipeline() with a new `target_metacell_size` If the obtained graining level is not acceptable and you updated scale parameter according to suggestion, do not forget to re-run chunk ?? ?? Visualize metacells mc.pl.compute_umap_by_features(mc_ad, max_top_feature_genes=1000, min_dist=2.0, random_seed=123456) #&gt; set metacells.var[top_feature_gene]: 293 true (1.769%) out of 16566 bools #&gt; set metacells.obsp[obs_balanced_ranks]: 762 nonzero (19.82%) out of 3844 elements #&gt; set metacells.obsp[obs_pruned_ranks]: 257 nonzero (6.686%) out of 3844 elements #&gt; set metacells.obsp[obs_outgoing_weights]: 257 nonzero (6.686%) out of 3844 elements #&gt; set metacells.obsp[umap_distances]: csr_matrix 62 X 62 float32s (3782 &gt; 0) #&gt; /Users/mariiabilous/Documents/PhD/UNIL/R/Metacell_tutorial/my_env_mc2/lib/python3.8/site-packages/umap/umap_.py:1356: RuntimeWarning: divide by zero encountered in power #&gt; return 1.0 / (1.0 + a * x ** (2 * b)) #&gt; /Users/mariiabilous/Documents/PhD/UNIL/R/Metacell_tutorial/my_env_mc2/lib/python3.8/site-packages/umap/umap_.py:1780: UserWarning: using precomputed metric; inverse_transform will be unavailable #&gt; warn(&quot;using precomputed metric; inverse_transform will be unavailable&quot;) #&gt; set metacells.obs[umap_x]: [ 1.6564819, 10.523616, 0.29960603, 12.346935, -18.181883, 10.824747, 9.3235655, 11.606001, 8.378801, 11.439771, -18.370312, 13.707805, -16.662771, 13.427194, 10.35691, 0.69431365, -16.371231, 8.772759, 8.827683, -15.460641, 10.793309, 4.4988446, -17.57337, 7.6907706, 14.141677, 8.847828, 10.136032, 8.403874, 9.716653, -19.049778, 3.3346436, 8.916034, -17.734402, -19.183643, 2.4466102, 9.458938, 9.972965, 14.90282, 14.809836, 8.051339, 11.39458, 13.204389, 9.030105, 13.247052, -19.935547, 12.671885, 13.710647, 11.188181, -16.07956, 12.613102, 12.006663, 2.273494, 10.232938, -16.919983, 12.528366, 14.898915, 11.630459, -13.0429125, -15.82163, -14.578497, -14.365959, -13.944745 ] #&gt; set metacells.obs[umap_y]: [ 7.753808, 5.679683, 8.05517, 3.7745268, 17.191807, 12.818527, 6.2553945, 17.103827, 4.138062, 11.021334, 20.70879, 13.585729, 20.566952, 12.627911, 18.061642, 6.2272234, 15.916855, 18.031816, 7.2213125, 19.455956, 14.636021, 8.450331, 15.314596, 6.2872787, 6.581571, 14.994367, 3.1421099, 8.773476, 4.545281, 15.859472, 7.0959816, 13.212819, 19.351728, 18.600061, 6.080823, 10.117547, 16.1381, 11.50319, 7.828978, 16.442448, 6.698089, 11.034152, 11.458855, 5.4966006, 17.60186, 14.4407425, 8.617028, 8.6199465, 18.102512, 9.883782, 12.338453, 9.131331, 8.351595, 17.561296, 7.718665, 10.21264, 4.989835, 14.793287, 13.923492, 15.697431, 13.76865, 16.49492 ] umap_x = mc.ut.get_o_numpy(mc_ad, &#39;umap_x&#39;) umap_y = mc.ut.get_o_numpy(mc_ad, &#39;umap_y&#39;) plt.figure() sns.scatterplot(x=umap_x, y=umap_y) plt.show() # make a membership -- index of metacell single cell belongs to ad.obs[&#39;membership&#39;] = [int(i)+1 if i &gt;= 0 else np.nan for i in ad.obs.metacell] ## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object mc_ad.uns = ad.uns.copy() mc_ad.uns[&#39;sc.obs&#39;] = ad.obs.copy() # save the requested gamma mc_ad.uns[&#39;gamma&#39;] = gamma Compute latent space for metacell QC MC2 builds metacells from gene expression data, not from latent space. Some of QC metrics (e.g., compactness and separation) are computed from the latent space. Thus, to compute those metrics, we need to compute latent space. # Save count as a separate layer ad.layers[&#39;counts&#39;] = ad.X # Copy the counts to &quot;.raw&quot; attribute of the anndata since it is necessary for downstream analysis # This step should be performed after filtering raw_ad = sc.AnnData(ad.layers[&#39;counts&#39;]) raw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names ad.raw = raw_ad # Normalize cells, log transform and compute highly variable genes sc.pp.normalize_per_cell(ad) sc.pp.log1p(ad) sc.pp.highly_variable_genes(ad, n_top_genes=1000) # Compute principal components - n_comp = 10 sc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True) # Compute UMAP for visualization sc.pp.neighbors(ad, n_neighbors=10, n_pcs=n_comp) sc.tl.umap(ad) Metacell QC Save output "],["supercell-r.html", "3.2 SuperCell (R)", " 3.2 SuperCell (R) Under construction… "],["seacells-python.html", "3.3 SEACells (Python)", " 3.3 SEACells (Python) Under construction… Replace the following code with ./sub_pages/21-seacells.Rmd Constructing metacells with SEACells. The code is adapted from the authors’ tutorial. SEACells work with Anndata objects and used Scanpy for pre-processing single-cell data and for the analysis of data at the metacell level (for the analysis, see section 4.2). Imports import os import pandas as pd import scanpy as sc import SEACells import random import sys sys.path.append(&#39;./mc_QC/&#39;) import mc_QC Global parameters ## Parameters MC_tool = &quot;SEACell&quot; gamma = 50 # the requested graining level ## Here we can modify dataset proj_name = [&quot;cell_lines&quot;, &quot;3k_pbmc&quot;][1] annotation_label = {&#39;cell_lines&#39;:&#39;cell_line&#39;, &#39;3k_pbmc&#39;:&#39;louvain&#39;}[proj_name] Load data ## here code to download dataset and store it at f&#39;Metacell_tutorial/data/{proj_name}/singlecell_anndata_filtered.h5ad&#39; # Load pre-filtered data data_folder = os.path.join(&quot;./data/&quot;, proj_name) # here path to folder with adata ad = sc.read(os.path.join(data_folder, &quot;singlecell_anndata_filtered.h5ad&quot;)) Saving count layers to a raw attribute as raw counts will be used for metacell aggregation. # Save count as a separate layer ad.layers[&#39;counts&#39;] = ad.X # Copy the counts to &quot;.raw&quot; attribute of the anndata since it is necessary for downstream analysis # This step should be performed after filtering raw_ad = sc.AnnData(ad.layers[&#39;counts&#39;]) raw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names ad.raw = raw_ad Standard pre-processing for single-cell RNA-seq data with Scanpy, for more information, see the Scanpy tutorial. # Normalize cells, log transform and compute highly variable genes sc.pp.normalize_per_cell(ad) sc.pp.log1p(ad) sc.pp.highly_variable_genes(ad, n_top_genes=1000) # Compute principal components - # Here we use 10 components to be consistent with out main tutorial, but fill free to explore other number of principal components to use n_comp = 10 sc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True) # Compute UMAP for visualization sc.pp.neighbors(ad, n_neighbors=10, n_pcs=n_comp) sc.tl.umap(ad) Running SEACells Setting up SEACells parameters ## User defined parameters build_kernel_on = &#39;X_pca&#39; # key in ad.obsm to use for computing metacells # This would be replaced by &#39;X_svd&#39; for ATAC data ## Additional parameters n_waypoint_eigs = 10 # Number of eigenvalues to consider when initializing metacells n_iter = 50 Initialize the SEACell model # set seed for reproducibility random.seed(123) # The number of SEACells is computed as a ratio between the number of single cells and the desired graining level n_SEACells = int(ad.shape[0]/gamma) model = SEACells.core.SEACells(ad, build_kernel_on=build_kernel_on, n_SEACells=n_SEACells, n_waypoint_eigs=n_waypoint_eigs, convergence_epsilon = 1e-5, verbose = True) #&gt; Welcome to SEACells! model.construct_kernel_matrix() M = model.kernel_matrix # Initialize archetypes model.initialize_archetypes() #&gt; Building kernel on X_pca #&gt; Computing diffusion components from X_pca for waypoint initialization ... #&gt; Determing nearest neighbor graph... #&gt; Done. #&gt; Sampling waypoints ... #&gt; Done. #&gt; Selecting 42 cells from waypoint initialization. #&gt; Initializing residual matrix using greedy column selection #&gt; Initializing f and g... #&gt; Selecting 10 cells from greedy initialization. #&gt; #&gt; 0%| | 0/20 [00:00&lt;?, ?it/s] 100%|##########| 20/20 [00:00&lt;00:00, 469.56it/s] # Plot the initialization to ensure they are evenly spread SEACells.plot.plot_initialization(ad, model, plot_basis=&#39;X_umap&#39;) ## error, mb missing some modules Fitting model ## fit model model.fit(min_iter = 10, max_iter = n_iter) #&gt; Randomly initialized A matrix. #&gt; Setting convergence threshold at 0.00088 #&gt; Starting iteration 1. #&gt; Completed iteration 1. #&gt; Starting iteration 10. #&gt; Completed iteration 10. #&gt; Starting iteration 20. #&gt; Completed iteration 20. #&gt; Starting iteration 30. #&gt; Completed iteration 30. #&gt; Converged after 37 iterations. Check model convergence # Check for convergence model.plot_convergence() Aggregate metacells membership membership = model.get_hard_assignments() # aggregate metacells mc_ad = SEACells.core.summarize_by_SEACell(ad, SEACells_label=&#39;SEACell&#39;, summarize_layer=&#39;raw&#39;) #&gt; 0%| | 0/52 [00:00&lt;?, ?it/s] 73%|#######3 | 38/52 [00:00&lt;00:00, 374.72it/s] 100%|##########| 52/52 [00:00&lt;00:00, 391.38it/s] # make `membership` numeric d = {x: int(i)+1 for i, x in enumerate(mc_ad.obs_names)} ad.obs.merge(membership) #&gt; n_genes percent_mito n_counts louvain SEACell #&gt; 0 781 0.030178 2421.0 CD4 T cells SEACell-15 #&gt; 1 781 0.030178 2421.0 CD4 T cells SEACell-15 #&gt; 2 781 0.030178 2421.0 CD4 T cells SEACell-15 #&gt; 3 781 0.030178 2421.0 CD4 T cells SEACell-15 #&gt; 4 781 0.030178 2421.0 CD4 T cells SEACell-15 #&gt; ... ... ... ... ... ... #&gt; 189387 1567 0.021160 5678.0 Dendritic cells SEACell-48 #&gt; 189388 1567 0.021160 5678.0 Dendritic cells SEACell-48 #&gt; 189389 1567 0.021160 5678.0 Dendritic cells SEACell-48 #&gt; 189390 1567 0.021160 5678.0 Dendritic cells SEACell-48 #&gt; 189391 1567 0.021160 5678.0 Dendritic cells SEACell-48 #&gt; #&gt; [189392 rows x 5 columns] ad.obs[&#39;membership&#39;] = [d[x] for x in membership.SEACell] Project metacells on the single-cell umap SEACells.plot.plot_2D(ad, key=&#39;X_umap&#39;, colour_metacells=True) Metacell QC Size distribution #mc_size = SEACells.plot.plot_SEACell_sizes(ad, bins=20) #mc_ad.obs = pd.merge(mc_ad.obs, mc_size, left_index=True, right_index=True) #mc_ad.obs Purity of metacells is a proportion of the most abundant cell type within metacell [ref SuperCell] mc_purity = mc_QC.purity(ad, annotation_label, MC_label = &#39;membership&#39;) mc_purity.head() #&gt; louvain louvain_purity #&gt; membership #&gt; 1 CD4 T cells 0.553571 #&gt; 2 B cells 0.977778 #&gt; 3 CD4 T cells 0.955882 #&gt; 4 CD14+ Monocytes 0.943396 #&gt; 5 NK cells 1.000000 Compactness of metacells is variance of components within metacells [ref SEACells] compactness = mc_QC.compactness(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Compactness_PCA&#39;, n_comp=n_comp)[&#39;Compactness_PCA&#39;] # add compactness to metadata mc_ad.obs = mc_ad.obs.join(compactness) Separation of metacells is a distance to a closest metacell [ref SEACells] separation = mc_QC.separation(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Separation_PCA&#39;, n_comp=n_comp)[&#39;Separation_PCA&#39;] # add separation to metadata mc_ad.obs = mc_ad.obs.join(separation) Inner normalized variance (INV) of metacells is mean-normalized variance of gene expression within metacells [ref MC-2] mc_INV = mc_QC.mc_inner_normalized_var(ad, MC_label = &#39;membership&#39;) mc_INV_val = mc_INV.quantile(0.95, axis=1, numeric_only=True) mc_INV_val = pd.DataFrame(mc_INV_val.transpose()).set_axis([&#39;INV&#39;], axis=1, inplace=False) # add INV to metadata mc_ad.obs = mc_ad.obs.join(mc_INV_val) Save metacell object for further analysis mc_ad.write_h5ad(os.path.join(&#39;..&#39;, &#39;data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) "],["downstream-analysis-of-metacells-for-a-discrete-dataset.html", "Chapter 4 Downstream analysis of metacells (for a discrete dataset)", " Chapter 4 Downstream analysis of metacells (for a discrete dataset) Here we use the obtained metacell to run the downstream analysis on them instead of single-cell data. In this analysis, we treat metacell as single cell, neglecting information about their size (i.e., number of containing single cells). If you are interested in sample-weighted analysis, where metacell size is taken into account, see section 4.4. "],["standard-analysis-r.html", "4.1 Standard analysis (R)", " 4.1 Standard analysis (R) Standard analysis includes dimensionality reduction, clustering, differential expression etc using Seurat [ref] framework. Under construction… 4.1.1 Dimensionality reduction 4.1.2 Clustering 4.1.3 Differential expression analysis "],["standard-analysis-Py.html", "4.2 Standard analysis (Python)", " 4.2 Standard analysis (Python) Standard analysis includes dimensionality reduction, clustering, differential expression etc using Scanpy framework. Under construction… 4.2.1 Dimensionality reduction 4.2.2 Clustering 4.2.3 Differential expression analysis "],["advanced-analysis.html", "4.3 Advanced analysis", " 4.3 Advanced analysis 4.3.1 GRN Gene correlation analysis suffers from large dropout rate of single-cell data and at the same time is very time and memory demanding. Metacells simultaneously adress both issues and thus are beneficial for gene co-expression and gene regulation analysis. Here we demonstrate usage of metacells for GRN analysis using SCENIC [ref]. "],["weighted-analysis.html", "4.4 Sample-weighted analysis", " 4.4 Sample-weighted analysis One of the features of metacells are their size, which is a number of single cell it contains. Since metacells aggregate different number of cells, they also carry different amount of information. And thus, to better reproduce single-cell analysis, bigger metacells should have larger impact on the results than smaller metacells. For this, a sample-weighted analysis can be applied. Sample-weighted analysis is impleented in the SuperCell package. "],["command-line-tool-for-mc-construction.html", "Chapter 5 Command line tool for MC construction", " Chapter 5 Command line tool for MC construction Here is a command line tool to construct metacells using either tool (MC2, SuperCell or SEACells) from a provided dataset. "],["comparison-of-metacells-usage-for-a-discrete-and-continuous-data.html", "Chapter 6 Comparison of metacells usage for a discrete and continuous data", " Chapter 6 Comparison of metacells usage for a discrete and continuous data Under construction… "],["continuous-metacells-have-lower-purity.html", "6.1 Continuous metacells have lower purity", " 6.1 Continuous metacells have lower purity Under construction… "],["data-integration-with-metacells.html", "Chapter 7 Data integration with metacells", " Chapter 7 Data integration with metacells Under construction… "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
