[["index.html", "Metacell Tutorial This tutorial", " Metacell Tutorial Aurélie Gabriel, Léonard Hérault, Mariia Bilous, David Gfeller 2023-11-20 This tutorial In this tutorial, we describe the different steps that should be followed to build metacells1 from single-cell data using three frameworks: SuperCell2 (tutorial in 3.1), (ii) Metacells version 2 (MC23) (tutorial in ??), and (iii) SEACells4 (tutorial in ??). We also show how to obtain metacells by running these methods using a command line tool that we provide as part of the MetacellAnalysisToolkit (MCAT) github repository. This repository also contains the MetacellAnalysisToolkit R package which provides R functions to compute QC metrics and visualization functions to evaluate the quality of metacells. In chapter ??, we use MCAT to build metacells on a continuous dataset of CD34+ cells and use the R package to visualize the constructed metacells. In chapter 4, we describe how to use the R package to evaluate the quality of the metacells. Finally, we provide examples of downstream analyses performed at the metacell level. These analyses include clustering, differential analysis, data integration and gene regulatory network analysis. References "],["requirements.html", "Chapter 1 Requirements", " Chapter 1 Requirements This chapter describes how to obtain the packages and data needed to reproduce the analyses performed in this tutorial. "],["installations.html", "1.1 Installations", " 1.1 Installations 1.1.1 Using conda (recommended) To build a conda environment containing the three metacell building tools used in this tutorial (SuperCell, MC2 and SEACells), please follow the instructions provided in the README of our MetacellAnalysisToolkit github repository. library(reticulate) conda_env &lt;- conda_list()[reticulate::conda_list()$name == &quot;MetacellAnalysisToolkit&quot;,&quot;python&quot;] use_condaenv(conda_env[2] ) 1.1.2 Without conda If you don’t have conda, you can use the following instructions: Set up a python virtual environment with MC2 and SEACells installed: pip install virtualenv virtualenv my_env source my_env/bin/activate # Installing SEACells git clone https://github.com/dpeerlab/SEACells.git cd SEACells python setup.py install cd .. pip install -r SEACells_requirements.txt pip install ipywidgets pip install jupyter # Install MC2 pip install git+https://github.com/tanaylab/metacells In R, install the SuperCell package: remotes::install_github(&quot;GfellerLab/SuperCell&quot;, force = TRUE, upgrade = FALSE) To run python function in R, install reticulate: install.packages(&#39;reticulate&#39;) To use the python libraries installed in the virtual environment, define the RETICULATE_PYTHON variable as follow: echo &#39;RETICULATE_PYTHON=my_env/bin/python&#39; &gt; &#39;.Renviron&#39; "],["PBMC-data.html", "1.2 Retrieve a discrete dataset (PBMCs dataset)", " 1.2 Retrieve a discrete dataset (PBMCs dataset) To test metacell construction on a discrete dataset, we retrieved the 3k PBMCs from scanpy datasets as follows: import scanpy as sc import os adata = sc.datasets.pbmc3k() adata_proc = sc.datasets.pbmc3k_processed() adata = adata[adata_proc.obs_names].copy() adata.obs = adata_proc.obs.copy() adata.uns = adata_proc.uns.copy() adata.obsm = adata_proc.obsm.copy() adata.obsp = adata_proc.obsp.copy() adata.X = adata.X.astype(&quot;float32&quot;) raw_ad = sc.AnnData(adata.X.copy()) raw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names adata.raw = raw_ad The data are saved in the following file for future analyses in python (use of SEACells and MC2): “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. directory = os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;) if not os.path.exists(directory): os.makedirs(directory) adata.write_h5ad(os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;, &quot;singlecell_anndata_filtered.h5ad&quot;)) The data are saved in the following file for future analyses in R (use of SuperCell): “data/3k_pbmc/singlecell_seurat_filtered.rds”. library(reticulate) library(Seurat) #&gt; The legacy packages maptools, rgdal, and rgeos, underpinning this package #&gt; will retire shortly. Please refer to R-spatial evolution reports on #&gt; https://r-spatial.org/r/2023/05/15/evolution4.html for details. #&gt; This package is now running under evolution status 0 #&gt; Attaching SeuratObject library(anndata) adata &lt;- anndata::read_h5ad(file.path(&quot;data/3k_pbmc/singlecell_anndata_filtered.h5ad&quot;)) raw_counts &lt;- Matrix::t(adata$raw$X) colnames(raw_counts) &lt;- rownames(adata$obs) rownames(raw_counts) &lt;- rownames(adata$var) pbmc &lt;- CreateSeuratObject(counts = raw_counts, meta.data = adata$obs) #&gt; Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes #&gt; (&#39;-&#39;) saveRDS(pbmc, file = paste0(&quot;data/3k_pbmc/singlecell_seurat_filtered.rds&quot;)) "],["CD34-data.html", "1.3 Retrieve a continuous dataset (CD34 dataset)", " 1.3 Retrieve a continuous dataset (CD34 dataset) To test metacell construction on discrete dataset, we retrieved the CD34 dataset provided by Persad et al.:5 mkdir data/CD34 wget -O data/CD34/cd34_multiome_rna.h5ad &#39;https://zenodo.org/record/6383269/files/cd34_multiome_rna.h5ad?download=1&#39; import scanpy as sc import os adata = sc.read(os.path.join(&quot;data&quot;, &quot;CD34&quot;, &quot;cd34_multiome_rna.h5ad&quot;)) adata.X.sort_indices() raw_ad = sc.AnnData(adata.X.copy()) raw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names adata.raw = raw_ad sc.pl.embedding(adata, &#39;X_umap&#39;, color=&#39;celltype&#39;) #&gt; /opt/conda/envs/MetacellAnalysisToolkit/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via &#39;c&#39;. Parameters &#39;cmap&#39; will be ignored #&gt; cax = scatter( The data are saved in the following file for future analyses in python (use of SEACells and MC2): “data/CD34/singlecell_anndata_filtered.h5ad”. directory = os.path.join(&quot;data&quot;, &quot;cd34_multiome&quot;) if not os.path.exists(directory): os.makedirs(directory) adata.write_h5ad(os.path.join(&quot;data&quot;, &quot;CD34&quot;, &quot;singlecell_anndata_filtered.h5ad&quot;)) The data are saved in the following file for future analyses in R (use of SuperCell): “data/CD34/singlecell_seurat_filtered.rds”. library(reticulate) library(Seurat) library(anndata) adata &lt;- anndata::read_h5ad(file.path(&quot;data/CD34/singlecell_anndata_filtered.h5ad&quot;)) raw_counts &lt;- Matrix::t(adata$raw$X) colnames(raw_counts) &lt;- rownames(adata$obs) rownames(raw_counts) &lt;- rownames(adata$var) cd34 &lt;- CreateSeuratObject(counts = raw_counts, meta.data = adata$obs) saveRDS(cd34, file = file.path(&quot;data/CD34/singlecell_seurat_filtered.rds&quot;)) References "],["HLCA-data.html", "1.4 Retrieve the lung atlas dataset", " 1.4 Retrieve the lung atlas dataset 1.4.1 Downloading the atlas To illustrate how metacells can be used in the context of single-cell data integration, we used a cell atlas of the human lung (core) available on cellxgene. To download the data, please choose the .h5ad option after clicking on the download button for the core atlas (3 tissues, 584’944 cells). Save these data in the data/HLCA/ directory. Please note that this may take some time (~45 mins) as the file is quite large (5.6 GB). 1.4.2 Splitting atlas by datasets We will use anndata to read in backed mode (saving a lot of memory) the whole atlas and write one h5ad file for each dataset. This should take less than 10 minutes. If you are limited in time feel free to process only a subset of the dataset. t0.split &lt;- Sys.time() library(anndata) adata &lt;- read_h5ad(&quot;data/HLCA/local.h5ad&quot;,backed = &quot;r&quot;) adata$var_names &lt;- adata$var$feature_name # We will use gene short name for downstream analyses datasets &lt;- unique(adata$obs$dat) # If you are limited in time you can process on half of the datasets (uncomment th following line) # datasets &lt;- datasets[1:7] print(dim(adata)) lapply(datasets,FUN = function(x) { dir.create(paste0(&quot;data/HLCA/datasets/&quot;,x),recursive = T) adata.dataset &lt;- AnnData(X = adata[adata$obs$dataset == x]$raw$X, var = adata[adata$obs$dataset == x]$var, obs = adata[adata$obs$dataset == x]$obs) #This will allow us to construct supervised metacell for each cell type in each sample later in the tutorial adata.dataset$obs$ann &lt;- as.character(adata.dataset$obs$ann_level_3) # For cell without an annotation at the 3rd level we will use the second level of annotation adata.dataset$obs$ann[adata.dataset$obs$ann_level_3 == &#39;None&#39;] = as.character(adata.dataset$obs$ann_level_2[adata.dataset$obs$ann_level_3 == &#39;None&#39;]) adata.dataset$obs$ann_sample &lt;- paste0(adata.dataset$obs$ann,&quot;_&quot;,adata.dataset$obs$sample) write_h5ad(adata.dataset,paste0(&quot;data/HLCA/datasets/&quot;,x,&quot;/sc_adata.h5ad&quot;)) } ) remove(adata) gc() tf.split &lt;- Sys.time() tf.split - t0.split "],["the-metacell-concept.html", "Chapter 2 The metacell concept", " Chapter 2 The metacell concept Metacells correspond to partitions of single-cell data into disjoint homogeneous groups of highly similar cells followed by aggregation of their profiles6. This concept relies on the assumption that most of the variability within metacells corresponds to technical noise and not to biologically relevant heterogeneity. Using metacells enables users to: (i) remove the noise while preserving and enhancing biological signal in sparse single-cell genomics data and, (ii) address computational challenges due to the large size of these data. The metacell concept. Several studies have been built upon the metacell concept. In this tutorial, we consider three tools providing standalone metacell construction frameworks and describe the different steps that should be followed to build metacells using these tools: (i) SuperCell7 (tutorial in 3.1), (ii) Metacells version 2 (MC28) (tutorial in ??), and (iii) SEACells9 (tutorial in ??). References "],["Metacell-construction-chapter.html", "Chapter 3 Constructing metacells", " Chapter 3 Constructing metacells In this chapter, we will demonstrate metacell construction using three different methods: SuperCell in R, MetaCell-2 (MC2) and SEACells in Pyhton. For this, we will first use a dataset of PBMCs from study. This dataset contains around 3K cells which is an example of a dataset with well defined cell types. For an example of more continuous data, see chapter ??. "],["SuperCell-construction.html", "3.1 SuperCell (R)", " 3.1 SuperCell (R) In this section, we construct metacells using the R package SuperCell. 3.1.1 Method The SuperCell method first reduces the gene expression space using principal component analysis (PCA) and computes euclidean distances based on the reduced space. Using the euclidean distances, a single-cell kNN graph is built and metacells are identified by applying the walktrap community detection algorithm. The number of metacells obtained can be chosen by the user by defining the graining level parameter. The code provided in this section is adapted from the author’s github documentation. For more information on the method, please refer to our review10 and the original paper.11 Importing R packages To run SuperCell, the following R package needs to be imported: if(system.file(package=&#39;SuperCell&#39;) == &quot;&quot;){ remotes::install_github(&quot;GfellerLab/SuperCell&quot;, force = TRUE, upgrade = FALSE) } library(SuperCell) 3.1.2 Data loading We will run SuperCell on a single-cell dataset composed of 2638 peripheral blood mononuclear cells (PBMCs) available in the scanpy package. Please follow the section 1.2 to retrieve these data from the scanpy package, preprocess and save the data in the following file: “data/3k_pbmc/singlecell_seurat_filtered.rds”. print(proj_name) #&gt; [1] &quot;3k_pbmc&quot; celltype_colors &lt;- c( &quot;CD14+ Monocytes&quot; = &quot;#E69F00&quot;, # orange &quot;B cells&quot; = &quot;#56B4E9&quot;, # sky blue &quot;CD4 T cells&quot; = &quot;#009E73&quot;, # bluish green &quot;NK cells&quot; = &quot;#F0E442&quot;, # yellow &quot;CD8 T cells&quot; = &quot;#0072B2&quot;, # blue &quot;FCGR3A+ Monocytes&quot; = &quot;#D55E00&quot;, # vermillion &quot;Dendritic cells&quot; = &quot;#CC79A7&quot;, # reddish purple &quot;Megakaryocytes&quot; = &quot;#000000&quot; # black ) sc_data = readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) 3.1.3 Filtering steps In this tutorial, the data have been pre-filtered and SuperCell does not require further filtering steps. 3.1.4 Building metacells Metacells construction using SuperCell requires one main input, i.e. a matrix of log-normalized gene expression data which will be used to compute PCA to subsequently build a knn graph for metacells identification. Important optional inputs are: (i) the graining level (gamma parameter), (ii) the number of neighbors to consider for the knn graph (k.knn parameter), (iii) the number of principal components to use to generate the knn graph (n.pc parameter), and (iv) the number of most variable genes to consider for PCA (n.var.genes parameter). Data pre-processing SuperCell builds its knn graph based on Euclidean distances defined in the PCA space. PCA computation is performed on the log-normalized gene expression data in the SCimplify SuperCell function. In the following code chunk, we use Seurat to normalize and visualize the data: library(Seurat) #&gt; The legacy packages maptools, rgdal, and rgeos, underpinning this package #&gt; will retire shortly. Please refer to R-spatial evolution reports on #&gt; https://r-spatial.org/r/2023/05/15/evolution4.html for details. #&gt; This package is now running under evolution status 0 #&gt; Attaching SeuratObject sc_data &lt;- NormalizeData(sc_data, normalization.method = &quot;LogNormalize&quot;) sc_data &lt;- FindVariableFeatures(sc_data, nfeatures = 2000) sc_data &lt;- ScaleData(sc_data) #&gt; Centering and scaling data matrix sc_data &lt;- RunPCA(sc_data, npcs = 50, verbose = F) sc_data &lt;- RunUMAP(sc_data, reduction = &quot;pca&quot;, dims = c(1:50), n.neighbors = 30, verbose = F) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session UMAPPlot(sc_data, group.by = annotation_label, cols = celltype_colors) Setting up SuperCell parameters In this tutorial, we will run SuperCell using the 30 first principal components resulting from the PCA. We chose a graining level of 25 and a number of neighbors of 15 for the knn step. gamma = 10 # the requested graining level. k_knn = 30 # the number of neighbors considered to build the knn network. nb_var_genes = 2000 # number of the top variable genes to use for dimensionality reduction nb_pc = 50 # the number of principal components to use. Metacells identification The metacells are identified using the SCimplify function from the SuperCell package. MC &lt;- SuperCell::SCimplify(Seurat::GetAssayData(sc_data, slot = &quot;data&quot;), # single-cell log-normalized gene expression data k.knn = k_knn, gamma = gamma, # n.var.genes = nb_var_genes, n.pc = nb_pc, genes.use = Seurat::VariableFeatures(sc_data) ) SCimplify returns a list containing the following main elements: (i) the single-cell assignments to metacells (membership), (ii) the metacell sizes (supercell_size), (iii) the single-cell graph (graph.singlecell), (iv) the metacell graph (graph.supercells), (v) the genes used for metacell identification (genes.use). Retrieve aggregated metacell data The supercell_GE() function can be used to generate a metacell counts matrix (aggregation of gene expression across all cells belonging to each metacell). Two modes can be used for single-cell aggregation, i.e. averaging of log-normalized gene expression or summing up raw counts (using the mode parameter). Note that we provide raw counts for the aggregation in this tutorial to match the aggregation steps using PC2 and SEAcells (see ?? and ??). Data normalization will thus be needed for downstream analyses on the metacell counts matrix. MC.GE &lt;- supercell_GE(Seurat::GetAssayData(sc_data, slot = &quot;counts&quot;), MC$membership, mode = &quot;sum&quot; ) dim(MC.GE) #&gt; [1] 32738 264 3.1.5 Annotate metacells (using available annotations) We can assign each metacell to a particular annotation using the supercell_assign() function. By default, this function assigns each metacell to a cluster with the largest Jaccard coefficient to avoid biases towards very rare or very abundant clusters. Alternatively, assignment can be performed using relative (method = \"relative\", may cause biases towards very small populations) or absolute (method = \"absolute\", may cause biases towards large populations) abundance. print(annotation_label) #&gt; 3k_pbmc #&gt; &quot;louvain&quot; MC$annotation &lt;- supercell_assign(clusters = sc_data@meta.data[, annotation_label], # single-cell annotation supercell_membership = MC$membership, # single-cell assignment to metacells method = &quot;absolute&quot; ) head(MC$annotation) #&gt; 1 2 3 4 #&gt; &quot;CD8 T cells&quot; &quot;CD4 T cells&quot; &quot;CD4 T cells&quot; &quot;B cells&quot; #&gt; 5 6 #&gt; &quot;CD14+ Monocytes&quot; &quot;CD4 T cells&quot; The SuperCell package provides the supercell_plot function to visualize the metacell network (igraph object where number of nodes corresponds to number of metacells), which is stored in the MC list in graph.supercells. The metacells can be colored with respect to a vector of annotation. supercell_plot( MC$graph.supercells, group = MC$annotation, seed = 1, alpha = -pi/2, main = &quot;Metacells colored by cell line assignment&quot; ) 3.1.6 Save output For future downstream analyses in R (section 5.1), metacell counts can be saved in a Seurat object. Here we also save in the Seurat object the PCA components and genes used in SCimplify for future QC analysis (See 4). colnames(MC.GE) &lt;- as.character(1:ncol(MC.GE)) MC.seurat &lt;- CreateSeuratObject(counts = MC.GE, meta.data = data.frame(size = as.vector(table(MC$membership))) ) MC.seurat[[annotation_label]] &lt;- MC$annotation # save single-cell membership to metacells in the MC.seurat object MC.seurat@misc$cell_membership &lt;- data.frame(row.names = names(MC$membership), membership = MC$membership) MC.seurat@misc$var_features &lt;- MC$genes.use # Save the PCA components and genes used in SCimplify PCA.res &lt;- irlba::irlba(scale(Matrix::t(sc_data@assays$RNA@data[MC$genes.use, ])), nv = nb_pc) pca.x &lt;- PCA.res$u %*% diag(PCA.res$d) rownames(pca.x) &lt;- colnames(sc_data@assays$RNA@data) MC.seurat@misc$sc.pca &lt;- CreateDimReducObject( embeddings = pca.x, loadings = PCA.res$v, key = &quot;PC_&quot;, assay = &quot;RNA&quot; ) print(paste0(&quot;Saving metacell object for the &quot;, proj_name, &quot; dataset using &quot;, MC_tool)) #&gt; [1] &quot;Saving metacell object for the 3k_pbmc dataset using SuperCell&quot; saveRDS(MC.seurat, file = paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) We can also use the supercell_2_Seurat() function from the SuperCell package. This function takes as inputs the metacell count matrix (output of the SuperCell supercell_GE() function) and the output of the SuperCell SCimplify() function to output a Seurat object containing normalized metacells gene expression data as well as the first (N.comp) principal components of PCA performed internally using user defined set of genes (by default the genes used for metacells constructions). MC.seurat &lt;- supercell_2_Seurat( SC.GE = MC.GE, SC = MC, fields = c(&quot;annotation&quot;, &quot;supercell_size&quot;), # elements of MC to save as metacell metadata var.genes = MC$genes.use, N.comp = 10 ) saveRDS(MC.seurat, file = paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) For future downstream analyses in python (section ??), metacell counts can be saved in an Anndata object: MC.seurat.ad &lt;- anndata::AnnData( X = Matrix::t(Seurat::GetAssayData(MC.seurat, slot = &quot;counts&quot;)), obs = MC.seurat@meta.data ) anndata::write_h5ad(anndata = MC.seurat.ad, filename = paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.h5ad&#39;)) #&gt; used (Mb) gc trigger (Mb) max used (Mb) #&gt; Ncells 3435355 183.5 7655248 408.9 6875190 367.2 #&gt; Vcells 20570981 157.0 54275477 414.1 54275477 414.1 References "],["command-line.html", "3.2 Metacell Analysis Toolkit (MCAT)", " 3.2 Metacell Analysis Toolkit (MCAT) We provide a command line tool allowing users to build metacells using either tool (MC2, SuperCell or SEACells) from a provided dataset. The command line tool takes multiple parameters as input, e.g., number of neighbors considered in the knn, number of components used, graining level. which is for example required in a benchmark setting. setwd(&quot;MetacellToolkit/&quot;) proj_name=&quot;3k_pbmc&quot; MC_tool=&quot;SuperCell&quot; # input raw adata output adata Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s adata # input raw adata output seurat Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s seurat proj_name=&quot;3k_pbmc&quot; MC_tool=&quot;SEACells&quot; # input raw adata output adata Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s adata # input raw adata output seurat Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s seurat "],["QCs.html", "Chapter 4 Metacells QCs", " Chapter 4 Metacells QCs Different metrics have been proposed in previous metacell studies to evaluate the quality of metacells. We propose a R package called MetacellToolkit, to compute and visualize these metrics. The package also provides a function to visualize metacells projected in the single-cell space. Import packages: # if(system.file(package=&#39;MetacellToolkit&#39;) == &quot;&quot;){ # remotes::install_github(&quot;GfellerLab/MetacellAnalysisToolkit@dev_ag&quot;, force = TRUE, upgrade = FALSE) # } library(MetacellAnalysisToolkit) library(Seurat) To explore metacells QCs, we need to load: (i) the single-cell data used to build the metacells and (ii) the metacell data saved in a Seurat object (see chapter 3). # Load the single-cell data sc_data = readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) # Load the metacell data mc_data = readRDS(paste0(&#39;data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) "],["quantitative-metrics.html", "4.1 Quantitative metrics", " 4.1 Quantitative metrics 4.1.1 Purity When available, cell annotations can be used to annotate each metacell to the most abundant cell category (e.g. cell type) composing the metacell (see chapter 3). This also allows us to compute metacell purity. If the annotation considered is the cell type, the purity of a metacell is the proportion of the most abundant cell type within the metacell.12 mc_data$purity &lt;- mc_purity(membership = mc_data@misc$cell_membership$membership, annotation = sc_data@meta.data[, annotation_label]) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;purity&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;purity&quot;, split.by = annotation_label) 4.1.2 Compactness The compactness of a metacell is the variance of the components within the metacell.13 The lower the compactness value the better. This metric as well as the separation metric are computed based on a low embedding of the single-cell data (e.g., PCA). Note that it is important to use the embedding used initially to construc the metacells. In the next chunk, we retrieve the principal components computed for metacell construction (in chapter 3 these principal components were saved in the Seurat objects containing the metacell data) and run UMAP for visualization. sc_data@reductions[[&quot;pca&quot;]] &lt;- mc_data@misc$sc.pca sc_data &lt;- RunUMAP(sc_data, reduction = &quot;pca&quot;, dims = c(1:30), n.neighbors = 15, verbose = F, min.dist = 0.5) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session UMAPPlot(sc_data, group.by = annotation_label, reduction = &quot;umap&quot;) membership_df &lt;- mc_data@misc$cell_membership mc_data$compactness &lt;- mc_compactness(cell.membership = membership_df, sc.obj = sc_data, sc.reduction = &quot;pca&quot;, n.components = 30, diffusion.components = T) #&gt; Computing compactness ... qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;compactness&quot;) #&gt; Warning: Removed 28 rows containing non-finite values (`stat_boxplot()`). qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;compactness&quot;, split.by = annotation_label) #&gt; Warning: Removed 28 rows containing non-finite values (`stat_boxplot()`). 4.1.3 Separation The separation of a metacell is the distance to the closest metacell.14 The higher the separation value the better. mc_data$separation &lt;- mc_separation(cell.membership = membership_df, sc.obj = sc_data, sc.reduction = &quot;pca&quot;, diffusion.components = T) #&gt; Computing separation ... qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;separation&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;separation&quot;, split.by = annotation_label) Note that compactness and separation metrics are correlated, better compactness results in worse separation and vice versa. Metacells from dense regions will have better compactness but worse separation, while metacells from sparse regions will have better separation but worse compactness. library(ggplot2) ggplot(data.frame(compactness = log(mc_data$compactness), separation = log(mc_data$separation)), aes(x=compactness, y=separation)) + geom_point()+ geom_smooth(method=lm) + ggpubr::stat_cor(method = &quot;spearman&quot;) #&gt; `geom_smooth()` using formula = &#39;y ~ x&#39; #&gt; Warning: Removed 28 rows containing non-finite values (`stat_smooth()`). #&gt; Warning: Removed 28 rows containing non-finite values (`stat_cor()`). #&gt; Warning: Removed 28 rows containing missing values (`geom_point()`). 4.1.4 INV The inner normalized variance (INV) of a metacell is the mean-normalized variance of gene expression within the metacell.15 The lower the INV value the better. Note that it is the only metric that is latent-space independent. mc_data$INV &lt;- mc_INV(cell.membership = membership_df, sc.obj = sc_data, group.label = &quot;membership&quot;) #&gt; Counts and data slots are identical. #&gt; Normalizing data ... #&gt; Computing INV ... qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;INV&quot;) #&gt; Warning: Removed 28 rows containing non-finite values (`stat_boxplot()`). qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;INV&quot;, split.by = annotation_label) #&gt; Warning: Removed 28 rows containing non-finite values (`stat_boxplot()`). References "],["size-distribution.html", "4.2 Size distribution", " 4.2 Size distribution The size of a metacell corresponds to the number of single cells it contains. Having a homogeneous metacell size distribution is ideal for downstream analyses, since larger metacells will express more genes, which could confound analyses. When heterogeneous size distributions are obtained we recommend weighted downstream analyses as described in section 5.2. # Seurat::VlnPlot(mc_data, features = &quot;size&quot;, pt.size = 2) # Seurat::VlnPlot(mc_data, features = &quot;size&quot;, pt.size = 2, group.by = annotation_label) hist(mc_data$size, main = &quot;Size distribution&quot;, xlab = &quot;Size&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;size&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;size&quot;, split.by = annotation_label) "],["representativeness-of-metacells.html", "4.3 Representativeness of metacells", " 4.3 Representativeness of metacells To visualize the metacells, we can project the metacells on the single-cell UMAP representation using the mc_projection() function (adapted from the plot.plot_2D() from the SEACells package). A good metacell partition should reproduce the overall structure of the single-cell data by uniformly representing the latent space. To use this function we need the data at the single-cell level (or at least an low-dimensional embedding of the data) and the single-cell membership to each the metacell. mc_projection( sc.obj = sc_data, mc.obj = mc_data, cell.membership = membership_df, sc.reduction = &quot;umap&quot;, sc.label = unlist(annotation_label), # single cells will be colored according the sc.label metacell.label = unlist(annotation_label) # metacells cell will be colored according the metacell.label ) By default the size of the metacells dots is proportionnal to the size of the metacells. Metacells can also be colored by a continuous variable such as one of the QC metrics computed in the previous chunks: mc_projection( sc.obj = sc_data, mc.obj = mc_data, cell.membership = membership_df, sc.reduction = &quot;umap&quot;, sc.label = unlist(annotation_label), # single cells will be colored according the sc.label continuous_metric = TRUE, metric = &quot;compactness&quot; ) "],["downstream-analysis-of-metacells.html", "Chapter 5 Downstream analysis of metacells", " Chapter 5 Downstream analysis of metacells In this chapter, we run standard and advanced downstream analyses on metacells instead of single-cell data. In this analysis, we treat each metacell as a single cell, neglecting information about the size of the metacell (i.e., number of containing single cells). If you are interested in sample-weighted analysis, where metacell size is taken into account, see section 5.2. "],["standard-analysis-R.html", "5.1 Standard analysis (R)", " 5.1 Standard analysis (R) In this tutorial, standard analyses include dimensionality reduction, clustering and differential expression using the Seurat framework. library(Seurat) #&gt; The legacy packages maptools, rgdal, and rgeos, underpinning this package #&gt; will retire shortly. Please refer to R-spatial evolution reports on #&gt; https://r-spatial.org/r/2023/05/15/evolution4.html for details. #&gt; This package is now running under evolution status 0 #&gt; Attaching SeuratObject library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(ggplot2) 5.1.1 Load metacell Seurat object We will use Seurat objects containing the metacells counts data and their annotation (e.g. cell-type annotation) and proceed with standard Seurat downstream analyses. Seurat objects containing metacells counts data and their annotation were generated at the end of sections 3.1 These objects can also be generated using the command line described in chapter 3.2 MC_tool = &quot;SuperCell&quot; proj_name = &quot;3k_pbmc&quot; annotation_column = &quot;louvain&quot; celltype_colors &lt;- c( &quot;CD14+ Monocytes&quot; = &quot;#E69F00&quot;, # orange &quot;B cells&quot; = &quot;#56B4E9&quot;, # sky blue &quot;CD4 T cells&quot; = &quot;#009E73&quot;, # bluish green &quot;NK cells&quot; = &quot;#F0E442&quot;, # yellow &quot;CD8 T cells&quot; = &quot;#0072B2&quot;, # blue &quot;FCGR3A+ Monocytes&quot; = &quot;#D55E00&quot;, # vermillion &quot;Dendritic cells&quot; = &quot;#CC79A7&quot;, # reddish purple &quot;Megakaryocytes&quot; = &quot;#000000&quot; # black ) MC.seurat = readRDS(paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) 5.1.2 Dimensionality reduction As for single-cells, we normalize the raw counts (here aggregated raw counts) and we identify the most variable features in the metacells gene expression data. Based on these features, we run PCA and use the first principal components to obtain a two dimensionnal representation of the data using UMAP. Idents(MC.seurat) &lt;- annotation_column MC.seurat &lt;- NormalizeData(MC.seurat) MC.seurat &lt;- FindVariableFeatures(MC.seurat, selection.method = &quot;vst&quot;, nfeatures = 2000) MC.seurat &lt;- ScaleData(MC.seurat) #&gt; Centering and scaling data matrix MC.seurat &lt;- RunPCA(MC.seurat, verbose = F) MC.seurat &lt;- RunUMAP(MC.seurat, dims = 1:30, verbose = F) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session DimPlot(MC.seurat, reduction = &quot;umap&quot;, cols = celltype_colors) 5.1.3 Clustering We cluster the metacells using Seurat clustering steps and visualize these clusters using UMAP: MC.seurat &lt;- FindNeighbors(MC.seurat, dims = 1:30, reduction = &quot;pca&quot;) #&gt; Computing nearest neighbor graph #&gt; Computing SNN MC.seurat &lt;- FindClusters(MC.seurat, resolution = 1.5) #&gt; Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #&gt; #&gt; Number of nodes: 264 #&gt; Number of edges: 8154 #&gt; #&gt; Running Louvain algorithm... #&gt; Maximum modularity in 10 random starts: 0.5400 #&gt; Number of communities: 6 #&gt; Elapsed time: 0 seconds DimPlot(MC.seurat, reduction = &quot;umap&quot;, group.by = &quot;seurat_clusters&quot;) cluster_colors=celltype_colors names(cluster_colors)=c(0:7) MC.seurat$SCclustering &lt;- SuperCell::supercell_cluster(D = dist(MC.seurat@reductions$pca@cell.embeddings[, 1:30] ), k = 8)$clustering DimPlot(MC.seurat, reduction = &quot;umap&quot;, group.by = &quot;SCclustering&quot;, cols = cluster_colors) 5.1.4 Differential expression analysis We perform diffrential analysis to identify the markers of CD8+ T cells as an example using the FindMarkers function. # Set idents to metacell annotation Idents(MC.seurat) &lt;- annotation_column levels(MC.seurat) &lt;- sort(levels(Idents(MC.seurat))) CD8cells_markers &lt;- FindMarkers(MC.seurat, ident.1 = &quot;CD8 T cells&quot;, only.pos = TRUE) #&gt; For a more efficient implementation of the Wilcoxon Rank Sum Test, #&gt; (default method for FindMarkers) please install the limma package #&gt; -------------------------------------------- #&gt; install.packages(&#39;BiocManager&#39;) #&gt; BiocManager::install(&#39;limma&#39;) #&gt; -------------------------------------------- #&gt; After installation of limma, Seurat will automatically use the more #&gt; efficient implementation (no further action necessary). #&gt; This message will be shown once per session We visualize the top 5 markers for the CD8+ T cells. genes.to.plot &lt;- rownames(CD8cells_markers)[1:5] VlnPlot(MC.seurat, features = genes.to.plot, ncol = 5, pt.size = 0.0, cols = celltype_colors) 5.1.5 Visualize gene-gene correlation We can use the supercell_GeneGenePlot function from the SuperCell package to visualize the correlation between marker genes of a cell-type: (i) at the single-cell level and (ii) at the metacell level. For that, we load the single-cell data from which the metacells were derived from. print(proj_name) #&gt; [1] &quot;3k_pbmc&quot; sc_data &lt;- readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) sc_data &lt;- NormalizeData(sc_data, normalization.method = &quot;LogNormalize&quot;) We visualize gene-gene correlation at the single-cell level: gene_x &lt;- rownames(CD8cells_markers)[1:3] gene_y &lt;- rownames(CD8cells_markers)[4:6] alpha &lt;- 0.7 p.sc &lt;- SuperCell::supercell_GeneGenePlot( GetAssayData(sc_data, slot = &quot;data&quot;), gene_x = gene_x, gene_y = gene_y, clusters = sc_data@meta.data[, annotation_column], sort.by.corr = F, alpha = alpha, color.use = celltype_colors ) p.sc$p We visualize gene-gene correlation at the metacell level: p.MC &lt;- SuperCell::supercell_GeneGenePlot(GetAssayData(MC.seurat, slot = &quot;data&quot;), gene_x = gene_x, gene_y = gene_y, clusters = MC.seurat@meta.data[, annotation_column], sort.by.corr = F, supercell_size = MC.seurat$size, alpha = alpha, color.use = celltype_colors) p.MC$p "],["weighted-analysis.html", "5.2 Sample-weighted analysis", " 5.2 Sample-weighted analysis Code has been modified but text should be updated in this section! library(Seurat) library(dplyr) library(ggplot2) library(SuperCell) 5.2.1 Load metacell Seurat object We will use Seurat objects containing the metacells counts data and their annotation (e.g. and cell-type annotation) and proceed with standard Seurat downstream analyses. Seurat objects containing metacells counts data and their annotation were generated at the end of sections 3.1 These objects can also be generated using the command line described in chapter 3.2 MC_tool = &quot;SuperCell&quot; proj_name = &quot;3k_pbmc&quot; annotation_column = &quot;louvain&quot; MC.seurat = readRDS(paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) 5.2.2 Dimensionality reduction As for single-cells, we normalize the raw counts (here aggregated raw counts) and we identify the most variable features in the metacells gene expression data. Based on these features, we run PCA and use the first principal components to obtain a two dimensionnal representation of the data using UMAP. MC.seurat &lt;- NormalizeData(MC.seurat, normalization.method = &quot;LogNormalize&quot;) MC_list &lt;- list(N.SC = ncol(MC.seurat), supercell_size = MC.seurat$size) MC_list$PCA &lt;- supercell_prcomp( Matrix::t(GetAssayData(MC.seurat, slot = &quot;data&quot;)), genes.use = MC.seurat@misc$var_features, # or a new set of HVG can be computed supercell_size = MC_list$supercell_size, # provide this parameter to run sample-weighted version of PCA, k = 10 ) MC_list$UMAP &lt;- supercell_UMAP( SC = MC_list, PCA_name = &quot;PCA&quot;, n_neighbors = 15 # large number to repel cells ) supercell_DimPlot(SC = MC_list, groups = MC.seurat@meta.data[, annotation_column], dim.name = &quot;UMAP&quot;, title = paste0(&quot;UMAP of metacells colored by cell type assignment&quot;) ) 5.2.3 Clustering We cluster the metacells using Seurat clustering steps and visualize these clusters using UMAP: # compute distance among metacells D &lt;- dist(MC_list$PCA$x) # cluster metacells MC_list$clustering &lt;- supercell_cluster(D = D, k = 8, supercell_size = MC_list$supercell_size) # Plot clustering result supercell_DimPlot( MC_list, groups = factor(MC_list$clustering$clustering), dim.name = &quot;UMAP&quot;, title = paste0(&quot;UMAP of metacells colored by metacell clustering&quot;) ) 5.2.4 Differential expression analysis # Compute upregulated genes in each cell line (versus other cells) MC.all.markers &lt;- supercell_FindAllMarkers( ge = GetAssayData(MC.seurat, slot = &quot;data&quot;), clusters = MC.seurat@meta.data[, annotation_column], supercell_size = MC_list$supercell_size, only.pos = TRUE, min.pct = 0, logfc.threshold = 0.2 ) We select the top markers for each cell-type: # Transform the output of `supercell_FindAllMarkers()` to be in the format of the `Seurat::FindAllMarkers()` MC.all.markers.df &lt;- data.frame() for(cl in names(MC.all.markers)){ cur &lt;- MC.all.markers[[cl]] if(is.data.frame(cur)){ cur$cluster &lt;- cl cur$gene &lt;- rownames(cur) cur$avg_log2FC &lt;- cur$logFC MC.all.markers.df &lt;- rbind(MC.all.markers.df, cur) } } # Top markers (select top markers of each cell line) MC.top.markers &lt;- MC.all.markers.df %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC) We visualize the top 5 markers for the XX cells. Idents(MC.seurat) &lt;- annotation_column # genes.to.plot &lt;- MC.seurat.top.markers$gene[MC.seurat.top.markers$cluster == unique(MC.seurat@meta.data[,annotation_column])[1]] genes.to.plot &lt;- MC.top.markers$gene[c(seq(1, 20, 5))] VlnPlot(MC.seurat, features = genes.to.plot, ncol = 4, pt.size = 0.0) "],["integration.html", "Chapter 6 Integration of metacells ", " Chapter 6 Integration of metacells "],["integration_unsupervised.html", "6.1 Unsupervised integration", " 6.1 Unsupervised integration In this section, we will work with the Human Cell Lung Atlas core HLCA gathering around 580,000 cells from 107 individuals distributed in 166 samples. The aim of this tutorial is to show how you can use metacells to analyze a very large dataset using a reasonable amount of time and memory. For this we will use here SuperCell via the MCAT command line tool. 6.1.1 Data loading Please follow the section 1.4 to retrieve the HLCA atlas, divide the atlas by dataset and save the splitted data in the following folder: “data/HLCA/”. 6.1.2 Setting up the environment First we need to specify that we will work with the MetacellAnalysisToolkit conda environment (needed for anndata relying on reticulate and the MCAT tool). To build the conda environment please follow the instructions on our MetacellAnalysisToolkit github repository. library(reticulate) conda_env &lt;- conda_list()[reticulate::conda_list()$name == &quot;MetacellAnalysisToolkit&quot;,&quot;python&quot;] use_condaenv(conda_env) library(Seurat) #&gt; The legacy packages maptools, rgdal, and rgeos, underpinning this package #&gt; will retire shortly. Please refer to R-spatial evolution reports on #&gt; https://r-spatial.org/r/2023/05/15/evolution4.html for details. #&gt; This package is now running under evolution status 0 #&gt; Attaching SeuratObject library(anndata) library(SuperCell) library(ggplot2) color.celltypes &lt;- c(&#39;#E5D2DD&#39;, &#39;#53A85F&#39;, &#39;#F1BB72&#39;, &#39;#F3B1A0&#39;, &#39;#D6E7A3&#39;, &#39;#57C3F3&#39;, &#39;#476D87&#39;, &#39;#E95C59&#39;, &#39;#E59CC4&#39;, &#39;#AB3282&#39;, &#39;#23452F&#39;, &#39;#BD956A&#39;, &#39;#8C549C&#39;, &#39;#585658&#39;, &#39;#9FA3A8&#39;, &#39;#E0D4CA&#39;, &#39;#5F3D69&#39;, &#39;#58A4C3&#39;, &quot;#b20000&quot;,&#39;#E4C755&#39;, &#39;#F7F398&#39;, &#39;#AA9A59&#39;, &#39;#E63863&#39;, &#39;#E39A35&#39;, &#39;#C1E6F3&#39;, &#39;#6778AE&#39;, &#39;#91D0BE&#39;, &#39;#B53E2B&#39;, &#39;#712820&#39;, &#39;#DCC1DD&#39;, &#39;#CCE0F5&#39;, &#39;#CCC9E6&#39;, &#39;#625D9E&#39;, &#39;#68A180&#39;, &#39;#3A6963&#39;, &#39;#968175&#39;) 6.1.3 Building metacell We build metacells with the MCAT command line using SuperCell (-t SuperCell). To facilitate downstream analysis of the donors we build metacells for each sample in each dataset (-a sample). Here we will use 2000 highly variable genes (-f 2000) to compute the PCA from which we used 50 principal components (-m 50) to build a k = 30 (-k 30) nearest neighbor graph on which the metacells are identified using a graining level of 50 (-g 50). We use an adata .h5ad output format (-s adata) as it is faster to write and lighter to store than a Seurat .rds object. This step takes around 20 min with multiple cores (-l 6). Be aware that parallel processing requires more memory (32 GB of memory required for 6 cores). If you are limited in memory you should still be able to process the samples by reducing the number of cores (e.g. -l 3) or by sequentially processing the samples (just remove the -l) in a slightly longer time. start=`date +%s` for d in data/HLCA/datasets/*; do /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/MetacellAnalysisToolkit/cli/MCAT -t SuperCell -i $d/sc_adata.h5ad -o $d -a sample -l 3 -n 50 -f 2000 -k 30 -g 50 -s adata done echo &quot;Duration: $((($(date +%s)-$start)/60)) minutes&quot; 6.1.4 Loading metacell objects We load the .h5ad objects and directly convert them in Seurat objects to benefit from all the functions of this framework. datasets &lt;- list.dirs(&quot;data/HLCA/datasets/&quot;, full.names = F, recursive = F) metacell.files &lt;- sapply(datasets[1:5] , FUN = function(x){paste0(&quot;data/HLCA/datasets/&quot;,x,&quot;/mc_adata.h5ad&quot;)}) metacell.objs &lt;- lapply(X = metacell.files, function(X){ adata &lt;- read_h5ad(X) countMatrix &lt;- Matrix::t(adata$X) colnames(countMatrix) &lt;- adata$obs_names rownames(countMatrix) &lt;- adata$var_names sobj &lt;- Seurat::CreateSeuratObject(counts = countMatrix,meta.data = adata$obs) sobj &lt;- RenameCells(sobj, add.cell.id = unique(sobj$sample)) # we give unique name to metacells return(sobj) }) 6.1.5 Merging objects and basic quality control Given the single-cell metadata, the MCAT tool automatically assigns annotations to metacells and computes purities for all the categorical variables present in the metadata of the input single-cell object. Thus, we can check the purity of our metacells at different levels of annotations, as well as their size (number of single cells they contain). To do so we merge the object together and use the Seurat VlnPlot function. unintegrated.mc &lt;- merge(metacell.objs[[1]], metacell.objs[-1]) VlnPlot(unintegrated.mc, features = c(&quot;size&quot;, &quot;ann_level_1_purity&quot;), group.by = &#39;dataset&#39;, pt.size = 0.001, ncol = 2) VlnPlot(unintegrated.mc, features = c(&quot;ann_level_2_purity&quot;, &quot;ann_level_3_purity&quot;), group.by = &#39;dataset&#39;, pt.size = 0.001, ncol = 2) We can also use box plots. ggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_2_purity, fill = dataset)) + geom_boxplot() + scale_x_discrete(guide = guide_axis(angle = 45)) ggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_3_purity, fill = dataset)) + geom_boxplot() + scale_x_discrete(guide = guide_axis(angle = 45)) ggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_level_4_purity, fill = dataset)) + geom_boxplot() + scale_x_discrete(guide = guide_axis(angle = 45)) ggplot(unintegrated.mc@meta.data,aes(x = dataset, y = ann_finest_level_purity, fill = dataset)) + geom_boxplot() + scale_x_discrete(guide = guide_axis(angle = 45)) Overall metacells from the different datasets present a good purity until the third level of annotation. 6.1.6 Unintegrated analysis Let’s first do a standard dimensionality reduction without batch correction. DefaultAssay(unintegrated.mc) &lt;- &quot;RNA&quot; unintegrated.mc &lt;- NormalizeData(unintegrated.mc) unintegrated.mc &lt;- FindVariableFeatures(unintegrated.mc) unintegrated.mc &lt;- ScaleData(unintegrated.mc) unintegrated.mc &lt;- RunPCA(unintegrated.mc) unintegrated.mc &lt;- RunUMAP(unintegrated.mc, dims = 1:30) umap.unintegrated.datasets &lt;- DimPlot(unintegrated.mc,reduction = &quot;umap&quot;,group.by = &quot;dataset&quot;) + NoLegend() + ggtitle(&quot;unintegrated datasets&quot;) umap.unintegrated.types &lt;- DimPlot(unintegrated.mc, reduction = &quot;umap&quot;, group.by = &quot;ann_level_2&quot;, label = T, repel = T, cols = color.celltypes)+ NoLegend() + ggtitle(&quot;unintegrated cell types&quot;) umap.unintegrated.datasets + umap.unintegrated.types remove(unintegrated.mc) # we won&#39;t use the unintegrated object anymore gc() You can see on the plots that a batch effect is clearly present at the metacell level with metacells clustering by datasets inside the major cell types. Let’s correct it. 6.1.7 Seurat integration Here we will use the standard Seurat_v4 batch correction workflow. As in the original study, we use the dataset rather than the donor as the batch parameter. See method section “Data integration benchmarking” of the original study for more details. This should take less than 5 minutes. # normalize each dataset metacell.objs &lt;- lapply(X = metacell.objs, FUN = function(x) { DefaultAssay(x) &lt;- &quot;RNA&quot;; x &lt;- RenameCells(x, add.cell.id = unique(x$sample)) # we give unique name to metacells x &lt;- NormalizeData(x) x &lt;- FindVariableFeatures(x, selection.method = &quot;vst&quot;, nfeatures = 2000) return(x)}) features &lt;- SelectIntegrationFeatures(object.list = metacell.objs) metacell.objs &lt;- lapply(X = metacell.objs, FUN = function(x) { x &lt;- ScaleData(x, features = features, verbose = FALSE) x &lt;- RunPCA(x, features = features, verbose = FALSE) }) anchors &lt;- FindIntegrationAnchors(object.list = metacell.objs, anchor.features = features, reduction = &quot;rpca&quot;, reference = c(1,2,5), #,9,11 the 5 biggest datasets (in term of metacell number) are used as reference dims = 1:30) remove(metacell.objs) # We don&#39;t need the object list anymore gc() combined.mc &lt;- IntegrateData(anchorset = anchors,k.weight = 50) # we have to update the k.weight parameters because the smallest dataset contain less than 100 metacells Check the obtained object. combined.mc #&gt; An object of class Seurat #&gt; 30024 features across 6061 samples within 2 assays #&gt; Active assay: integrated (2000 features, 2000 variable features) #&gt; 1 other assay present: RNA We can verify that the sum of metacell sizes corresponds to the original number of single-cells sum(combined.mc$size) #&gt; [1] 302920 Seurat returns the slot \"integrated\" that we can use for the downstream analysis. DefaultAssay(combined.mc) = &quot;integrated&quot; combined.mc &lt;- ScaleData(combined.mc, verbose = FALSE) combined.mc &lt;- RunPCA(combined.mc, npcs = 30, verbose = FALSE) combined.mc &lt;- RunUMAP(combined.mc, reduction = &quot;pca&quot;, dims = 1:30, verbose = FALSE) combined.mc &lt;- RunUMAP(combined.mc, dims = 1:30,reduction = &quot;pca&quot;,reduction.name = &quot;umap&quot;, verbose = FALSE) Now we can make the plots and visually compare the results with the unintegrated analysis. umap.integrated.datasets &lt;- DimPlot(combined.mc,reduction = &quot;umap&quot;,group.by = &quot;dataset&quot;) + NoLegend() + ggtitle(&quot;integrated datasets&quot;) umap.integrated.celltypes &lt;- DimPlot(combined.mc,reduction = &quot;umap&quot;,group.by = &quot;ann_level_2&quot;,label = T,repel = T,cols = color.celltypes) + NoLegend() + ggtitle(&quot;integrated cell types&quot;) umap.integrated.datasets + umap.integrated.celltypes + umap.unintegrated.datasets + umap.unintegrated.types Seurat efficiently corrected the batch effect in the data while keeping the cell type separated, but other batch correction methods such as harmony would have also done the job. Note that In the original study, datasets were integrated using SCANVI semi-supervised integration using partial annotation obtained for each dataset prior integration. If you are interested in such supervised approach at the metacell level in R you can have a look to our second example in section @ref(integration_supervised) using the STACAS package. We can navigate in the different annotation levels. library(ggplot2) DimPlot(combined.mc,group.by = &quot;ann_level_1&quot;,reduction = &quot;umap&quot;,label = T,repel = T,cols= color.celltypes) + NoLegend() DimPlot(combined.mc,group.by = &quot;ann_level_2&quot;,reduction = &quot;umap&quot;,label = T,repel = T,cols= color.celltypes) + NoLegend() DimPlot(combined.mc,group.by = &quot;ann_level_3&quot;,reduction = &quot;umap&quot;,label = T, repel = T,cols= color.celltypes) + NoLegend() 6.1.8 Downstream analysis 6.1.8.1 Clustering We cluster the metacells based on the corrected PCA space by Seurat. DefaultAssay(combined.mc) &lt;- &quot;integrated&quot; combined.mc &lt;- FindNeighbors(combined.mc, reduction = &quot;pca&quot;, dims = 1:30) combined.mc &lt;- FindClusters(combined.mc, resolution = 0.5) UMAPPlot(combined.mc, label = T) + NoLegend() 6.1.8.2 Deferentially expressed gene (DEG) analysis. Now let’s found the markers of the cluster 19 we’ve just identified. DefaultAssay(combined.mc) &lt;- &quot;RNA&quot; markers18 &lt;- FindMarkers(combined.mc, ident.1 = 18, only.pos = T) #&gt; For a more efficient implementation of the Wilcoxon Rank Sum Test, #&gt; (default method for FindMarkers) please install the limma package #&gt; -------------------------------------------- #&gt; install.packages(&#39;BiocManager&#39;) #&gt; BiocManager::install(&#39;limma&#39;) #&gt; -------------------------------------------- #&gt; After installation of limma, Seurat will automatically use the more #&gt; efficient implementation (no further action necessary). #&gt; This message will be shown once per session head(markers18) #&gt; p_val avg_log2FC pct.1 pct.2 p_val_adj #&gt; HOXD9 0 0.8120847 0.968 0.020 0 #&gt; DTX1 0 0.3972931 0.871 0.021 0 #&gt; STAB2 0 0.4492518 0.758 0.006 0 #&gt; SCN3A 0 0.3283766 0.806 0.012 0 #&gt; GPR182 0 0.6745167 0.952 0.013 0 #&gt; HOXD8 0 1.1639281 1.000 0.025 0 This cluster clearly presents a B cell signature with marker genes such as CD19 and PAX5 genes &lt;-c(&quot;CD19&quot;,&quot;PAX5&quot;) # knwon mast cells markers markers18[genes,] #&gt; p_val avg_log2FC pct.1 pct.2 p_val_adj #&gt; NA NA NA NA NA NA #&gt; NA.1 NA NA NA NA NA VlnPlot(combined.mc, genes, ncol = 1) By looking at the metacell annotation (assigned from the original single-cell metadata by MCAT), we can verify that we correctly retrieved the B cell lineage cluster. DimPlot(combined.mc[, combined.mc$integrated_snn_res.0.5 == 18], group.by = c(&quot;ann_level_3&quot;, &quot;integrated_snn_res.0.5&quot;), ncol = 2) 6.1.8.3 Cell type abundances analyses. We can easily make analysis of cell type abundances for different clinical variables as we construct metacell by sample. We have to take metacell size into account for these analyses. For instance we can analyse the proportion of different epithelial cell types depending on the smoking status. library(reshape2) combined.mc.epith &lt;- combined.mc[,combined.mc$ann_level_1 == &quot;Epithelial&quot;] #combined.metacells$major_type &lt;- droplevels(combined.metacells$major_type) smpCounts &lt;- aggregate(combined.mc.epith$size, by=list(sample = combined.mc.epith$sample, major_type = combined.mc.epith$ann_level_3, smoking_status = combined.mc.epith$smoking_status), FUN=sum) remove(combined.mc.epith) gc() ggplot(smpCounts,aes(x = smoking_status,fill=major_type)) + geom_bar(position = &quot;fill&quot;) + scale_fill_manual(values = color.celltypes) + xlab(&quot;% epithelial cells&quot;) Samples from smokers seem to present more AT2 cells but this quick analysis is for illustrative purposes only. In practice it’s far more complex to draw conclusion as we should have considered the variations between samples/donors as well as many other technical (tissue dissociation protocol, tissue sampling method, single-cell platform, … ) and biological (BMI, sex, Age, …) variables. 6.1.9 Conclusion Overall we made a precise simplification of the original atlas using metacells built from each sample separately. By reducing the size of the original atlas by a factor of 50 we could load the data, make an integration to correct batch effect and recapitulate the main different cell types using a reasonable amount of time and memory. In contrast, simply loading the original single-cell data in R using Seurat is extremely time-consuming and challenging even for the most powerful computers. In this first example we used a fully unsupervised workflow and did not use any prior biological knowledge. Authors of the original study made a remarkable work annotating the hundreds of thousands cells of the atlas. In the second example in section @ref(integration_supervised) we propose a supervised workflow using this annotation to guide both the metacell identification and the batch correction. We can save the results for comparison with the second example. saveRDS(combined.mc,&quot;data/HLCA/combined.mc.unsup.rds&quot;) "],["integration_supervised.html", "6.2 Supervised integration", " 6.2 Supervised integration "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
