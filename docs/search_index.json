[["index.html", "Metacell Tutorial Chapter 1 This tutorial", " Metacell Tutorial Mariia Bilous, Léonard Hérault, Aurélie Gabriel, David Gfeller 2023-11-07 Chapter 1 This tutorial In this tutorial, we describe the different steps that should be followed to build metacells from single-cell data using three frameworks: SuperCell (tutorial in 4.1), (ii) Metacells version 2 (MC2) (tutorial in 4.2), and (iii) SEACells (tutorial in 4.3). We also show how to obtain metacells by running these methods using a command line tool that we provide as part of the MetaCellToolkit github repository. This repository also contain the MetacellToolkit R package which provides R functions to compute QC metrics and visualizations to evaluate the quality of metacells. In chapter 5, we describe how to use this package to evaluate the quality of the metacells. Finally, we provide examples of downstream analyses performed at the metacell level. These analyses include clustering, differential analysis, data integration and gene regulatory network analysis. TO_CACHE &lt;- TRUE "],["requirements.html", "Chapter 2 Requirements", " Chapter 2 Requirements This chapter describes how to obtain the packages and data needed to reproduce the analyses performed in this tutorial. "],["installations.html", "2.1 Installations", " 2.1 Installations To run the code provided in this tutorial please follow the following instructions: "],["PBMC-data.html", "2.2 Retrieve the discrete dataset (PBMCs dataset)", " 2.2 Retrieve the discrete dataset (PBMCs dataset) To test metacell construction on discrete dataset, we retrieved the 3k PBMCs from scanpy datasets as follows : import scanpy as sc import os adata = sc.datasets.pbmc3k() adata_proc = sc.datasets.pbmc3k_processed() adata = adata[adata_proc.obs_names].copy() adata.obs = adata_proc.obs.copy() adata.uns = adata_proc.uns.copy() adata.obsm = adata_proc.obsm.copy() adata.obsp = adata_proc.obsp.copy() raw_ad = sc.AnnData(adata.X.copy()) raw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names adata.raw = raw_ad The data are saved in the following file for future analyses in python (use of SEACells and MC2): “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. directory = os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;) if not os.path.exists(directory): os.makedirs(directory) adata.write_h5ad(os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;, &quot;singlecell_anndata_filtered.h5ad&quot;)) The data are saved in the following file for future analyses in R (use of SuperCell): “data/3k_pbmc/singlecell_seurat_filtered.rds”. library(reticulate) library(Seurat) raw_counts &lt;- Matrix::t(as(py$adata$raw$X, &quot;CsparseMatrix&quot;)) colnames(raw_counts) &lt;- rownames(py$adata$obs) rownames(raw_counts) &lt;- rownames(py$adata$var) pbmc &lt;- CreateSeuratObject(counts = raw_counts, meta.data = py$adata$obs) #&gt; Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes #&gt; (&#39;-&#39;) saveRDS(pbmc, file = paste0(&quot;data/3k_pbmc/singlecell_seurat_filtered.rds&quot;)) "],["CD34-data.html", "2.3 Retrieve the continuous dataset (CD34 dataset)", " 2.3 Retrieve the continuous dataset (CD34 dataset) To test metacell construction on discrete dataset, we retrieved the CD34 dataset provided by Persad et al. (SEACells?) : mkdir data/CD34 wget -O data/CD34/cd34_multiome_rna.h5ad &#39;https://zenodo.org/record/6383269/files/cd34_multiome_rna.h5ad?download=1&#39; The data are saved in the following file for future analyses in python (use of SEACells and MC2): “data/CD34/singlecell_anndata_filtered.h5ad”. import scanpy as sc import os adata = sc.read(os.path.join(&quot;data&quot;, &quot;CD34&quot;, &quot;cd34_multiome_rna.h5ad&quot;)) adata.X.sort_indices() raw_ad = sc.AnnData(adata.X.copy()) raw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names adata.raw = raw_ad sc.pl.embedding(adata, &#39;X_umap&#39;, color=&#39;celltype&#39;) #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/Metacell_tutorial/my_env/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via &#39;c&#39;. Parameters &#39;cmap&#39; will be ignored #&gt; cax = scatter( directory = os.path.join(&quot;data&quot;, &quot;cd34_multiome&quot;) if not os.path.exists(directory): os.makedirs(directory) adata.write_h5ad(os.path.join(&quot;data&quot;, &quot;CD34&quot;, &quot;singlecell_anndata_filtered.h5ad&quot;)) The data are saved in the following file for future analyses in R (use of SuperCell): “data/CD34/singlecell_seurat_filtered.rds”. library(reticulate) library(Seurat) raw_counts &lt;- Matrix::t(as(py$adata$raw$X, &quot;CsparseMatrix&quot;)) colnames(raw_counts) &lt;- rownames(py$adata$obs) rownames(raw_counts) &lt;- rownames(py$adata$var) cd34 &lt;- CreateSeuratObject(counts = raw_counts, meta.data = py$adata$obs) saveRDS(cd34, file = paste0(&quot;data/CD34/singlecell_seurat_filtered.rds&quot;)) "],["the-metacell-concept.html", "Chapter 3 The metacell concept", " Chapter 3 The metacell concept Metacells correspond to partitions of single-cell data into disjoint homogeneous groups of highly similar cells followed by aggregation of their profiles. This concept relies on the assumption that most of the variability within metacells corresponds to technical noise and not to biologically relevant heterogeneity. Using metacells enables users to: (i) removing the noise while preserving and enhancing biological signal in sparse single-cell genomics data and, (ii) address computational challenges due to the large size of these data. The metacell concept. Several studies have been built upon the metacell concept. In this tutorial, we consider three tools providing standalone metacell construction frameworks and describe the different steps that should be followed to build metacells using these tools: (i) SuperCell (tutorial in 4.1), (ii) Metacells version 2 (MC2) (tutorial in 4.2), and (iii) SEACells (tutorial in 4.3). "],["Metacell-construction-chapter.html", "Chapter 4 Constructing metacells (for ‘discrete’ data)", " Chapter 4 Constructing metacells (for ‘discrete’ data) In this chapter, we will demonstrate metacell construction using three different methods: SuperCell in R, MetaCell-2 (MC2) and SEACells in Pyhton. For this, we will first use a dataset of PBMCs from study. This dataset contains around 3K cells which is an example of a dataset with well defined cell types. For an example of more continuous data, see chapter ??. #&gt; findfont: Font family [&#39;Raleway&#39;] not found. Falling back to DejaVu Sans. #&gt; findfont: Font family [&#39;Lato&#39;] not found. Falling back to DejaVu Sans. "],["SuperCell-construction.html", "4.1 SuperCell (R)", " 4.1 SuperCell (R) In this section, we construct metacells using the R package SuperCell. 4.1.1 Method The SuperCell method first reduces the gene expression space using principal component analysis (PCA) and computes euclidean distances based on the reduced space. Using the euclidean distances, a single-cell kNN graph is built and metacells are identified by applying the walktrap community detection algorithm. The number of metacells obtained can be chosen by the user by defining the graining level parameter. The code provided in this section is adapted from the author’s github documentation. For more information on the method, please refer to our review (Review?) and the original paper (SuperCell?). Importing R packages To run SuperCell, the following R package needs to be imported: if(system.file(package=&#39;SuperCell&#39;) == &quot;&quot;){ remotes::install_github(&quot;GfellerLab/SuperCell&quot;, force = TRUE, upgrade = FALSE) } library(SuperCell) 4.1.2 Data loading We will run SuperCell on a single-cell dataset composed of 2638 peripheral blood mononuclear cells (PBMCs) available in the scanpy package. Please follow the section 2.2 to retrieve these data from the scanpy package, preprocess and save the data in the following file: “data/3k_pbmc/singlecell_seurat_filtered.rds”. print(proj_name) #&gt; [1] &quot;3k_pbmc&quot; sc_data = readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) 4.1.3 Filtering steps In this tutorial, the data have been pre-filtered and SuperCell does not require further filtering steps. 4.1.4 Building metacells Metacells construction using SuperCell requires one main inputs, i.e. a matrix of log-normalized gene expression data which will be used to compute PCA to subsequently build a knn graph for metacells identification. Important optional inputs are: (i) the graining level (gamma parameter), (ii) the number of neighbors to consider for the knn graph (k.knn parameter), (iii) the number of principal components to use to generate the knn graph (n.pc parameter), and (iv) the number of most variable genes to consider for PCA (n.var.genes parameter). Data pre-processing SuperCell builds its knn graph based on Euclidean distances defined in the PCA space. PCA computation is performed on the log-normalized gene expression data in the SCimplify SuperCell function. In the following code chunk, we use Seurat to normalize and visualize the data: library(Seurat) #&gt; Attaching SeuratObject sc_data &lt;- NormalizeData(sc_data, normalization.method = &quot;LogNormalize&quot;) sc_data &lt;- FindVariableFeatures(sc_data, nfeatures = 2000) sc_data &lt;- ScaleData(sc_data) #&gt; Centering and scaling data matrix sc_data &lt;- RunPCA(sc_data, npcs = 30, verbose = F) sc_data &lt;- RunUMAP(sc_data, reduction = &quot;pca&quot;, dims = c(1:30), n.neighbors = 15, verbose = F) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session UMAPPlot(sc_data, group.by = annotation_label) Setting up SuperCell parameters In this tutorial, we will run SuperCell using the 30 first principal components resulting from the PCA. We chose a graining level of 25 and a number of neighbors of 15 for the knn step. gamma = 25 # the requested graining level. k_knn = 15 # the number of neighbors considered to build the knn network. nb_var_genes = 2000 # number of the top variable genes to use for dimensionality reduction nb_pc = 30 # the number of principal components to use. Metacells identification The metacells are identified using the SCimplify function from the SuperCell package. MC &lt;- SuperCell::SCimplify(Seurat::GetAssayData(sc_data, slot = &quot;data&quot;), # single-cell log-normalized gene expression data k.knn = k_knn, gamma = gamma, n.var.genes = nb_var_genes, n.pc = nb_pc ) SCimplify returns a list containing the following main elements: (i) the single-cell assignments to metacells (membership), (ii) the metacell sizes (supercell_size), (iii) the single-cell graph (graph.singlecell), (iv) the metacell graph (graph.supercells), (v) the genes used for metacell identification (genes.use). Retrieve aggregated metacell data The supercell_GE() function can be used to generate a metacell counts matrix (aggregation of gene expression across all cells belonging to each metacell). Two modes can be used for single-cell aggregation, i.e. averaging of log-normalized gene expression or summing up raw counts (using the mode parameter). Note that we provide raw counts for the aggregation in this tutorial to match the aggregation steps using PC2 and SEAcells (see 4.2 and 4.3). Data normalization will thus be needed for downstream analyses on the metacell counts matrix. MC.GE &lt;- supercell_GE(Seurat::GetAssayData(sc_data, slot = &quot;counts&quot;), MC$membership, mode = &quot;sum&quot; ) dim(MC.GE) #&gt; [1] 32738 106 4.1.5 Annotate metacells (using available annotations) We can assign each metacell to a particular annotation using the supercell_assign() function. By default, this function assigns each metacell to a cluster with the largest Jaccard coefficient to avoid biases towards very rare or very abundant clusters. Alternatively, assignment can be performed using relative (method = \"relative\", may cause biases towards very small populations) or absolute (method = \"absolute\", may cause biases towards large populations) abundance. print(annotation_label) #&gt; 3k_pbmc #&gt; &quot;louvain&quot; MC$annotation &lt;- supercell_assign(clusters = sc_data@meta.data[, annotation_label], # single-cell annotation supercell_membership = MC$membership, # single-cell assignment to metacells method = &quot;jaccard&quot; ) head(MC$annotation) #&gt; 1 2 3 4 #&gt; &quot;CD14+ Monocytes&quot; &quot;CD14+ Monocytes&quot; &quot;CD14+ Monocytes&quot; &quot;CD4 T cells&quot; #&gt; 5 6 #&gt; &quot;CD4 T cells&quot; &quot;Dendritic cells&quot; The SuperCell package provides the supercell_plot function to visualize the metacell network (igraph object where number of nodes corresponds to number of metacells), which is stored in the MC list in graph.supercells. The metacells can be colored with respect to a vector of annotation. supercell_plot( MC$graph.supercells, group = MC$annotation, seed = 1, alpha = -pi/2, main = &quot;Metacells colored by cell line assignment&quot; ) 4.1.6 Save output For future downstream analyses in R (section 6.1), metacell counts can be saved in a Seurat object. Here we also save in the Seurat object the PCA components and genes used in SCimplify for future QC analysis (See 5). colnames(MC.GE) &lt;- as.character(1:ncol(MC.GE)) MC.seurat &lt;- CreateSeuratObject(counts = MC.GE, meta.data = data.frame(size = as.vector(table(MC$membership))) ) MC.seurat[[annotation_label]] &lt;- MC$annotation # save single-cell membership to metacells in the MC.seurat object MC.seurat@misc$cell_membership &lt;- data.frame(row.names = names(MC$membership), membership = MC$membership) MC.seurat@misc$var_features &lt;- MC$genes.use # Save the PCA components and genes used in SCimplify PCA.res &lt;- irlba::irlba(scale(Matrix::t(sc_data@assays$RNA@data[MC$genes.use, ])), nv = nb_pc) pca.x &lt;- PCA.res$u %*% diag(PCA.res$d) rownames(pca.x) &lt;- colnames(sc_data@assays$RNA@data) MC.seurat@misc$sc.pca &lt;- CreateDimReducObject( embeddings = pca.x, loadings = PCA.res$v, key = &quot;PC_&quot;, assay = &quot;RNA&quot; ) print(paste0(&quot;Saving metacell object for the &quot;, proj_name, &quot; dataset using &quot;, MC_tool)) #&gt; [1] &quot;Saving metacell object for the 3k_pbmc dataset using SuperCell&quot; saveRDS(MC.seurat, file = paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) We can also use the supercell_2_Seurat() function from the SuperCell package. This function takes as inputs the metacell count matrix (output of the SuperCell supercell_GE() function) and the output of the SuperCell SCimplify() function to output a Seurat object containing normalized metacells gene expression data as well as the first (N.comp) principal components of PCA performed internally using user defined set of genes (by default the genes used for metacells constructions). MC.seurat &lt;- supercell_2_Seurat( SC.GE = MC.GE, SC = MC, fields = c(&quot;annotation&quot;, &quot;supercell_size&quot;), # elements of MC to save as metacell metadata var.genes = MC$genes.use, N.comp = 10 ) saveRDS(MC.seurat, file = paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) For future downstream analyses in python (section 6.2), metacell counts can be saved in an Anndata object: #&gt; used (Mb) gc trigger (Mb) max used (Mb) #&gt; Ncells 3064161 163.7 5181401 276.8 5181401 276.8 #&gt; Vcells 18101117 138.2 225369907 1719.5 281711725 2149.3 "],["MC2-construction.html", "4.2 MC2 (Python)", " 4.2 MC2 (Python) In this section, we construct metacells using Metacell-2 (MC2) implemented in Python. 4.2.1 Method Metacell-2 (MC2) is a python tool to construct metacells and is the updated version of the MetaCell algorithm, which introduced the concept of metacell. MC2 applies a two-phase divide-and-conquer approach. Cells are randomly divided into piles of ~10k cells and initial metacells are built applying a MetaCell-like approach per pile, i.e. based on a single-cell kNN graph built from log-normalized counts using a set of highly variable genes. Then, transcriptionally similar metacells are grouped into metagroup piles for the identification of final metacells and outliers identification. Note that prior to metacell identification, the MC2 framework recommends gene filtering steps. The choice of the genes used by the method is of high importance to assure good quality of the metacells. The code provided in this section is adapted from the author’s tutorial. For more information on the method, please refer to our review (Review?) and the (MC2?). Importing python packages To run MC2, the following python packages need to be imported: import os import numpy as np import pandas as pd import anndata as ad import scanpy as sc import matplotlib.pyplot as plt import seaborn as sns import metacells as mc If you don’t have these packages installed, please refer to the section 2.1. 4.2.2 Data loading We will run Metacell-2 (MC2) on a single-cell dataset composed of around 3000 peripheral blood mononuclear cells (PBMCs). Please follow the section 2.2 to retrieve these data from the scanpy package and save the data in the following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. MC_tool = &quot;MC2&quot; proj_name = &quot;3k_pbmc&quot; ad = sc.read(os.path.join(&quot;data&quot;, proj_name, &quot;singlecell_anndata_filtered.h5ad&quot;)) ad.X = ad.raw.X.copy() We initialize the name of the anndata (in the unstructured annotations) object using the mc.ut.set_name() function from the MC2 package. mc.ut.set_name(ad, proj_name) 4.2.3 Filtering steps MC2 requires that standard filtering steps such as doublet filtering are performed outside of the MC2 framework. In addition to standard data filtering steps, the MC2 package proposes functions to filter the single-cell data at the gene and at the cell level (See author’s vignette). At the gene level, the filtering steps consist in excluding genes based on biological knowledge (e.g. mitochrondrial genes) as well as based on their expression levels. The latter genes include genes with zero expression or low expression levels and “bursty lonely genes” (i.e., genes with high expression levels but no correlation with any other gene). At the cell level, filtering is performed based on cells UMI counts. Gene filtering In the following code chunk, we exclude genes using the mc.pl.exclude_genes()function from the MC2 package. Based on the authors vignette, we consider a minimal list of genes to exclude, i.e., sex-specific and non-coding genes as well as the mitochondrial genes. To complete this list of genes, an iterative approach can be used following the guidelines of the MC2 authors in a second vignette. The mc.pl.exclude_genes() function will filter out: i) the known-to-be-excluded genes defined by the user as gene names or gene names patterns (EXCLUDED_GENE_NAMES and EXCLUDED_GENE_PATTERNS parameters respectively), and ii) the “bursty lonely genes”. EXCLUDED_GENE_NAMES = [&quot;XIST&quot;, &quot;MALAT1&quot;, &quot;NEAT1&quot;] EXCLUDED_GENE_PATTERNS = [&#39;MT-.*&#39;] mc.pl.exclude_genes( ad, excluded_gene_names=EXCLUDED_GENE_NAMES, excluded_gene_patterns=EXCLUDED_GENE_PATTERNS, random_seed=123456 ) #&gt; set 3k_pbmc.var[bursty_lonely_gene]: 0 true (0%) out of 32738 bools #&gt; set 3k_pbmc.var[properly_sampled_gene]: 16579 true (50.64%) out of 32738 bools #&gt; set 3k_pbmc.var[excluded_gene]: 16174 true (49.4%) out of 32738 bools Cell filtering based on UMIs counts In the MC2 framework, cells with very low and very high UMI content will be filtered out (PROPERLY_SAMPLED_MIN_CELL_TOTAL, PROPERLY_SAMPLED_MAX_CELL_TOTAL variables defining thresholds in the next code chunk). Also, cell filtering based on UMI counts in excluded genes is also performed(PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION variable). Since our dataset has been pre-filtered, very lenient cutoffs will be used in this tutorial. The following code chunk defines these parameters. To adapt them to your datasets, we advise you to explore the distributions of total UMI counts and UMI counts in excluded genes, as recommended and described in the MC2 original vignette. PROPERLY_SAMPLED_MIN_CELL_TOTAL = 200 PROPERLY_SAMPLED_MAX_CELL_TOTAL = 10000 PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION = 0.25 The number of UMIs in excluded genes is computed using the mc.tl.compute_excluded_gene_umis() function and cells are filtered out using the mc.pl.exclude_cells() function. Additional cells can be filtered out by adding a cell description columns in the obs data frame in the anndata oject. This annotation should be a boolean indicating whether the cell should filtered out or not. The name of this column should be provided to the mc.pl.exclude_cells() function via the additional_cells_masks parameter. mc.tl.compute_excluded_gene_umis(ad) mc.pl.exclude_cells( ad, properly_sampled_min_cell_total=PROPERLY_SAMPLED_MIN_CELL_TOTAL, properly_sampled_max_cell_total=PROPERLY_SAMPLED_MAX_CELL_TOTAL, properly_sampled_max_excluded_genes_fraction=PROPERLY_SAMPLED_MAX_EXCLUDED_GENES_FRACTION # , # additional_cells_masks=[&quot;|doublet_cell&quot;] ) #&gt; set 3k_pbmc.obs[properly_sampled_cell]: 2638 true (100%) out of 2638 bools #&gt; set 3k_pbmc.obs[excluded_cell]: 0 true (0%) out of 2638 bools After performing the two-step filtering (genes and cells), the “cleaned” data can be extracted using the mc.pl.extract_clean_data() function. # Extract clean dataset (with filtered cells and genes) ad = mc.pl.extract_clean_data(ad) #&gt; set 3k_pbmc.clean.obs[full_cell_index]: 2638 int32s #&gt; set 3k_pbmc.clean.var[full_gene_index]: 16564 int32s 4.2.4 Building metacells Defining lateral genes To build metacells, we need to define lateral genes, which are genes with strong biological signal which is independent of cell-state, e.g. cell-cycle genes. These genes will be ignored for computing cells similarity and building metacells but will be considered to define outlier cells (i.e., expression levels of lateral genes should be consistent within metacells). In the following chunk, we consider a minimal list of lateral genes (provided by the MC2 authors) including cell-cycle and ribosomal genes and mark them in the MC2 object using the mc.pl.mark_lateral_genes() function. LATERAL_GENE_NAMES = [ &quot;ACSM3&quot;, &quot;ANP32B&quot;, &quot;APOE&quot;, &quot;AURKA&quot;, &quot;B2M&quot;, &quot;BIRC5&quot;, &quot;BTG2&quot;, &quot;CALM1&quot;, &quot;CD63&quot;, &quot;CD69&quot;, &quot;CDK4&quot;, &quot;CENPF&quot;, &quot;CENPU&quot;, &quot;CENPW&quot;, &quot;CH17-373J23.1&quot;, &quot;CKS1B&quot;, &quot;CKS2&quot;, &quot;COX4I1&quot;, &quot;CXCR4&quot;, &quot;DNAJB1&quot;, &quot;DONSON&quot;, &quot;DUSP1&quot;, &quot;DUT&quot;, &quot;EEF1A1&quot;, &quot;EEF1B2&quot;, &quot;EIF3E&quot;, &quot;EMP3&quot;, &quot;FKBP4&quot;, &quot;FOS&quot;, &quot;FOSB&quot;, &quot;FTH1&quot;, &quot;G0S2&quot;, &quot;GGH&quot;, &quot;GLTSCR2&quot;, &quot;GMNN&quot;, &quot;GNB2L1&quot;, &quot;GPR183&quot;, &quot;H2AFZ&quot;, &quot;H3F3B&quot;, &quot;HBM&quot;, &quot;HIST1H1C&quot;, &quot;HIST1H2AC&quot;, &quot;HIST1H2BG&quot;, &quot;HIST1H4C&quot;, &quot;HLA-A&quot;, &quot;HLA-B&quot;, &quot;HLA-C&quot;, &quot;HLA-DMA&quot;, &quot;HLA-DMB&quot;, &quot;HLA-DPA1&quot;, &quot;HLA-DPB1&quot;, &quot;HLA-DQA1&quot;, &quot;HLA-DQB1&quot;, &quot;HLA-DRA&quot;, &quot;HLA-DRB1&quot;, &quot;HLA-E&quot;, &quot;HLA-F&quot;, &quot;HMGA1&quot;, &quot;HMGB1&quot;, &quot;HMGB2&quot;, &quot;HMGB3&quot;, &quot;HMGN2&quot;, &quot;HNRNPAB&quot;, &quot;HSP90AA1&quot;, &quot;HSP90AB1&quot;, &quot;HSPA1A&quot;, &quot;HSPA1B&quot;, &quot;HSPA6&quot;, &quot;HSPD1&quot;, &quot;HSPE1&quot;, &quot;HSPH1&quot;, &quot;ID2&quot;, &quot;IER2&quot;, &quot;IGHA1&quot;, &quot;IGHA2&quot;, &quot;IGHD&quot;, &quot;IGHG1&quot;, &quot;IGHG2&quot;, &quot;IGHG3&quot;, &quot;IGHG4&quot;, &quot;IGHM&quot;, &quot;IGKC&quot;, &quot;IGKV1-12&quot;, &quot;IGKV1-39&quot;, &quot;IGKV1-5&quot;, &quot;IGKV3-15&quot;, &quot;IGKV4-1&quot;, &quot;IGLC2&quot;, &quot;IGLC3&quot;, &quot;IGLC6&quot;, &quot;IGLC7&quot;, &quot;IGLL1&quot;, &quot;IGLL5&quot;, &quot;IGLV2-34&quot;, &quot;JUN&quot;, &quot;JUNB&quot;, &quot;KIAA0101&quot;, &quot;LEPROTL1&quot;, &quot;LGALS1&quot;, &quot;LINC01206&quot;, &quot;LTB&quot;, &quot;MCM3&quot;, &quot;MCM4&quot;, &quot;MCM7&quot;, &quot;MKI67&quot;, &quot;MT2A&quot;, &quot;MYL12A&quot;, &quot;MYL6&quot;, &quot;NASP&quot;, &quot;NFKBIA&quot;, &quot;NUSAP1&quot;, &quot;PA2G4&quot;, &quot;PCNA&quot;, &quot;PDLIM1&quot;, &quot;PLK3&quot;, &quot;PPP1R15A&quot;, &quot;PTMA&quot;, &quot;PTTG1&quot;, &quot;RAN&quot;, &quot;RANBP1&quot;, &quot;RGCC&quot;, &quot;RGS1&quot;, &quot;RGS2&quot;, &quot;RGS3&quot;, &quot;RP11-1143G9.4&quot;, &quot;RP11-160E2.6&quot;, &quot;RP11-53B5.1&quot;, &quot;RP11-620J15.3&quot;, &quot;RP5-1025A1.3&quot;, &quot;RP5-1171I10.5&quot;, &quot;RPS10&quot;, &quot;RPS10-NUDT3&quot;, &quot;RPS11&quot;, &quot;RPS12&quot;, &quot;RPS13&quot;, &quot;RPS14&quot;, &quot;RPS15&quot;, &quot;RPS15A&quot;, &quot;RPS16&quot;, &quot;RPS17&quot;, &quot;RPS18&quot;, &quot;RPS19&quot;, &quot;RPS19BP1&quot;, &quot;RPS2&quot;, &quot;RPS20&quot;, &quot;RPS21&quot;, &quot;RPS23&quot;, &quot;RPS24&quot;, &quot;RPS25&quot;, &quot;RPS26&quot;, &quot;RPS27&quot;, &quot;RPS27A&quot;, &quot;RPS27L&quot;, &quot;RPS28&quot;, &quot;RPS29&quot;, &quot;RPS3&quot;, &quot;RPS3A&quot;, &quot;RPS4X&quot;, &quot;RPS4Y1&quot;, &quot;RPS4Y2&quot;, &quot;RPS5&quot;, &quot;RPS6&quot;, &quot;RPS6KA1&quot;, &quot;RPS6KA2&quot;, &quot;RPS6KA2-AS1&quot;, &quot;RPS6KA3&quot;, &quot;RPS6KA4&quot;, &quot;RPS6KA5&quot;, &quot;RPS6KA6&quot;, &quot;RPS6KB1&quot;, &quot;RPS6KB2&quot;, &quot;RPS6KC1&quot;, &quot;RPS6KL1&quot;, &quot;RPS7&quot;, &quot;RPS8&quot;, &quot;RPS9&quot;, &quot;RPSA&quot;, &quot;RRM2&quot;, &quot;SMC4&quot;, &quot;SRGN&quot;, &quot;SRSF7&quot;, &quot;STMN1&quot;, &quot;TK1&quot;, &quot;TMSB4X&quot;, &quot;TOP2A&quot;, &quot;TPX2&quot;, &quot;TSC22D3&quot;, &quot;TUBA1A&quot;, &quot;TUBA1B&quot;, &quot;TUBB&quot;, &quot;TUBB4B&quot;, &quot;TXN&quot;, &quot;TYMS&quot;, &quot;UBA52&quot;, &quot;UBC&quot;, &quot;UBE2C&quot;, &quot;UHRF1&quot;, &quot;YBX1&quot;, &quot;YPEL5&quot;, &quot;ZFP36&quot;, &quot;ZWINT&quot; ] LATERAL_GENE_PATTERNS = [&quot;RP[LS].*&quot;] # Ribosomal # This will mark as &quot;lateral_gene&quot; any genes that match the above, if they exist in the clean dataset. mc.pl.mark_lateral_genes( ad, lateral_gene_names=LATERAL_GENE_NAMES, lateral_gene_patterns=LATERAL_GENE_PATTERNS, ) #&gt; set 3k_pbmc.clean.var[lateral_gene]: 225 true (1.358%) out of 16564 bools Some genes have higher variances than expected which could lead to false positive outlier identification. Users can mark those genes as noisy genes using the mc.pl.mark_noisy_genes() function. NOISY_GENE_NAMES = [ &quot;CCL3&quot;, &quot;CCL4&quot;, &quot;CCL5&quot;, &quot;CXCL8&quot;, &quot;DUSP1&quot;, &quot;FOS&quot;, &quot;G0S2&quot;, &quot;HBB&quot;, &quot;HIST1H4C&quot;, &quot;IER2&quot;, &quot;IGKC&quot;, &quot;IGLC2&quot;, &quot;JUN&quot;, &quot;JUNB&quot;, &quot;KLRB1&quot;, &quot;MT2A&quot;, &quot;RPS26&quot;, &quot;RPS4Y1&quot;, &quot;TRBC1&quot;, &quot;TUBA1B&quot;, &quot;TUBB&quot; ] # This will mark as &quot;noisy_gene&quot; any genes that match the above, if they exist in the clean dataset. mc.pl.mark_noisy_genes(ad, noisy_gene_names=NOISY_GENE_NAMES) #&gt; set 3k_pbmc.clean.var[noisy_gene]: 17 true (0.1026%) out of 16564 bools To extend this list of lateral genes, users can use the relate_to_lateral_genes function to identify genes that are highly correlated with the predefined lateral genes. The use of this function is described in the vignette from the MC2 authors. Define target_metacell_size (graining level) By default, MC2 will build metacells with a size of 96 cells per metacells. Users can vary the target_metacell_size parameter to reach a desired graining level. gamma = 25 target_metacell_size = gamma Metacells identification using the divide and conquer approach The construction of metacells by MC2 is performed using the mc.pl.divide_and_conquer_pipeline() function. Note that by default all cores of the system will be used for the metacells construction. To change this behavior and adapt the number of cores the MC2 authors propose to use the mc.pl.guess_max_parallel_piles() and mc.pl.set_max_parallel_piles() functions to adapt the number of processed in parallel depending on the available memory. The mc.pl.divide_and_conquer_pipeline() function associates each cell to a metacell or defines the cell as outlier. These assignments are found in the obs layer of the anndata object. max_parallel_piles = mc.pl.guess_max_parallel_piles(ad) mc.pl.set_max_parallel_piles(max_parallel_piles) mc.pl.divide_and_conquer_pipeline( ad, target_metacell_size = target_metacell_size, random_seed = 123456) #&gt; set 3k_pbmc.clean.var[selected_gene]: * -&gt; False #&gt; set 3k_pbmc.clean.var[rare_gene]: 0 true (0%) out of 16564 bools #&gt; set 3k_pbmc.clean.var[rare_gene_module]: 16564 int32 elements with all outliers (100%) #&gt; set 3k_pbmc.clean.obs[cells_rare_gene_module]: 2638 int32 elements with all outliers (100%) #&gt; set 3k_pbmc.clean.obs[rare_cell]: 0 true (0%) out of 2638 bools #&gt; set 3k_pbmc.clean.var[selected_gene]: 256 true (1.546%) out of 16564 bools #&gt; set 3k_pbmc.clean.obs[metacell]: 2638 int32s #&gt; set 3k_pbmc.clean.obs[dissolved]: 45 true (1.706%) out of 2638 bools #&gt; set 3k_pbmc.clean.obs[metacell_level]: 2638 int32s ad.obs.metacell.head #&gt; &lt;bound method NDFrame.head of index #&gt; AAACATACAACCAC-1 66 #&gt; AAACATTGAGCTAC-1 87 #&gt; AAACATTGATCAGC-1 84 #&gt; AAACCGTGCTTCCG-1 91 #&gt; AAACCGTGTATGCG-1 110 #&gt; ... #&gt; TTTCGAACTCTCAT-1 112 #&gt; TTTCTACTGAGGCA-1 74 #&gt; TTTCTACTTCCTCG-1 113 #&gt; TTTGCATGAGAGGC-1 57 #&gt; TTTGCATGCCTCAC-1 82 #&gt; Name: metacell, Length: 2638, dtype: int32&gt; The following code chunk adds a columns (named membership) containing the single_cell assignments to the obs attribute in the single-cell anndata object. The membership information is required to compute metacells quality metrics as shown in chapter 5. # make a membership -- index of metacells to which single cells belong to ad.obs[&#39;membership&#39;] = [int(i)+1 if i &gt;= 0 else np.nan for i in ad.obs.metacell] Retrieve aggregated metacell data The function mc.pl.collect_metacells() should be used to subsequently retrieve an anndata object containing the data at the metacells level instead of the single-cell level. This function will store in the X data matrix of the anndata object a matrix of gene fraction (i.e., the sum of all gene levels in a metacell sums to 1) and it will store the total UMIs per gene per metacell in the layer total_umis. mc_ad = mc.pl.collect_metacells(ad, name=&#39;metacells&#39;, random_seed = 123456) #&gt; set metacells.obs[grouped]: 122 int64s #&gt; set metacells.obs[total_umis]: 122 float64s #&gt; set metacells.layers[total_umis]: ndarray 122 X 16564 float32s #&gt; set metacells.obs[__zeros_downsample_umis]: 122 int64s #&gt; set metacells.layers[zeros]: ndarray 122 X 16564 int32s #&gt; set 3k_pbmc.clean.obs[metacell_name]: 2638 &lt;U8s #&gt; set metacells.var[gene_ids]: 16564 objects #&gt; set metacells.var[bursty_lonely_gene]: 0 true (0%) out of 16564 bools #&gt; set metacells.var[properly_sampled_gene]: 16564 true (100%) out of 16564 bools #&gt; set metacells.var[excluded_gene]: 0 true (0%) out of 16564 bools #&gt; set metacells.var[full_gene_index]: 16564 int32s #&gt; set metacells.var[lateral_gene]: 225 true (1.358%) out of 16564 bools #&gt; set metacells.var[noisy_gene]: 17 true (0.1026%) out of 16564 bools #&gt; set metacells.var[selected_gene]: 256 true (1.546%) out of 16564 bools #&gt; set metacells.var[rare_gene]: 0 true (0%) out of 16564 bools #&gt; set metacells.var[rare_gene_module]: 16564 int32s #&gt; set metacells.obs[metacells_rare_gene_module]: 122 int32s #&gt; set metacells.obs[rare_metacell]: 0 true (0%) out of 122 bools #&gt; set metacells.uns[outliers]: 161 #&gt; set metacells.uns[metacells_algorithm]: metacells.0.9.0 mc_ad.shape #&gt; (122, 16564) mc_ad.X.sum(axis=1)[:5] #&gt; matrix([[1. ], #&gt; [1. ], #&gt; [1. ], #&gt; [1. ], #&gt; [0.99999994]], dtype=float32) mc_ad.layers[&#39;total_umis&#39;] #&gt; array([[1., 0., 0., ..., 0., 0., 0.], #&gt; [0., 0., 0., ..., 0., 1., 0.], #&gt; [0., 0., 0., ..., 0., 0., 2.], #&gt; ..., #&gt; [0., 0., 0., ..., 0., 2., 3.], #&gt; [0., 0., 0., ..., 0., 0., 0.], #&gt; [1., 0., 0., ..., 0., 1., 0.]], dtype=float32) 4.2.5 Annotate metacells (using available annotations) If single-cell annotations are available in the original single-cell anndata object. We can transfer these annotations to the metacell anndata object using the mc.tl.convey_obs_to_group() function which will associate each metacell to the most frequent annotation (categorical) or averaged annotation (continuous) across the single-cells composing the metacell (use of the mc.ut.most_frequent and np.mean respectively in the mode paratemer). # Assign a single value for each metacell based on the cells. mc.tl.convey_obs_to_group( adata=ad, gdata=mc_ad, property_name=annotation_label, to_property_name=annotation_label, method=mc.ut.most_frequent # This is the default, for categorical data ) #&gt; set metacells.obs[louvain]: 122 &lt;U17s # Compute the fraction of cells with each possible value in each metacell: mc.tl.convey_obs_fractions_to_group( adata=ad, gdata=mc_ad, property_name=annotation_label, to_property_name=annotation_label ) #&gt; set metacells.obs[louvain_fraction_of_B cells]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_CD14+ Monocytes]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_CD4 T cells]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_CD8 T cells]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_Dendritic cells]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_FCGR3A+ Monocytes]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_Megakaryocytes]: 122 float64s #&gt; set metacells.obs[louvain_fraction_of_NK cells]: 122 float64s 4.2.6 Save output For future downstream analyses in python (section 6.2), we save the metacell counts in an Anndata object: ## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object mc_ad.uns = ad.uns.copy() mc_ad.uns[&#39;sc.obs&#39;] = ad.obs.copy() # save the requested gamma mc_ad.uns[&#39;gamma&#39;] = gamma # save metacell size mc_ad.obs.rename(columns={&#39;grouped&#39;:&#39;size&#39;}, inplace = True) print(&quot;Saving metacell object for the &quot;+ proj_name+ &quot; dataset using &quot;+ MC_tool) #&gt; Saving metacell object for the 3k_pbmc dataset using MC2 mc_ad.write_h5ad(os.path.join(&#39;./data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) For future QCs and downstream analyses in R (section 6.1), we save the metacell counts in a Seurat object: library(Seurat) library(anndata) library(reticulate) adata_mc &lt;- read_h5ad(paste0(&quot;data/&quot;, py$proj_name, &quot;/metacell_MC2.h5ad&quot;)) # Save counts and metadata in a Seurat object countMatrix &lt;- Matrix::t(adata_mc$X) colnames(countMatrix) &lt;- adata_mc$obs_names rownames(countMatrix) &lt;- adata_mc$var_names MC.seurat &lt;- CreateSeuratObject(counts = as(countMatrix, &#39;CsparseMatrix&#39;), meta.data = as.data.frame(adata_mc$obs)) #&gt; Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes #&gt; (&#39;-&#39;) #&gt; Warning: Invalid name supplied, making object name syntactically valid. New #&gt; object name is #&gt; sizetotal_umisX__zeros_downsample_umismetacells_rare_gene_modulerare_metacelllouvainlouvain_fraction_of_B.cellslouvain_fraction_of_CD14..Monocyteslouvain_fraction_of_CD4.T.cellslouvain_fraction_of_CD8.T.cellslouvain_fraction_of_Dendritic.cellslouvain_fraction_of_FCGR3A..Monocyteslouvain_fraction_of_Megakaryocyteslouvain_fraction_of_NK.cells; #&gt; see ?make.names for more details on syntax validity MC.seurat@misc[[&quot;var_features&quot;]] &lt;- rownames(adata_mc$var)[which(adata_mc$var$selected_gene == T)] # Save membership in misc MC.seurat@misc$cell_membership &lt;- py$ad$obs[&#39;membership&#39;] saveRDS(MC.seurat, file = paste0(&#39;./data/&#39;, py$proj_name, &#39;/metacell_MC2.rds&#39;)) "],["SEACells-construction.html", "4.3 SEACells (Python)", " 4.3 SEACells (Python) In this section, we construct metacells using SEACells. 4.3.1 Method The SEAcells method builds a single-cell kNN graph from the Euclidean distance in the principal component space (SVD for scATAC-seq) space. Distances in the graph are transformed to affinity by applying an adaptive Gaussian kernel. The affinity matrix is then decomposed into archetypes (linear combination of cells) and membership matrices (cells as a linear combination of archetypes). Single cells are assigned to a given metacell based on the maximum membership value of the corresponding archetype. The code provided in this section is adapted from the author’s jupyter notebook. For more information on the method, please refer to our review (Review?) and the original paper (SEACells?). Importing python packages To run the SEACells, the following python packages need to be imported: import os import pandas as pd import scanpy as sc import SEACells import random If you don’t have these packages installed, please refer to the section 2.1. 4.3.2 Data loading Similarly to SuperCell and MC2, we will run SEACells on the single-cell dataset composed of around 3000 peripheral blood mononuclear cells (PBMCs). Please follow the section 2.2 to retrieve these data from the scanpy package and save the data in the following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. MC_tool = &quot;SEACells&quot; proj_name = &quot;3k_pbmc&quot; ad = sc.read(os.path.join(&quot;data&quot;, proj_name, &quot;singlecell_anndata_filtered.h5ad&quot;)) 4.3.3 Filtering steps In this tutorial, the data have been pre-filterd and SEACells does not perform additionnal filtering. 4.3.4 Building metacells Metacells construction using SEACells requires 2 main inputs: i) an anndata object (build_kernel_on parameter), and ii) a key indicating which matrix in the obsm attribute of the anndata object should be considered to compute the kernel needed for archetypal analysis (build_kernel_on parameter). Important optional inputs are: the number of metacells to identify (n_SEACells parameter), which is used as input of the archetypal analysis, ii) the number of neighbors to consider for the knn graph (n_neighbors parameter). Data pre-processing The following code chunk saves the raw counts of the filtered data in the raw attribute of the anndata object. The raw counts will be used later for metacells aggregation. raw_ad = sc.AnnData(ad.X) raw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names ad.raw = raw_ad To build the kernel for archetypal analysis, SEACells requires a lower-dimensionnal embedding of the data (for example using PCA for scRNA-Seq data or SVD for scATAC-Seq data). In the next code chunk, we follow standard pre-processing steps prior to PCA computation, i.e., data normalization, log transformation, identification of highly variable genes. PCA components are saved in the obsm attribute of the anndata object. To pre-process the single-cell data, we are using standard pre-processing for single-cell RNA-seq data using Scanpy. For more information, see the Scanpy tutorial. # Normalize cells, log transform and compute highly variable genes sc.pp.normalize_per_cell(ad, 10000) sc.pp.log1p(ad) sc.pp.highly_variable_genes(ad, n_top_genes=2000) # Compute principal components - n_comp = 30 sc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True) # Compute UMAP for visualization # Here we use 30 components to be consistent with our main tutorial, but fill free to explore other number of principal components to use sc.pp.neighbors(ad, n_neighbors=15, n_pcs=30) sc.tl.umap(ad) Setting up SEACells parameters In this tutorial, we will use in the SEACells model the 30 first principal components resulting from the PCA to build the knn graph which will be used to compute the kernel. The number of neighbors to considered for the knn graph can be fixed using the n_neighbors parameter (here 15). As mentioned previously, users should provide as input the number of metacells required (n_SEACells parameter). This number can be defined as the ratio between the number of single cells and the desired graining level (gamma parameter in the following code chunk). In this example, we choose a graining level of 25. build_kernel_on = &#39;X_pca&#39; # key in ad.obsm to use for computing metacells n_waypoint_eigs = 10 # Number of eigenvalues to consider when initializing metacells n_neighbors = 15 # Number of neighbors used for graph construction gamma = 25 # the requested graining level n_SEACells = int(ad.shape[0]/gamma) # the requested number of metacells Initializing the SEACells model The SEACells model is initialized with the previously defined parameters using the SEACells.core.SEACells function. model = SEACells.core.SEACells(ad, build_kernel_on = build_kernel_on, n_SEACells = n_SEACells, n_waypoint_eigs = n_waypoint_eigs, n_neighbors = n_neighbors, convergence_epsilon = 1e-5, verbose = True) #&gt; Welcome to SEACells! Kernel computation is performed using the mconstruct_kernel_matrix function. model.construct_kernel_matrix() M = model.kernel_matrix Metacells are initialized using the initialize_archetypes function. The SEACells archetypes initialization is based on cells sampling and thus is stochastic. User can fix a seed for reproducible results. To check that the archetypes are evenly spread, users can visualize them using the plot.plot_initialization function. # set seed for reproducibility random.seed(123) # Initialize archetypes model.initialize_archetypes() #&gt; Building kernel on X_pca #&gt; Computing diffusion components from X_pca for waypoint initialization ... #&gt; Determing nearest neighbor graph... #&gt; Done. #&gt; Sampling waypoints ... #&gt; Done. #&gt; Selecting 88 cells from waypoint initialization. #&gt; Initializing residual matrix using greedy column selection #&gt; Initializing f and g... #&gt; Selecting 17 cells from greedy initialization. #&gt; #&gt; 0%| | 0/27 [00:00&lt;?, ?it/s] 100%|##########| 27/27 [00:00&lt;00:00, 275.01it/s] # Visualize the initialization SEACells.plot.plot_initialization(ad, model, plot_basis=&#39;X_umap&#39;) Fitting the SEACells model to identify metacells The identification of the archetypes is an iterative process. In this example, we fixed the minimum and maximum number of iteration to 10 and 50 respectively. We then check the model convergence using the plot_convergence function. model.fit(min_iter = 10, max_iter = 50) #&gt; Randomly initialized A matrix. #&gt; Setting convergence threshold at 0.00088 #&gt; Starting iteration 1. #&gt; Completed iteration 1. #&gt; Starting iteration 10. #&gt; Completed iteration 10. #&gt; Starting iteration 20. #&gt; Completed iteration 20. #&gt; Starting iteration 30. #&gt; Completed iteration 30. #&gt; Starting iteration 40. #&gt; Completed iteration 40. #&gt; Converged after 46 iterations. model.plot_convergence() #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. Once the final archetypes have been identified, we can assign each single-cell to one metacell (hard assignments). These assignments (membership) can be retrieved using the get_hard_assignments function or extracted from the anndata object using ad.obs[\"SEACell\"]. In this tutorial, we will only consider hard assignments. However, the SEACells package also provides the option to retrieve soft assignments (multiple weighted assignments for each cell) using the get_soft_assignments function. For more details on the soft assignments, please refer to the SEACell paper and the original author’s jupyter notebook. membership = model.get_hard_assignments() membership.head #&gt; &lt;bound method NDFrame.head of SEACell #&gt; index #&gt; AAACATACAACCAC-1 SEACell-58 #&gt; AAACATTGAGCTAC-1 SEACell-69 #&gt; AAACATTGATCAGC-1 SEACell-0 #&gt; AAACCGTGCTTCCG-1 SEACell-47 #&gt; AAACCGTGTATGCG-1 SEACell-57 #&gt; ... ... #&gt; TTTCGAACTCTCAT-1 SEACell-1 #&gt; TTTCTACTGAGGCA-1 SEACell-101 #&gt; TTTCTACTTCCTCG-1 SEACell-30 #&gt; TTTGCATGAGAGGC-1 SEACell-69 #&gt; TTTGCATGCCTCAC-1 SEACell-23 #&gt; #&gt; [2638 rows x 1 columns]&gt; ad.obs[&quot;SEACell&quot;].head #&gt; &lt;bound method NDFrame.head of index #&gt; AAACATACAACCAC-1 SEACell-58 #&gt; AAACATTGAGCTAC-1 SEACell-69 #&gt; AAACATTGATCAGC-1 SEACell-0 #&gt; AAACCGTGCTTCCG-1 SEACell-47 #&gt; AAACCGTGTATGCG-1 SEACell-57 #&gt; ... #&gt; TTTCGAACTCTCAT-1 SEACell-1 #&gt; TTTCTACTGAGGCA-1 SEACell-101 #&gt; TTTCTACTTCCTCG-1 SEACell-30 #&gt; TTTGCATGAGAGGC-1 SEACell-69 #&gt; TTTGCATGCCTCAC-1 SEACell-23 #&gt; Name: SEACell, Length: 2638, dtype: object&gt; Retrieve aggregated metacell data The core.summarize_by_SEACell function can be used to generate a metacell count matrix (aggregation of counts across all cells belonging to each metacell). mc_ad = SEACells.core.summarize_by_SEACell(ad, SEACells_label=&#39;SEACell&#39;, summarize_layer=&#39;raw&#39;, celltype_label=annotation_label) #&gt; 0%| | 0/105 [00:00&lt;?, ?it/s] 51%|#####1 | 54/105 [00:00&lt;00:00, 532.25it/s] 100%|##########| 105/105 [00:00&lt;00:00, 545.47it/s] Annotate metacells Note that providing an annotation to the celltype_label parameter in the SEACells.core.summarize_by_SEACell function allowed us to annotate the metacells to the most common cell type in each metacell. 4.3.5 Visualize metacells To visualize the metacells, we can project the metacells on the single-cell UMAP representation using the plot.plot_2D included in the SEACells package. SEACells.plot.plot_2D(ad, key=&#39;X_umap&#39;, colour_metacells=True) Save output For future downstream analyses in python (section 6.2), we save the metacell counts in an Anndata object: print(&quot;Saving metacell object for the &quot;+ proj_name+ &quot; dataset using &quot;+ MC_tool) #&gt; Saving metacell object for the 3k_pbmc dataset using SEACells # Save metacell sizes label_df = ad.obs[[&#39;SEACell&#39;]].reset_index() mc_ad.obs = mc_ad.obs.join(pd.DataFrame(label_df.groupby(&#39;SEACell&#39;).count().iloc[:, 0]).rename(columns={&#39;index&#39;:&#39;size&#39;})) # save pca used to compute metacells mc_ad.uns[&#39;var_features&#39;]=ad.var_names[ad.var.highly_variable].tolist() mc_ad.uns[&#39;sc.pca&#39;]=ad.obsm[&#39;X_pca&#39;] mc_ad.uns[&#39;sc.umap&#39;]=ad.obsm[&#39;X_umap&#39;] mc_ad.write_h5ad(os.path.join(&#39;./data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) For future downstream analyses in R (section 6.1), we save the metacell counts in a Seurat object: library(Seurat) library(anndata) library(reticulate) adata_mc &lt;- read_h5ad(paste0(&quot;data/&quot;, py$proj_name, &quot;/metacell_SEACells.h5ad&quot;)) # Save counts and metadata in a Seurat object countMatrix &lt;- Matrix::t(adata_mc$X) colnames(countMatrix) &lt;- adata_mc$obs_names rownames(countMatrix) &lt;- adata_mc$var_names MC.seurat &lt;- CreateSeuratObject(counts = as(countMatrix, &#39;CsparseMatrix&#39;), meta.data = as.data.frame(adata_mc$obs)) #&gt; Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes #&gt; (&#39;-&#39;) # MC.seurat@misc[[&quot;sc.pca&quot;]] &lt;- adata_mc$uns$sc.pca # MC.seurat@misc[[&quot;sc.umap&quot;]] &lt;- adata_mc$uns$sc.umap MC.seurat@misc[[&quot;var_features&quot;]] &lt;- adata_mc$uns$var_features pca.res &lt;- adata_mc$uns$sc.pca rownames(pca.res) &lt;- rownames(py$ad$obs) MC.seurat@misc$sc.pca &lt;- CreateDimReducObject( embeddings = pca.res, key = &quot;PC_&quot;, assay = &quot;RNA&quot; ) #&gt; Warning: No columnames present in cell embeddings, setting to &#39;PC_1:30&#39; # Save membership in misc MC.seurat@misc$cell_membership &lt;- data.frame(row.names = rownames(py$membership), membership = py$membership$SEACell) saveRDS(MC.seurat, file = paste0(&#39;./data/&#39;, py$proj_name, &#39;/metacell_SEACells.rds&#39;)) "],["command-line.html", "4.4 Command line tool", " 4.4 Command line tool We provide a command line tool allowing users to build metacells using either tool (MC2, SuperCell or SEACells) from a provided dataset. The command line tool take multiple parameters as input, e.g., number of neighbors considered in the knn, number of components used, graining level. which is for example required in a benchmark setting. setwd(&quot;MetacellToolkit/&quot;) proj_name=&quot;3k_pbmc&quot; MC_tool=&quot;SuperCell&quot; # input raw adata output adata Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s adata # input raw adata output seurat Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s seurat proj_name=&quot;3k_pbmc&quot; MC_tool=&quot;SEACells&quot; # input raw adata output adata Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s adata # input raw adata output seurat Rscript cli/${MC_tool}CL.R -i data/${proj_name}/singlecell_anndata_filtered.h5ad -o data/${proj_name}/${MC_tool}/ -n 50 -f 2000 -k 30 -g 50 -s seurat "],["QCs.html", "Chapter 5 Metacells QCs", " Chapter 5 Metacells QCs Different metrics have been proposed in previous metacell studies to evaluate the quality of metacells. We propose a R package called MetacellToolkit, to compute and visualize these metrics. The package also provides a function to visualize metacells projected in the single-cell space. Import packages: # if(system.file(package=&#39;MetacellToolkit&#39;) == &quot;&quot;){ # remotes::install_github(&quot;GfellerLab/MetacellToolkit@dev_ag&quot;, force = TRUE, upgrade = FALSE) # } library(MetacellToolkit) To explore metacells QCs, we need to load: (i) the single-cell data used to build the metacells and (ii) the metacell data saved in a Seurat object (see chapter 4). # Load the single-cell data sc_data = readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) # Load the metacell data mc_data = readRDS(paste0(&#39;data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) "],["quantitative-metrics.html", "5.1 Quantitative metrics", " 5.1 Quantitative metrics 5.1.1 Purity When available, cell annotations can be used to annotate each metacell to the most abundant cell category (e.g. cell type) composing the metacell (see chapter 4). This also allows us to compute metacell purity. If the annotation considered is the cell type, the purity of a metacell is the proportion of the most abundant cell type within the metacell (SuperCell?). mc_data$purity &lt;- mc_purity(membership = mc_data@misc$cell_membership$membership, annotation = sc_data@meta.data[, annotation_label]) #&gt; Loading required package: SeuratObject qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;purity&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;purity&quot;, split.by = annotation_label) 5.1.2 Compactness The compactness of a metacell is the variance of the components within the metacell (SEACells?). The lower the compactness value the better. This metric as well as the separation metric are computed based on a low embedding of the single-cell data (e.g., PCA). Note that it is important to use the embedding used initially to construc the metacells. In the next chunk, we retrieve the principal components computed for metacell construction (in chapter 4 these principal components were saved in the Seurat objects containing the metacell data) and run UMAP for visualization. sc_data@reductions[[&quot;pca&quot;]] &lt;- mc_data@misc$sc.pca sc_data &lt;- RunUMAP(sc_data, reduction = &quot;pca&quot;, dims = c(1:30), n.neighbors = 15, verbose = F, min.dist = 0.5) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session UMAPPlot(sc_data, group.by = annotation_label, reduction = &quot;umap&quot;) membership_df &lt;- mc_data@misc$cell_membership mc_data$compactness &lt;- mc_compactness(cell.membership = membership_df, sc.obj = sc_data, sc.reduction = &quot;pca&quot;, n.components = 30, diffusion.components = T) #&gt; Computing compactness ... qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;compactness&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;compactness&quot;, split.by = annotation_label) 5.1.3 Separation The separation of a metacell is the distance to the closest metacell (SEACells?). The higher the separation value the better. mc_data$separation &lt;- mc_separation(cell.membership = membership_df, sc.obj = sc_data, sc.reduction = &quot;pca&quot;, diffusion.components = T) #&gt; Computing separation ... qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;separation&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;separation&quot;, split.by = annotation_label) Note that compactness and separation metrics are correlated, better compactness results in worse separation and vice versa. Metacells from dense regions will have better compactness but worse separation, while metacells from sparse regions will have better separation but worse compactness. library(ggplot2) ggplot(data.frame(compactness = log(mc_data$compactness), separation = log(mc_data$separation)), aes(x=compactness, y=separation)) + geom_point()+ geom_smooth(method=lm) + ggpubr::stat_cor(method = &quot;spearman&quot;) #&gt; `geom_smooth()` using formula = &#39;y ~ x&#39; 5.1.4 INV The inner normalized variance (INV) of a metacell is the mean-normalized variance of gene expression within the metacell (MC2?). The lower the INV value the better. Note that it is the only metric that is latent-space independent. mc_data$INV &lt;- mc_INV(cell.membership = membership_df, sc.obj = sc_data, group.label = &quot;membership&quot;) #&gt; Counts and data slots are identical. #&gt; Normalizing data ... #&gt; Computing INV ... qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;INV&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;INV&quot;, split.by = annotation_label) "],["size-distribution.html", "5.2 Size distribution", " 5.2 Size distribution The size of a metacell corresponds to the number of single cells it contains. Having a homogeneous metacell size distribution is ideal for downstream analyses, since larger metacells will express more genes, which could confound analyses. When heterogeneous size distributions are obtained we recommend weighted downstream analyses as described in section 6.3. # Seurat::VlnPlot(mc_data, features = &quot;size&quot;, pt.size = 2) # Seurat::VlnPlot(mc_data, features = &quot;size&quot;, pt.size = 2, group.by = annotation_label) hist(mc_data$size, main = &quot;Size distribution&quot;, xlab = &quot;Size&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;size&quot;) qc_boxplot(mc.obj = mc_data, qc.metrics = &quot;size&quot;, split.by = annotation_label) "],["representativeness-of-metacells.html", "5.3 Representativeness of metacells", " 5.3 Representativeness of metacells To visualize the metacells, we can project the metacells on the single-cell UMAP representation using the mc_projection() function (adapted from the plot.plot_2D() from the SEACells package). A good metacell partition should reproduce the overall structure of the single-cell data by uniformly representing the latent space. To use this function we need the data at the single-cell level (or at least an low-dimensional embedding of the data) and the single-cell membership to each the metacell. convert_to_num &lt;- function(original_names){ conversion_vect &lt;- 1:length(unique(original_names)) names(conversion_vect) &lt;- unique(original_names) return(conversion_vect[original_names]) } named_membership &lt;- convert_to_num(membership_df$membership) names(named_membership) &lt;- rownames(membership_df) mc_projection( sc.obj = sc_data, mc.obj = mc_data, membership = named_membership, sc.reduction = &quot;umap&quot;, sc.label = unlist(annotation_label), # single cells will be colored according the sc.label metacell.label = unlist(annotation_label) # metacells cell will be colored according the metacell.label ) By default the size of the metacells dots is proportionnal to the size of the metacells. Metacells can also be colored by a continuous variable such as one of the QC metrics computed in the previous chunks: mc_projection( sc.obj = sc_data, mc.obj = mc_data, membership = named_membership, sc.reduction = &quot;umap&quot;, sc.label = unlist(annotation_label), # single cells will be colored according the sc.label continuous_metric = TRUE, metric = &quot;compactness&quot; ) "],["downstream-analysis-of-metacells.html", "Chapter 6 Downstream analysis of metacells", " Chapter 6 Downstream analysis of metacells In this chapter, we run standard and advanced downstream analyses on metacells instead of single-cell data. In this analysis, we treat each metacell as a single cell, neglecting information about the size of the metacell (i.e., number of containing single cells). If you are interested in sample-weighted analysis, where metacell size is taken into account, see section 6.3. "],["standard-analysis-R.html", "6.1 Standard analysis (R)", " 6.1 Standard analysis (R) In this tutorial, standard analysis includes dimensionality reduction, clustering and differential expression using the Seurat framework. library(Seurat) #&gt; Attaching SeuratObject library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(ggplot2) 6.1.1 Load metacell Seurat object We will use Seurat objects containing the metacells counts data and their annotation (e.g. and cell-type annotation) and proceed with standard Seurat downstream analyses. Seurat objects containing metacells counts data and their annotation were generated at the end of sections ….. These objects can also be generated using the command line described in chapter … MC_tool = &quot;SuperCell&quot; proj_name = &quot;3k_pbmc&quot; annotation_column = &quot;louvain&quot; MC.seurat = readRDS(paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) 6.1.2 Dimensionality reduction As for single-cells, we normalize the raw counts (here aggregated raw counts) and we identify the most variable features in the metacells gene expression data. Based on these features, we run PCA and use the first principal components to obtain a two dimensionnal representation of the data using UMAP. Idents(MC.seurat) &lt;- annotation_column MC.seurat &lt;- NormalizeData(MC.seurat, normalization.method = &quot;LogNormalize&quot;) MC.seurat &lt;- FindVariableFeatures(MC.seurat, nfeatures = 2000) MC.seurat &lt;- ScaleData(MC.seurat) #&gt; Centering and scaling data matrix MC.seurat &lt;- RunPCA(MC.seurat, verbose = F) MC.seurat &lt;- RunUMAP(MC.seurat, dims = 1:30, verbose = F) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session DimPlot(MC.seurat, reduction = &quot;umap&quot;) 6.1.3 Clustering We cluster the metacells using Seurat clustering steps and visualize these clusters using UMAP: MC.seurat &lt;- FindNeighbors(MC.seurat, dims = 1:30) #&gt; Computing nearest neighbor graph #&gt; Computing SNN MC.seurat &lt;- FindClusters(MC.seurat, resolution = 2) #&gt; Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #&gt; #&gt; Number of nodes: 106 #&gt; Number of edges: 2637 #&gt; #&gt; Running Louvain algorithm... #&gt; Maximum modularity in 10 random starts: 0.1672 #&gt; Number of communities: 6 #&gt; Elapsed time: 0 seconds #&gt; 1 singletons identified. 5 final clusters. DimPlot(MC.seurat, reduction = &quot;umap&quot;, group.by = &quot;seurat_clusters&quot;) 6.1.4 Differential expression analysis # Set idents to metacell annotation Idents(MC.seurat) &lt;- annotation_column levels(MC.seurat) &lt;- sort(levels(Idents(MC.seurat))) # Compute upregulated genes in group of metacells (versus other metacells) MC.seurat.all.markers &lt;- FindAllMarkers( MC.seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = &quot;t&quot; ) #&gt; Calculating cluster B cells #&gt; Calculating cluster CD14+ Monocytes #&gt; Calculating cluster CD4 T cells #&gt; Calculating cluster CD8 T cells #&gt; Calculating cluster Dendritic cells #&gt; Calculating cluster FCGR3A+ Monocytes #&gt; Calculating cluster Megakaryocytes #&gt; Calculating cluster NK cells We select the top markers for each cell-type: # Top markers (select top markers of each metacell population) MC.seurat.top.markers &lt;- MC.seurat.all.markers %&gt;% group_by(cluster) %&gt;% slice_max(n = 5, order_by = avg_log2FC) MC.seurat.top.markers #&gt; # A tibble: 35 × 7 #&gt; # Groups: cluster [7] #&gt; p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; #&gt; 1 6.34e-11 4.09 1 0.543 2.08e- 6 B cells CD79A #&gt; 2 3.56e- 5 3.70 1 0.223 1 e+ 0 B cells IGLL5 #&gt; 3 1.60e-12 3.40 1 0.755 5.24e- 8 B cells CD79B #&gt; 4 3.70e-19 3.36 1 0.606 1.21e-14 B cells MS4A1 #&gt; 5 2.16e- 6 3.12 1 0.383 7.08e- 2 B cells TCL1A #&gt; 6 1.28e-23 4.79 1 0.79 4.20e-19 CD14+ Monocytes S100A8 #&gt; 7 4.10e-36 4.51 1 0.926 1.34e-31 CD14+ Monocytes S100A9 #&gt; 8 4.35e-42 3.38 1 1 1.42e-37 CD14+ Monocytes LYZ #&gt; 9 2.36e-38 2.90 1 0.58 7.72e-34 CD14+ Monocytes LGALS2 #&gt; 10 2.26e-19 2.79 1 0.395 7.39e-15 CD14+ Monocytes CD14 #&gt; # ℹ 25 more rows We visualize the top 5 markers for the XX cells. # genes.to.plot &lt;- MC.seurat.top.markers$gene[MC.seurat.top.markers$cluster == unique(MC.seurat@meta.data[,annotation_column])[1]] genes.to.plot &lt;- MC.seurat.top.markers$gene[c(seq(1, 20, 5))] VlnPlot(MC.seurat, features = genes.to.plot, ncol = 4, pt.size = 0.0) 6.1.5 Visualize gene-gene correlation We can use the supercell_GeneGenePlot function from the SuperCell package to visualize the correlation between marker genes of a cell-type: (i) at the single-cell level and (ii) at the metacell level. For that, we load the single-cell data from which the metacells were derived. print(proj_name) #&gt; [1] &quot;3k_pbmc&quot; sc_data = readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) sc_data &lt;- NormalizeData(sc_data, normalization.method = &quot;LogNormalize&quot;) library(SuperCell) cell_type_markers &lt;- MC.seurat.top.markers[MC.seurat.top.markers$cluster == &quot;CD8 T cells&quot;, ] gene_x &lt;- cell_type_markers$gene[1:2] gene_y &lt;- cell_type_markers$gene[3:4] alpha &lt;- 0.7 p.sc &lt;- supercell_GeneGenePlot( GetAssayData(sc_data, slot = &quot;data&quot;), gene_x = gene_x, gene_y = gene_y, clusters = sc_data@meta.data[, annotation_column], sort.by.corr = F, alpha = alpha ) p.sc$p p.MC &lt;- supercell_GeneGenePlot(GetAssayData(MC.seurat, slot = &quot;data&quot;), gene_x = gene_x, gene_y = gene_y, clusters = MC.seurat@meta.data[ ,annotation_column], sort.by.corr = F, alpha = alpha) p.MC$p "],["standard-analysis-Py.html", "6.2 Standard analysis (Python)", " 6.2 Standard analysis (Python) In this section, standard analysis includes dimensionality reduction, clustering, differential expression etc using Scanpy framework. import numpy as np import pandas as pd import scanpy as sc sc.settings.verbosity = 1 MC_tool = &quot;SEACells&quot; proj_name = &quot;3k_pbmc&quot; annotation_column = &quot;louvain&quot; adata = sc.read(os.path.join(&#39;./data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) 6.2.1 Dimensionality reduction adata.var_names_make_unique() # this is unnecessary if using `var_names=&#39;gene_ids&#39;` in `sc.read_10x_mtx` sc.pp.normalize_per_cell(adata) sc.pp.log1p(adata) sc.pp.highly_variable_genes(adata, n_top_genes=2000) # Freeze the state of the AnnData object for later use in differential testing and visualizations of gene expression adata.raw = adata # step needd only if I use regress_out steps # Compute PCA (highly variable genes will be used) sc.tl.pca(adata, svd_solver=&#39;arpack&#39;) # Compute the neighbor graph sc.pp.neighbors(adata, n_neighbors=15, n_pcs=30) #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/umap/distances.py:1063: NumbaDeprecationWarning: The &#39;nopython&#39; keyword argument was not supplied to the &#39;numba.jit&#39; decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. #&gt; @numba.jit() #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/umap/distances.py:1071: NumbaDeprecationWarning: The &#39;nopython&#39; keyword argument was not supplied to the &#39;numba.jit&#39; decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. #&gt; @numba.jit() #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/umap/distances.py:1086: NumbaDeprecationWarning: The &#39;nopython&#39; keyword argument was not supplied to the &#39;numba.jit&#39; decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. #&gt; @numba.jit() #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/umap/umap_.py:660: NumbaDeprecationWarning: The &#39;nopython&#39; keyword argument was not supplied to the &#39;numba.jit&#39; decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details. #&gt; @numba.jit() # Run umap sc.tl.umap(adata) # Plot metacells in the UMAP space sc.pl.umap(adata, color=[annotation_column], size = 100) #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via &#39;c&#39;. Parameters &#39;cmap&#39; will be ignored #&gt; cax = scatter( 6.2.2 Clustering Perform clustering on the metacell data. # run laiden graph-clustering sc.tl.leiden(adata, neighbors_key = &quot;neighbors&quot;, resolution = 2) # plot the metacells in the UMAP space and color by cluster sc.pl.umap(adata, color=[&#39;leiden&#39;], size = 100) #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via &#39;c&#39;. Parameters &#39;cmap&#39; will be ignored #&gt; cax = scatter( 6.2.3 Differential expression analysis Identify marker genes for each group of metacells. Note that here we use the clusters since the Megakaryocytes contain only one metacells. We visualize the top 3 markers for CD8 Tcells. # Identify marker genes sc.tl.rank_genes_groups(adata, &#39;leiden&#39;, method=&#39;wilcoxon&#39;) sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False) #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_review/tuto/Metacell_tutorial/my_env/lib/python3.8/site-packages/scanpy/plotting/_tools/__init__.py:397: UserWarning: Attempting to set identical low and high ylims makes transformation singular; automatically expanding. #&gt; ax.set_ylim(ymin, ymax) # Show the top marker genes print(pd.DataFrame(adata.uns[&#39;rank_genes_groups&#39;][&#39;names&#39;]).head(5)) #&gt; 0 1 2 3 4 5 6 7 #&gt; 0 RPL31 FOLR3 CD8A LTB CST3 STXBP2 XCL2 TNFRSF13C #&gt; 1 RPL32 S100A9 CCL5 TNFRSF4 HLA-DRB5 MS4A4A KLRF1 CD79A #&gt; 2 CCR7 S100A8 LYAR AQP3 HLA-DRB1 RHOC RAMP1 GNG7 #&gt; 3 RPS6 BST1 CD8B CD40LG HLA-DPA1 CDKN1C CLIC3 PPAPDC1B #&gt; 4 RPS27 MGST1 KLRG1 CD2 TMSB10 FCER1G PRF1 HLA-DOB # Visualize marker genes sc.pl.violin(adata, [&#39;CD8A&#39;, &#39;CCL5&#39;, &#39;LYAR&#39;], groupby=annotation_column, size = 2, rotation = 90) "],["weighted-analysis.html", "6.3 Sample-weighted analysis", " 6.3 Sample-weighted analysis Code has been modified but text should be updated in this section! library(Seurat) library(dplyr) library(ggplot2) library(SuperCell) 6.3.1 Load metacell Seurat object We will use Seurat objects containing the metacells counts data and their annotation (e.g. and cell-type annotation) and proceed with standard Seurat downstream analyses. Seurat objects containing metacells counts data and their annotation were generated at the end of sections ….. These objects can also be generated using the command line described in chapter … MC_tool = &quot;SuperCell&quot; proj_name = &quot;3k_pbmc&quot; annotation_column = &quot;louvain&quot; MC.seurat = readRDS(paste0(&#39;./data/&#39;, proj_name, &#39;/metacell_&#39;, MC_tool,&#39;.rds&#39;)) 6.3.2 Dimensionality reduction As for single-cells, we normalize the raw counts (here aggregated raw counts) and we identify the most variable features in the metacells gene expression data. Based on these features, we run PCA and use the first principal components to obtain a two dimensionnal representation of the data using UMAP. MC.seurat &lt;- NormalizeData(MC.seurat, normalization.method = &quot;LogNormalize&quot;) MC_list &lt;- list(N.SC = ncol(MC.seurat), supercell_size = MC.seurat$size) MC_list$PCA &lt;- supercell_prcomp( Matrix::t(GetAssayData(MC.seurat, slot = &quot;data&quot;)), genes.use = MC.seurat@misc$var_features, # or a new set of HVG can be computed supercell_size = MC_list$supercell_size, # provide this parameter to run sample-weighted version of PCA, k = 10 ) MC_list$UMAP &lt;- supercell_UMAP( SC = MC_list, PCA_name = &quot;PCA&quot;, n_neighbors = 50 # large number to repel cells ) supercell_DimPlot(SC = MC_list, groups = MC.seurat@meta.data[, annotation_column], dim.name = &quot;UMAP&quot;, title = paste0(&quot;UMAP of metacells colored by cell type assignment&quot;) ) 6.3.3 Clustering We cluster the metacells using Seurat clustering steps and visualize these clusters using UMAP: # compute distance among metacells D &lt;- dist(MC_list$PCA$x) # cluster metacells MC_list$clustering &lt;- supercell_cluster(D = D, k = 8, supercell_size = MC_list$supercell_size) # Plot clustering result supercell_DimPlot( MC_list, groups = factor(MC_list$clustering$clustering), dim.name = &quot;UMAP&quot;, title = paste0(&quot;UMAP of metacells colored by metacell clustering&quot;) ) 6.3.4 Differential expression analysis # Compute upregulated genes in each cell line (versus other cells) MC.all.markers &lt;- supercell_FindAllMarkers( ge = GetAssayData(MC.seurat, slot = &quot;data&quot;), clusters = MC.seurat@meta.data[, annotation_column], supercell_size = MC_list$supercell_size, only.pos = TRUE, min.pct = 0, logfc.threshold = 0.2 ) We select the top markers for each cell-type: # Transform the output of `supercell_FindAllMarkers()` to be in the format of the `Seurat::FindAllMarkers()` MC.all.markers.df &lt;- data.frame() for(cl in names(MC.all.markers)){ cur &lt;- MC.all.markers[[cl]] if(is.data.frame(cur)){ cur$cluster &lt;- cl cur$gene &lt;- rownames(cur) cur$avg_log2FC &lt;- cur$logFC MC.all.markers.df &lt;- rbind(MC.all.markers.df, cur) } } # Top markers (select top markers of each cell line) MC.top.markers &lt;- MC.all.markers.df %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC) We visualize the top 5 markers for the XX cells. Idents(MC.seurat) &lt;- annotation_column # genes.to.plot &lt;- MC.seurat.top.markers$gene[MC.seurat.top.markers$cluster == unique(MC.seurat@meta.data[,annotation_column])[1]] genes.to.plot &lt;- MC.top.markers$gene[c(seq(1, 20, 5))] VlnPlot(MC.seurat, features = genes.to.plot, ncol = 4, pt.size = 0.0) "],["advanced-analysis.html", "6.4 Advanced analysis", " 6.4 Advanced analysis 6.4.1 GRN 6.4.2 Integration of metacells "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
