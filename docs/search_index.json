[["index.html", "Metacell Tutorial Chapter 1 About", " Metacell Tutorial Mariia Bilous, Léonard Hérault, Aurélie Gabriel, David Gfeller 2023-07-24 Chapter 1 About The structure of this tutorial. "],["book-structure.html", "1.1 Book structure", " 1.1 Book structure Book consists of several Chapters (i.e., first-level headings). Each chapter is in separate .Rmd file in the root folder, with a name in XY_text.Rmd format, with XY being numbers. Each Chapter consists of sections and sup-sections (i.e., second-level and lower heading), files for which are located in ./sub_pages. Sub-pages and chapters may also call functional_chunks, which are located in ./functional_chunks and represent parts of code that can be repetitively run (e.g., load_anndata, save_mc_anndata etc). When the book is rendered, the included sub_pages and functional_chunks are basically inserted in the Chapter as inline code. The only challenge is the relative path of the files and resulting outputs, such as plots. To resolve this issue, currently, I manually set up the project folder as a knitting root directory in each sub-file (i.e., sub_pages and functional_chunks) as knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) . Also, in my RStudio settings, I have the following setting Tools -&gt; Global Options... -&gt; R Markdown -&gt; Evaluate chunk in directory -&gt; Project. Note: each chapters runs in a new R session and they do not share the environment, thus, we need to provide global knit options for each chapter, otherwise they are lost. I do it with a source('./R/config.R') in the beginning of each chapter. "],["installation-and-requirements.html", "1.2 Installation and requirements", " 1.2 Installation and requirements R requirements install.packages(&#39;rprojroot&#39;) # to reset work directory to the Project root install.packages(&#39;bookdown&#39;) # to render book To run MC2 and SEACells in RStudio, we need install.packages(&#39;reticulate&#39;) # to run Python Then, we need to setup virtual environment pip install virtualenv cd &lt;Path_to_Metacell_tutorial&gt; virtualenv my_env source my_env/bin/activate # Installing SEACells, pip install installs old version, that does not work for me, thus install from git git clone https://github.com/dpeerlab/SEACells.git cd SEACells python setup.py install cd .. pip install -r SEACells_requirements.txt # here some packages have wrong/non-existing vision, so I manually changed their versions pip install ipywidgets pip install jupyter pip install metacells # in project dir echo &#39;RETICULATE_PYTHON=my_env/bin/python&#39; &gt; &#39;.Renviron&#39; # restart RStudio and open &#39;Metacell_tutorial.Rproj&#39; "],["render-book.html", "1.3 Render book", " 1.3 Render book The function to render book is bookdown::render_book(), this will take some time, as it will execute all the chunks in the book, there is an option to cache some chunks, but we have to make sure that cached chunks do not share variables with non-cached chunks (it will raise an error anyway). bookdown::preview_chapter() renders a chapter. "],["get-data.html", "1.4 Get data", " 1.4 Get data To get 3k PBMCs, use scanpy datasets af follows import scanpy as sc import os ad = sc.datasets.pbmc3k() adata_proc = sc.datasets.pbmc3k_processed() ad = ad[adata_proc.obs_names].copy() ad.obs = adata_proc.obs.copy() ad.uns = adata_proc.uns.copy() ad.obsm = adata_proc.obsm.copy() ad.obsp = adata_proc.obsp.copy() raw_ad = sc.AnnData(ad.X.copy()) raw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names ad.raw = raw_ad sc.pl.embedding(ad, &#39;X_umap&#39;, color=&#39;louvain&#39;) #&gt; /mnt/c/Aurelie/postdoc_UNIL/Metacell_tutorial/my_env/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via &#39;c&#39;. Parameters &#39;cmap&#39; will be ignored #&gt; cax = scatter( directory = os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;) if not os.path.exists(directory): os.makedirs(directory) ad.write_h5ad(os.path.join(&quot;data&quot;, &quot;3k_pbmc&quot;, &quot;singlecell_anndata_filtered.h5ad&quot;)) library(reticulate) library(Seurat) #&gt; Attaching SeuratObject raw_counts &lt;- Matrix::t(as(py$ad$raw$X, &quot;CsparseMatrix&quot;)) colnames(raw_counts) &lt;- rownames(py$ad$obs) rownames(raw_counts) &lt;- rownames(py$ad$var) # norm_counts &lt;- Matrix::t(as(py$ad$X, &quot;CsparseMatrix&quot;)) # colnames(norm_counts) &lt;- rownames(py$ad$obs) # rownames(norm_counts) &lt;- rownames(py$ad$var) pbmc &lt;- CreateSeuratObject(counts = raw_counts, meta.data = py$ad$obs) #&gt; Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes #&gt; (&#39;-&#39;) # pbmc@assays$RNA@data &lt;- norm_counts saveRDS(pbmc, file = paste0(&quot;data/3k_pbmc/singlecell_seurat_filtered.rds&quot;)) "],["the-metacell-concept.html", "Chapter 2 The metacell concept", " Chapter 2 The metacell concept See chapters 2.1, 2.2, 2.3 "],["MC2.html", "2.1 Metacell (MC2)", " 2.1 Metacell (MC2) "],["SuperCell.html", "2.2 SuperCell", " 2.2 SuperCell "],["SEACells.html", "2.3 SEACells", " 2.3 SEACells "],["constructing-metacells-for-discrete-data.html", "Chapter 3 Constructing metacells (for ‘discrete’ data)", " Chapter 3 Constructing metacells (for ‘discrete’ data) In this chapter, we will demonstrate metacell construction using three different methods. MetaCell-2 (MC2) and SEACells in Pyhton and SuperCell in R. For this, we will use a dataset of PBMCs from study. This dataset contains 30K cells and … This is an example of a complex dataset with well defined cells types. For an example of more continuous data, see chapter ?? #&gt; findfont: Font family [&#39;Raleway&#39;] not found. Falling back to DejaVu Sans. #&gt; findfont: Font family [&#39;Lato&#39;] not found. Falling back to DejaVu Sans. "],["mc2-python.html", "3.1 MC2 (Python)", " 3.1 MC2 (Python) In this section, we construct metacells using Metacell-2 (MC2). The code is adapted from the author’s tutorial. For more information on the method, please refer to the section 1 of chapter 2. Importing python packages To run Metacell-2, the following python packages need to be imported: import os import numpy as np import pandas as pd import anndata as ad import scanpy as sc import matplotlib.pyplot as plt import seaborn as sns import metacells as mc import sys sys.path.append(&#39;./mc_QC/&#39;) import mc_QC If you don’t have these packages installed, please refer to the section 2 of chapter 1. 3.1.1 Data loading We will run Metacell-2 on a single-cell dataset composed of XX peripheral blood mononuclear cells (PBMCs). Please follow the section 4 from Chapter 1 to retrieve these data from the scanpy package and save the data in the following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. MC_tool = &quot;MC2&quot; proj_name = &quot;3k_pbmc&quot; ad = sc.read(os.path.join(&quot;data&quot;, proj_name, &quot;singlecell_anndata_filtered.h5ad&quot;)) We initialize the name of the anndata (in the unstructured annotations) object using the ut.set_name function from the Metacells package. mc.ut.set_name(ad, proj_name) 3.1.2 Filtering steps Before building the metacells the Metacell-2 authors recommend to filter the single-cell data in two-steps (See original vignette). A first filtering step consists in filtering genes based on biological knowledge (e.g. mitochrondrial genes) or based on their expression levels. The latter genes include genes with zero expression or low expression levels, “noisy lonely genes” (i.e., genes with high expression levels but no correlation with any other gene). A second filtering step consists in filtering cells based on their UMI counts. Gene filtering In section XX form Chapter XX, we pre-processed the raw scRNA-Seq data and excluded genes with low expression as well as mitochondrial genes. In the following code chunk, we identify additional genes to filter using the analyze_clean_genes and pick_clean_genes functions from the Metacells package, which returns three sets of genes: i) the known-to-be-excluded genes defined by the user as an array of gene names or gene names patterns, ii) the properly sampled genes, and iii) the “noisy lonely genes”. excluded_gene_names = [] # for example, [&#39;IGHMBP2&#39;, &#39;IGLL1&#39;, &#39;IGLL5&#39;, &#39;IGLON5&#39;, &#39;NEAT1&#39;, &#39;TMSB10&#39;, &#39;TMSB4X&#39;] excluded_gene_patterns = [&#39;MT-.*&#39;] mc.pl.analyze_clean_genes(ad, excluded_gene_names=excluded_gene_names, excluded_gene_patterns=excluded_gene_patterns, random_seed=123456) #&gt; set 3k_pbmc.var[properly_sampled_gene]: 16579 true (50.64%) out of 32738 bools #&gt; set 3k_pbmc.var[excluded_gene]: 13 true (0.03971%) out of 32738 bools #&gt; set 3k_pbmc.var[noisy_lonely_gene]: 0 true (0%) out of 32738 bools mc.pl.pick_clean_genes(ad) #&gt; set 3k_pbmc.var[clean_gene]: 16566 true (50.6%) out of 32738 bools Cell filtering The first round of cell cleaning implies filtering out cell with very low and very hight UMI content (properly_sampled_min_cell_total, properly_sampled_max_cell_total parameters). The second round includes cell filtering based on UMI counts in excluded genes (properly_sampled_max_excluded_genes_fraction parameter). Since our dataset have been pre-filtered, very lenient cutoffs will be used in this tutorial (properly_sampled_min_cell_total, properly_sampled_max_cell_total and properly_sampled_max_excluded_genes_fraction) such that all the cells are kept for the metacell construction. The following code chunk defines these parameters. To adapt them to your datasets, we advise you to explore the distributions of total UMI counts and UMI counts in excluded genes, as recommended and descrided in the Metacell-2 original vignette. ### The first round of cell cleaning (high/low UMIs) properly_sampled_min_cell_total = 200 properly_sampled_max_cell_total = 10000 ## The second round of cell cleaning (content of excluded genes, e.g., mito-genes) properly_sampled_max_excluded_genes_fraction = 0.25 The set of cells to be filtered is defined using the analyze_clean_cells and pick_clean_cells functions from the Metacell-2 package. mc.pl.analyze_clean_cells( ad, properly_sampled_min_cell_total = properly_sampled_min_cell_total, properly_sampled_max_cell_total = properly_sampled_max_cell_total, properly_sampled_max_excluded_genes_fraction = properly_sampled_max_excluded_genes_fraction ) #&gt; set 3k_pbmc.obs[properly_sampled_cell]: 2638 true (100%) out of 2638 bools mc.pl.pick_clean_cells(ad) #&gt; set 3k_pbmc.obs[clean_cell]: 2638 true (100%) out of 2638 bools After performing the two-step filtering (genes and cells), the “cleaned” data can be extracted using the pl.extract_clean_data prior to metacells construction. # Extract clean dataset (with filtered cells and genes) ad = mc.pl.extract_clean_data(ad) #&gt; set 3k_pbmc.clean.obs[full_cell_index]: 2638 int64s #&gt; set 3k_pbmc.clean.var[full_gene_index]: 16566 int64s 3.1.3 Building metacells Estimate target_metacell_size (gamma) In contrast to the SuperCell and SEACells, Metacell-2 does not allow to explicitly obtain metacell data at a user-defined graining level. Instead, to vary the graining level, we have to vary the target_metacell_size parameter, that is 160000 by default. Here we provide a chunk to calibrate this value to reach a desired graining level. Please, increase or decrease the scale parameter if the obtained graining level (gamma_obtained) is lower or larger than the requested one (gamma). gamma = 50 # graining level print(f&#39;The requested graining level is {gamma}, lets estimate the target_metacell_size that should result in such graining level.&#39;) #&gt; The requested graining level is 50, lets estimate the target_metacell_size that should result in such graining level. scale = 2 # increase or decrease if the obtained graining level (`gamma_obtained`) is significantly &gt; or &lt; then the requested one `gamma` # estimated mean UMI content in downsampled data total_umis_of_cells = mc.ut.get_o_numpy(ad, name=&#39;__x__&#39;, sum=True) est_downsample_UMI = np.quantile(np.array(total_umis_of_cells), 0.05) target_metacell_size = int(est_downsample_UMI * gamma * scale) target_metacell_size #&gt; 98900 Metacells identification using the divide and conquer approach Metacell-2 uses its own feature selection approach (i.e., selection of genes used to build metacells). Additionally, users can explicitly specify which features should be used by providing two arguments: i) feature_gene_names, i.e., genes that have to be included and, ii) forbidden_gene_names, i.e., genes that have to be excluded. Examples of forbidden are cell cycle genes which reflect true biological signal but could bias the metacells construction. The Metacell-2 original vignette provides additional information to identify forbidden genes. The previous arguments for feature selection are taken as input by the pl.divide_and_conquer_pipeline function which builds the metacells. Note that by default all cores of the system will be used for the metacells construction. More information are available on the original vignette to change this behavior and adapt the number of cores (see ut.set_processors_count) or the number processed in parallel (see pl.set_max_parallel_piles). mc.pl.divide_and_conquer_pipeline( ad, #feature_gene_names = feature_gene_names, # comment this line to allow Metacell2 selecting features #forbidden_gene_names = forbidden_gene_names, # comment this line to allow Metacell2 selecting features target_metacell_size = target_metacell_size, random_seed = 123456) #&gt; set 3k_pbmc.clean.var[rare_gene]: 0 true (0%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[rare_gene_module]: 16566 int32 elements with all outliers (100%) #&gt; set 3k_pbmc.clean.obs[cells_rare_gene_module]: 2638 int32 elements with all outliers (100%) #&gt; set 3k_pbmc.clean.obs[rare_cell]: 0 true (0%) out of 2638 bools #&gt; set 3k_pbmc.clean.layers[downsampled]: csr_matrix 2638 X 16566 float32s (1218892 &gt; 0) #&gt; set 3k_pbmc.clean.uns[downsample_samples]: 989 #&gt; set 3k_pbmc.clean.var[high_top3_gene]: 552 true (3.332%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[high_total_gene]: 4519 true (27.28%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[high_relative_variance_gene]: 3027 true (18.27%) out of 16566 bools #&gt; set 3k_pbmc.clean.var[feature_gene]: 293 true (1.769%) out of 16566 bools #&gt; set 3k_pbmc.clean.obsp[obs_similarity]: ndarray 2638 X 2638 float32s #&gt; set 3k_pbmc.clean.obsp[obs_outgoing_weights]: csr_matrix 2638 X 2638 float32s (117211 &gt; 0) #&gt; set 3k_pbmc.clean.obs[seed]: 496 outliers (18.8%) out of 2638 int32 elements with 61 groups with mean size 35.11 #&gt; set 3k_pbmc.clean.obs[candidate]: 6 outliers (0.2274%) out of 2638 int32 elements with 67 groups with mean size 39.28 #&gt; set 3k_pbmc.clean.var[gene_deviant_votes]: 942 positive (5.686%) out of 16566 int32s #&gt; set 3k_pbmc.clean.obs[cell_deviant_votes]: 889 positive (33.7%) out of 2638 int32s #&gt; set 3k_pbmc.clean.obs[dissolved]: 10 true (0.3791%) out of 2638 bools #&gt; set 3k_pbmc.clean.obs[metacell]: 905 outliers (34.31%) out of 2638 int64 elements with 66 groups with mean size 26.26 #&gt; set 3k_pbmc.clean.obs[outlier]: 905 true (34.31%) out of 2638 bools #&gt; set 3k_pbmc.clean.uns[pre_directs]: 0 #&gt; set 3k_pbmc.clean.uns[directs]: 1 #&gt; set 3k_pbmc.clean.var[pre_high_total_gene]: * &lt;- 0 #&gt; set 3k_pbmc.clean.var[high_total_gene]: 4519 positive (27.28%) out of 16566 int32s #&gt; set 3k_pbmc.clean.var[pre_high_relative_variance_gene]: * &lt;- 0 #&gt; set 3k_pbmc.clean.var[high_relative_variance_gene]: 3027 positive (18.27%) out of 16566 int32s #&gt; set 3k_pbmc.clean.var[forbidden_gene]: * &lt;- False #&gt; set 3k_pbmc.clean.var[pre_feature_gene]: * &lt;- 0 #&gt; set 3k_pbmc.clean.var[feature_gene]: 293 positive (1.769%) out of 16566 int32s #&gt; set 3k_pbmc.clean.var[pre_gene_deviant_votes]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_cell_directs]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[cell_directs]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_pile]: * &lt;- -1 #&gt; set 3k_pbmc.clean.obs[pile]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_candidate]: * &lt;- -1 #&gt; set 3k_pbmc.clean.obs[pre_cell_deviant_votes]: * &lt;- 0 #&gt; set 3k_pbmc.clean.obs[pre_dissolved]: * &lt;- False #&gt; set 3k_pbmc.clean.obs[pre_metacell]: * &lt;- -1 ad.obs.metacell.head #&gt; &lt;bound method NDFrame.head of index #&gt; AAACATACAACCAC-1 36 #&gt; AAACATTGAGCTAC-1 14 #&gt; AAACATTGATCAGC-1 26 #&gt; AAACCGTGCTTCCG-1 62 #&gt; AAACCGTGTATGCG-1 -1 #&gt; .. #&gt; TTTCGAACTCTCAT-1 62 #&gt; TTTCTACTGAGGCA-1 14 #&gt; TTTCTACTTCCTCG-1 -1 #&gt; TTTGCATGAGAGGC-1 28 #&gt; TTTGCATGCCTCAC-1 27 #&gt; Name: metacell, Length: 2638, dtype: int64&gt; Retrieve aggregated metacell data The pl.divide_and_conquer_pipeline function associate each cell to a metacell or defines the cell as outlier. These assignments are found in the obs layer of the anndata object The function pl.collect_metacells should be used to subsequently retrieve an anndata object containing the data at the metacells level instead of the single-cell level. mc_ad = mc.pl.collect_metacells(ad, name=&#39;metacells&#39;) #&gt; set metacells.var[excluded_gene]: 0 true (0%) out of 16566 bools #&gt; set metacells.var[clean_gene]: 16566 true (100%) out of 16566 bools #&gt; set metacells.var[forbidden_gene]: 0 true (0%) out of 16566 bools #&gt; set metacells.var[pre_feature_gene]: 0 positive (0%) out of 16566 int32s #&gt; set metacells.var[feature_gene]: 293 positive (1.769%) out of 16566 int32s #&gt; set metacells.obs[pile]: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] #&gt; set metacells.obs[candidate]: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, -2, 35 ] mc_ad.shape #&gt; (66, 16566) Comparing the obtained and requested graining level In the following code chunk, we estimate whether a deviation of the obtained gamma from the requested gamma is acceptable. If not, we suggest to increase or decrease the scale parameter to approach the desired graining level. gamma_obtained = ad.shape[0]/mc_ad.shape[0] print(gamma_obtained) #&gt; 39.96969696969697 gamma_dev = (gamma_obtained - gamma)/gamma if abs(gamma_dev) &lt; 0.3: gamma_dev = 0 if gamma_dev &lt; 0: print(&quot;Increase `target_metacell_size` parameter by increasing `scale` and re-run metacell divide_and_conquer_pipeline() to get larger graining level&quot;) elif gamma_dev &gt; 0: print(&quot;Deacrease `target_metacell_size` parameter by decreasing `scale` and re-run metacell divide_and_conquer_pipeline() to get smaller graining level&quot;) elif gamma_dev == 0: print(&quot;The obtained graining level is acceptable, no need to re-run the metacell divide_and_conquer_pipeline() with a new `target_metacell_size` &quot;) #&gt; The obtained graining level is acceptable, no need to re-run the metacell divide_and_conquer_pipeline() with a new `target_metacell_size` If the obtained graining level is not acceptable and you updated scale parameter according to the suggestion, do not forget to re-run chunk ?? ??. 3.1.4 Visualize metacells The following code chunk adds a columns named membership and containing the single_cell assignments to the obs attribute in the anndata object containing the raw data. This annotation will be used in the mc_QC package to compute metacells quality metrics. We also save the single-cell metadata in the metacell anndata object. # make a membership -- index of metacells to which single cells belong to ad.obs[&#39;membership&#39;] = [int(i)+1 if i &gt;= 0 else np.nan for i in ad.obs.metacell] ## Save single-cell metadata (i.e., `raw.obs` dataframe) in the metacell adata object mc_ad.uns = ad.uns.copy() mc_ad.uns[&#39;sc.obs&#39;] = ad.obs.copy() # save the requested gamma mc_ad.uns[&#39;gamma&#39;] = gamma Compute latent space for metacell QC To visualize the metacells, we can project the metacells on the single-cell UMAP representation. To run UMAP, we will generate in the next code chunk a lower-dimentional embedding of the data, so far not needed since the MC2 methods builds metacells from gene expression data and not from latent space. Also, note that some of the QC metrics (e.g., compactness and separation), that we will compute in the next section of this tutorial, are computed from this latent space. # Save count as a separate layer ad.layers[&#39;counts&#39;] = ad.X # Copy the counts to &quot;.raw&quot; attribute of the anndata since it is necessary for downstream analysis # This step should be performed after filtering raw_ad = sc.AnnData(ad.layers[&#39;counts&#39;]) raw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names ad.raw = raw_ad # Normalize cells, log transform and compute highly variable genes sc.pp.normalize_per_cell(ad) sc.pp.log1p(ad) sc.pp.highly_variable_genes(ad, n_top_genes=1000) # Compute principal components - n_comp = 10 sc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True) # Compute UMAP for visualization sc.pp.neighbors(ad, n_neighbors=10, n_pcs=n_comp) sc.tl.umap(ad) To visualize the metacell projection on the single-cell UMAP, we use the mc_visualize function from the mc_QC, this function was adapted from the plot.plot_2D included in the SEACells package. mc_proj = mc_QC.mc_visualize(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;membership&#39;, colour_metacells=True, legend_sc=None, legend_mc=None) #&gt; No artists with labels found to put in legend. Note that artists whose label start with an underscore are ignored when legend() is called with no argument. mc_proj.show() #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. 3.1.5 Metacell QC Compute purity, compactness and separation metrics Size distribution #mc_size = SEACells.plot.plot_SEACell_sizes(ad, bins=20) #mc_ad.obs = pd.merge(mc_ad.obs, mc_size, left_index=True, right_index=True) #mc_ad.obs When available, we can use cell annotation to annotate each metacell to the most abundant cell category (e.g. cell type) composing the metacell. This also allows us to compute metacell purity. If the annotation considered is the cell type, the purity of a metacell is the proportion of the most abundant cell type within the metacell [ref SuperCell] mc_purity = mc_QC.purity(ad, annotation_label, MC_label = &#39;membership&#39;) mc_purity.head() #&gt; louvain louvain_purity #&gt; membership #&gt; 1.0 CD8 T cells 0.857143 #&gt; 2.0 CD4 T cells 0.869565 #&gt; 3.0 CD4 T cells 0.961538 #&gt; 4.0 B cells 1.000000 #&gt; 5.0 CD4 T cells 0.782609 # add purity to metadata mc_ad.obs[&#39;purity&#39;] = list(mc_purity[annotation_label + &quot;_purity&quot;]) The compactness of a metacell is the variance of the components within the metacell [ref SEACells] compactness = mc_QC.compactness(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Compactness_PCA&#39;, n_comp=10)[&#39;Compactness_PCA&#39;] # add compactness to metadata mc_ad.obs[&#39;Compactness_PCA&#39;] = list(compactness) The separation of a metacell is the distance to the closest metacell [ref SEACells] separation = mc_QC.separation(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Separation_PCA&#39;, n_comp=10)[&#39;Separation_PCA&#39;] # add separation to metadata mc_ad.obs[&#39;Separation_PCA&#39;] = list(separation) ad.uns[&#39;mc_obs&#39;] = mc_ad.obs mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;purity&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. #&gt; findfont: Font family &#39;Bitstream Vera Sans&#39; not found. mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;Compactness_PCA&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;Separation_PCA&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) Save output mc_ad.write_h5ad(os.path.join(&#39;./data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) "],["seacells-python.html", "3.2 SEACells (Python)", " 3.2 SEACells (Python) In this section, we construct metacells using SEACells. The code is adapted from the author’s jupyter notebook. For more information on the method, please refer to the section 3 of chapter 2. Importing python packages To run the SEACells, the following python packages need to be imported: import os import pandas as pd import scanpy as sc import SEACells import random import sys sys.path.append(&#39;./mc_QC/&#39;) import mc_QC If you don’t have these packages installed, please refer to the section 2 of chapter 1. 3.2.1 Data loading Similarly to Metacell-2, we will run SEACells on the single-cell dataset composed of XX peripheral blood mononuclear cells (PBMCs). Please follow the section 4 from Chapter 1 to retrieve these data from the scanpy package and save the data in the following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. MC_tool = &quot;SEACells&quot; proj_name = &quot;3k_pbmc&quot; ad = sc.read(os.path.join(&quot;data&quot;, proj_name, &quot;singlecell_anndata_filtered.h5ad&quot;)) 3.2.2 Filtering steps In this tutorial, the data have been pre-filterd in the section XX of chapter XX. 3.2.3 Building metacells Metacells construction using SEACells requires 2 main inputs: i) an anndata object (build_kernel_on parameter), and ii) a key indicating which matrix in the obsm attribute of the anndata object should be considered to compute the kernel needed for archetypal analysis (build_kernel_on parameter). Important optional inputs are: the number of metacells to identify (n_SEACells parameter), which is used as input of the archetypal analysis, ii) the number of neighbors to consider for the knn graph (n_neighbors parameter). Data pre-processing The following code chunk saves the raw counts of the filtered data in the raw attribute of the anndata object. The raw counts will be used later for metacells aggregation. raw_ad = sc.AnnData(ad.X) raw_ad.obs_names, raw_ad.var_names = ad.obs_names, ad.var_names ad.raw = raw_ad To build the kernel for archetypal analysis, SEACells requires a lower-dimensionnal embedding of the data (for example using PCA for scRNA-Seq data or SVD for scATAC-Seq data). In the next code chunk, we follow standard pre-processing steps prior to PCA computation, i.e., data normalization, log transformation, identification of highly variable genes. PCA components are saved in the obsm attribute of the anndata object. To pre-process the single-cell data, we are using standard pre-processing for single-cell RNA-seq data using Scanpy. For more information, see the Scanpy tutorial. # Normalize cells, log transform and compute highly variable genes sc.pp.normalize_per_cell(ad) sc.pp.log1p(ad) sc.pp.highly_variable_genes(ad, n_top_genes=1000) # Compute principal components - # Here we use 10 components to be consistent with our main tutorial, but fill free to explore other number of principal components to use n_comp = 10 sc.tl.pca(ad, n_comps=n_comp, use_highly_variable=True) # Compute UMAP for visualization sc.pp.neighbors(ad, n_neighbors=10, n_pcs=n_comp) sc.tl.umap(ad) Setting up SEACells parameters In this tutorial, we will use in the SEACells model the 10 first principal components resulting from the PCA to build the knn graph which will be used to compute the kernel. The number of neighbors to considered for the knn graph can be fixed using the n_neighbors parameter (here 15). As mentioned previously, users should provide as input the number of metacells required (n_SEACells parameter). This number can be defined as the ratio between the number of single cells and the desired graining level (gamma parameter in the following code chunk). In this example, we choose a graining level of 50. build_kernel_on = &#39;X_pca&#39; # key in ad.obsm to use for computing metacells n_waypoint_eigs = 10 # Number of eigenvalues to consider when initializing metacells n_neighbors = 15 # Number of neighbors used for graph construction gamma = 50 # the requested graining level n_SEACells = int(ad.shape[0]/gamma) # the requested number of metacells Initializing the SEACells model The SEACells model is initialized with the previously defined parameters using the SEACells.core.SEACells function. model = SEACells.core.SEACells(ad, build_kernel_on = build_kernel_on, n_SEACells = n_SEACells, n_waypoint_eigs = n_waypoint_eigs, n_neighbors = n_neighbors, convergence_epsilon = 1e-5, verbose = True) #&gt; Welcome to SEACells! Kernel computation is performed using the mconstruct_kernel_matrix function. model.construct_kernel_matrix() M = model.kernel_matrix Metacells are initialized using the initialize_archetypes function. The SEACells archetypes initialization is based on cells sampling and thus is stochastic. User can fix a seed for reproducible results. To check that the archetypes are evenly spread, users can visualize them using the plot.plot_initialization function. # set seed for reproducibility random.seed(123) # Initialize archetypes model.initialize_archetypes() #&gt; Building kernel on X_pca #&gt; Computing diffusion components from X_pca for waypoint initialization ... #&gt; Determing nearest neighbor graph... #&gt; Done. #&gt; Sampling waypoints ... #&gt; Done. #&gt; Selecting 39 cells from waypoint initialization. #&gt; Initializing residual matrix using greedy column selection #&gt; Initializing f and g... #&gt; Selecting 13 cells from greedy initialization. #&gt; #&gt; 0%| | 0/23 [00:00&lt;?, ?it/s] 100%|##########| 23/23 [00:00&lt;00:00, 441.29it/s] # Visualize the initialization SEACells.plot.plot_initialization(ad, model, plot_basis=&#39;X_umap&#39;) Fitting the SEACells model to identify metacells The identification of the archetypes is an iterative process. In this example, we fixed the minimum and maximum number of iteration to 10 and 50 respectively. We then check the model convergence using the plot_convergence function. model.fit(min_iter = 10, max_iter = 50) #&gt; Randomly initialized A matrix. #&gt; Setting convergence threshold at 0.00088 #&gt; Starting iteration 1. #&gt; Completed iteration 1. #&gt; Starting iteration 10. #&gt; Completed iteration 10. #&gt; Starting iteration 20. #&gt; Completed iteration 20. #&gt; Converged after 25 iterations. model.plot_convergence() Once the final archetypes have been identified, we can assign each single-cell to one metacell (hard assignments). These assignments (membership) can be retrieved using the get_hard_assignments function or extracted from the anndata object using ad.obs[\"SEACell\"]. In this tutorial, we will only consider hard assignments. However, the SEACells package also provides the option to retrieve soft assignments (multiple weighted assignments for each cell) using the get_soft_assignments function. For more details on the soft assignments, please refer to the SEACell paper and the original author’s jupyter notebook. membership = model.get_hard_assignments() membership.head #&gt; &lt;bound method NDFrame.head of SEACell #&gt; index #&gt; AAACATACAACCAC-1 SEACell-41 #&gt; AAACATTGAGCTAC-1 SEACell-1 #&gt; AAACATTGATCAGC-1 SEACell-4 #&gt; AAACCGTGCTTCCG-1 SEACell-19 #&gt; AAACCGTGTATGCG-1 SEACell-40 #&gt; ... ... #&gt; TTTCGAACTCTCAT-1 SEACell-50 #&gt; TTTCTACTGAGGCA-1 SEACell-44 #&gt; TTTCTACTTCCTCG-1 SEACell-27 #&gt; TTTGCATGAGAGGC-1 SEACell-51 #&gt; TTTGCATGCCTCAC-1 SEACell-24 #&gt; #&gt; [2638 rows x 1 columns]&gt; ad.obs[&quot;SEACell&quot;].head #&gt; &lt;bound method NDFrame.head of index #&gt; AAACATACAACCAC-1 SEACell-41 #&gt; AAACATTGAGCTAC-1 SEACell-1 #&gt; AAACATTGATCAGC-1 SEACell-4 #&gt; AAACCGTGCTTCCG-1 SEACell-19 #&gt; AAACCGTGTATGCG-1 SEACell-40 #&gt; ... #&gt; TTTCGAACTCTCAT-1 SEACell-50 #&gt; TTTCTACTGAGGCA-1 SEACell-44 #&gt; TTTCTACTTCCTCG-1 SEACell-27 #&gt; TTTGCATGAGAGGC-1 SEACell-51 #&gt; TTTGCATGCCTCAC-1 SEACell-24 #&gt; Name: SEACell, Length: 2638, dtype: object&gt; Retrieve aggregated metacell data The core.summarize_by_SEACell function can be used to generate a metacell count matrix (aggregation of counts across all cells belonging to each metacell). mc_ad = SEACells.core.summarize_by_SEACell(ad, SEACells_label=&#39;SEACell&#39;, summarize_layer=&#39;raw&#39;) #&gt; 0%| | 0/52 [00:00&lt;?, ?it/s] 100%|##########| 52/52 [00:00&lt;00:00, 564.32it/s] 3.2.4 Visualize metacells To visualize the metacells, we can project the metacells on the single-cell UMAP representation using the plot.plot_2D included in the SEACells package. SEACells.plot.plot_2D(ad, key=&#39;X_umap&#39;, colour_metacells=True) 3.2.5 Metacell QC Compute purity, compactness and separation metrics The following code chunk adds a columns named membership and containing the single_cell assignments to the obs attribute in the anndata object containing the raw data. This annotation will be used in the mc_QC package to compute metacells quality metrics. # make `membership` numeric d = {x: int(i)+1 for i, x in enumerate(mc_ad.obs_names)} ad.obs.merge(membership) ad.obs[&#39;membership&#39;] = [d[x] for x in membership.SEACell] #mc_QC.mc_visualize(ad, key=&#39;X_umap&#39;, group_by_name=&#39;SEACell&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;SEACell&#39;, colour_metacells=True, legend_sc=&#39;full&#39;, legend_mc=None) Size distribution #mc_size = SEACells.plot.plot_SEACell_sizes(ad, bins=20) #mc_ad.obs = pd.merge(mc_ad.obs, mc_size, left_index=True, right_index=True) #mc_ad.obs When available, we can use cell annotation to annotate each metacell to the most abundant cell category (e.g. cell type) composing the metacell. This also allows us to compute metacell purity. If the annotation considered is the cell type, the purity of a metacell is the proportion of the most abundant cell type within the metacell [ref SuperCell] mc_purity = mc_QC.purity(ad, annotation_label, MC_label = &#39;membership&#39;) mc_purity.head() #&gt; louvain louvain_purity #&gt; membership #&gt; 1 CD8 T cells 0.741379 #&gt; 2 B cells 0.967213 #&gt; 3 CD4 T cells 0.941860 #&gt; 4 CD14+ Monocytes 0.950000 #&gt; 5 NK cells 1.000000 # add purity to metadata mc_ad.obs[&#39;purity&#39;] = list(mc_purity[annotation_label + &quot;_purity&quot;]) The compactness of a metacell is the variance of the components within the metacell [ref SEACells] compactness = mc_QC.compactness(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Compactness_PCA&#39;, n_comp=10)[&#39;Compactness_PCA&#39;] # add compactness to metadata mc_ad.obs[&#39;Compactness_PCA&#39;] = list(compactness) The separation of a metacell is the distance to the closest metacell [ref SEACells] separation = mc_QC.separation(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Separation_PCA&#39;, n_comp=10)[&#39;Separation_PCA&#39;] # add separation to metadata mc_ad.obs[&#39;Separation_PCA&#39;] = list(separation) ad.uns[&#39;mc_obs&#39;] = mc_ad.obs mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;purity&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;Compactness_PCA&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;Separation_PCA&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) Save output mc_ad.write_h5ad(os.path.join(&#39;./data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) "],["supercell-r.html", "3.3 SuperCell (R)", " 3.3 SuperCell (R) In this section, we construct metacells using SuperCell. The code is adapted from the author’s github documentation. For more information on the method, please refer to the section 2.2. Importing R packages To run SuperCell, the following python packages need to be imported: if(system.file(package=&#39;SuperCell&#39;) == &quot;&quot;){ remotes::install_github(&quot;GfellerLab/SuperCell&quot;, force = TRUE, upgrade = FALSE) } library(SuperCell) import sys sys.path.append(&#39;./mc_QC/&#39;) import mc_QC import pandas as pd import scanpy as sc import SEACells If you don’t have these packages installed, please refer to the section 2 of chapter 1. 3.3.1 Data loading Similarly to Metacell-2 and SEACells, we will run SuperCell on the single-cell dataset composed of XX peripheral blood mononuclear cells (PBMCs). Please follow the section 4 from Chapter 1 to retrieve these data from the scanpy package and save the data in the following file: “data/3k_pbmc/singlecell_anndata_filtered.h5ad”. MC_tool = &quot;SuperCell&quot; proj_name = &quot;3k_pbmc&quot; sc_data = readRDS(paste0(&quot;data/&quot;, proj_name, &quot;/singlecell_seurat_filtered.rds&quot;)) 3.3.2 Filtering steps In this tutorial, the data have been pre-filtered in the section XX of chapter XX. 3.3.3 Building metacells Metacells construction using SuperCell requires one main inputs, i.e. a matrix of log-normalized gene expression data which will be used to compute PCA to build a knn graph for metacells identification. Important optional inputs are: i) the graining level (gamma parameter), ii) the number of neighbors to consider for the knn graph (k.knn parameter). Data pre-processing SuperCell builds a knn graph based on a lower-dimensional embedding of the data. The computation of this embedding is performed internally in the SCimplify SuperCell function. No pre-processing is thus required from the users. library(Seurat) #&gt; Attaching SeuratObject sc_data &lt;- NormalizeData(sc_data, normalization.method = &quot;LogNormalize&quot;) sc_data &lt;- FindVariableFeatures(sc_data, nfeatures = 1000) sc_data &lt;- ScaleData(sc_data) #&gt; Centering and scaling data matrix sc_data &lt;- RunPCA(sc_data, npcs = 10, features = ) #&gt; PC_ 1 #&gt; Positive: LTB, CD2, ACAP1, STK17A, CTSW, CCL5, GIMAP5, AQP3, GZMA, CST7 #&gt; MAL, HOPX, GZMK, NKG7, KLRG1, LYAR, RIC3, PRF1, FAM107B, CCND3 #&gt; CD79A, SRSF7, PASK, PTPN4, GZMH, GPR183, FGFBP2, TIGIT, TCL1A, ARID5B #&gt; Negative: CST3, TYROBP, LST1, AIF1, FTL, LYZ, FTH1, FCN1, S100A9, TYMP #&gt; FCER1G, CFD, LGALS1, S100A8, LGALS2, CTSS, IFITM3, PSAP, CFP, SAT1 #&gt; IFI30, COTL1, S100A11, NPC2, LGALS3, GSTP1, NCF2, PYCARD, CDA, GPX1 #&gt; PC_ 2 #&gt; Positive: NKG7, CST7, GZMA, PRF1, GZMB, FGFBP2, CTSW, GNLY, CCL4, GZMH #&gt; CCL5, FCGR3A, XCL2, CLIC3, SRGN, HOPX, S100A4, TTC38, IGFBP7, ID2 #&gt; ANXA1, ACTB, TMSB4X, APOBEC3G, KLRG1, LYAR, CD160, ABI3, HAVCR2, IFITM2 #&gt; Negative: CD79A, MS4A1, HLA-DQA1, HLA-DQB1, TCL1A, HLA-DRA, CD79B, CD74, HLA-DRB1, HLA-DPB1 #&gt; HLA-DMA, HLA-DRB5, HLA-DPA1, FCRLA, LTB, HVCN1, BLNK, P2RX5, IRF8, IGLL5 #&gt; SMIM14, PPP1R14A, C16orf74, MZB1, RP5-887A10.1, BTK, RP11-428G5.5, IL4R, PHACTR1, IGJ #&gt; PC_ 3 #&gt; Positive: HLA-DPA1, HLA-DPB1, HLA-DRB5, HLA-DRB1, CD74, HLA-DQB1, HLA-DQA1, CD79B, HLA-DRA, CD79A #&gt; MS4A1, RBM3, HLA-DMA, IFITM2, TCL1A, CSNK2B, HVCN1, UBE2L6, YWHAB, IRF8 #&gt; CTSS, PSMA7, UBXN1, S100A4, C1orf162, PYCARD, APOBEC3G, SMIM14, SRSF7, TYROBP #&gt; Negative: PPBP, PF4, SDPR, SPARC, GNG11, NRGN, HIST1H2AC, GP9, RGS18, TUBB1 #&gt; CLU, AP001189.4, CD9, ITGA2B, PTCRA, CA2, TMEM40, ACRBP, MMD, TREML1 #&gt; SEPT5, RUFY1, MYL9, TSC22D1, MPP1, CMTM5, LY6G6F, GP1BA, RP11-367G6.3, CLEC1B #&gt; PC_ 4 #&gt; Positive: HLA-DQA1, CD79B, CD79A, CD74, HLA-DQB1, HLA-DPB1, MS4A1, HLA-DPA1, HLA-DRB1, HLA-DRA #&gt; HLA-DRB5, TCL1A, GZMB, FGFBP2, HLA-DMA, NKG7, PRF1, HVCN1, CST7, GNLY #&gt; FCRLA, FCGR3A, GZMH, GZMA, CCL4, IRF8, BLNK, IGLL5, CLIC3, P2RX5 #&gt; Negative: FYB, MAL, S100A8, AQP3, TMSB4X, CD2, S100A9, S100A4, GIMAP4, RBP7 #&gt; GIMAP5, S100A12, LGALS2, ANXA1, FOLR3, LYZ, FCN1, PASK, MS4A6A, S100A11 #&gt; CORO1B, AIF1, IL8, ATP5H, CRIP2, IL23A, PPA1, LTB, LGALS3BP, ASGR1 #&gt; PC_ 5 #&gt; Positive: S100A8, LGALS2, S100A9, S100A12, RBP7, FGFBP2, FOLR3, MS4A6A, GZMB, CCL4 #&gt; CCL3, NKG7, GNLY, CST7, GSTP1, GZMA, PRF1, GZMH, ASGR1, CTSW #&gt; LYZ, CCL5, CLIC3, XCL2, TYROBP, IL8, FCN1, GPX1, FCGR1A, TTC38 #&gt; Negative: LTB, MS4A7, IFITM2, HN1, LILRB2, WARS, CTD-2006K23.1, AQP3, VMO1, GDI2 #&gt; ADA, ANXA5, NAAA, FCGR3A, CORO1B, ABRACL, CD2, PPM1N, ATP5C1, HSP90AA1 #&gt; TIMP1, ARL6IP5, ICAM2, COTL1, C1QA, OAS1, PPA1, MAL, ABI3, TNFSF10 sc_data &lt;- RunUMAP(sc_data, reduction = &quot;pca&quot;, dims = c(1:10), n.neighbors = 10) #&gt; Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #&gt; To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; #&gt; This message will be shown once per session #&gt; 15:23:33 UMAP embedding parameters a = 0.9922 b = 1.112 #&gt; 15:23:33 Read 2638 rows and found 10 numeric columns #&gt; 15:23:33 Using Annoy for neighbor search, n_neighbors = 10 #&gt; 15:23:33 Building Annoy index with metric = cosine, n_trees = 50 #&gt; 0% 10 20 30 40 50 60 70 80 90 100% #&gt; [----|----|----|----|----|----|----|----|----|----| #&gt; **************************************************| #&gt; 15:23:33 Writing NN index file to temp file /tmp/RtmpfxPN15/file9ea5737c903 #&gt; 15:23:33 Searching Annoy index using 1 thread, search_k = 1000 #&gt; 15:23:34 Annoy recall = 100% #&gt; 15:23:34 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 10 #&gt; 15:23:34 Initializing from normalized Laplacian + noise (using irlba) #&gt; 15:23:34 Commencing optimization for 500 epochs, with 34256 positive edges #&gt; 15:23:36 Optimization finished UMAPPlot(sc_data, group.by = &quot;louvain&quot;) Setting up SuperCell parameters In this tutorial, we will use in the SuperCell method using the 10 first principal components resulting from the PCA. We chose a graining level of 50 and a number of neighbors of 15 for knn. gamma = 50 # the requested graining level. k.knn = 15 # the number of neighbors considered to build the knn network. nb.var.genes = 1000 # number of the top variable genes to use for dimensionality reduction Metacells idenification MC &lt;- SuperCell::SCimplify(sc_data@assays$RNA@data, # single-cell log-normalized gene expression data k.knn = k.knn, gamma = gamma, n.var.genes = nb.var.genes ) SuperCell returns a list containing the following main elements: i) the single-cell assignments to metacells (membership), ii) Retrieve aggregated metacell data The supercell_GE() function can be used to generate a metacell count matrix (aggregation of counts across all cells belonging to each metacell). Two modes can be used for single-cell aggregation, i.e. averaging or summing counts (using the mode parameter). MC.GE &lt;- supercell_GE(sc_data@assays$RNA@counts, MC$membership, mode = &quot;sum&quot;) dim(MC.GE) #&gt; [1] 32738 53 3.3.4 Visualize metacells We can assign each metacell to a particular annotation using the supercell_assign() function. By default, this function assigns each metacell to a cluster with the largest Jaccard coefficient to avoid biases towards very rare or very abundant clusters. Alternatively, assignment can be performed using relative (may cause biases towards very small populations) or absolute (may cause biases towards large populations) abundance with method = \"relative\" or method = \"absolute\", respectively. MC$annotation &lt;- supercell_assign(clusters = sc_data@meta.data$louvain, # single-cell annotation supercell_membership = MC$membership, # single-cell assignment to metacells method = &quot;jaccard&quot;) The SuperCell package provides the supercell_plot function to visualize the metacell network, which is stored MC object in graph.supercells. The metacells can be colored with respect to a vector of annotation. supercell_plot( MC$graph.supercells, group = MC$annotation, seed = 1, alpha = -pi/2, main = &quot;Metacells colored by cell line assignment&quot; ) To visualize the metacells, we can project the metacells on the single-cell UMAP representation using the plot.plot_2D included in the SEACells package. To use this function we need to create a anndata object as well as to run UMAP on the single cell data. library(anndata) # Create anndata object from R r_ad &lt;- AnnData(X = Matrix::t(sc_data@assays$RNA@counts), obs = sc_data@meta.data, obsm = list(X_pca = sc_data@reductions$pca@cell.embeddings, X_umap = sc_data@reductions$umap@cell.embeddings) ) r_ad$obs[&#39;membership&#39;] &lt;- MC$membership # save anndata object in python environment ad = r.r_ad mc_proj = mc_QC.mc_visualize(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;membership&#39;, colour_mc_name=&#39;membership&#39;, colour_metacells=True, legend_sc=None, legend_mc=None) mc_proj.show() 3.3.5 Metacell QC Compute purity, compactness and separation metrics The following code chunk adds a columns named membership and containing the single_cell assignments to the obs attribute in the anndata object containing the raw data. This annotation will be used in the mc_QC package to compute metacells quality metrics. library(anndata) # Create anndata object from R r_mc_ad &lt;- AnnData(X = Matrix::t(MC.GE), obs = data.frame(annotation = MC$annotation)) # save anndata object in python environment mc_ad = r.r_mc_ad Size distribution #mc_size = SEACells.plot.plot_SEACell_sizes(ad, bins=20) #mc_ad.obs = pd.merge(mc_ad.obs, mc_size, left_index=True, right_index=True) #mc_ad.obs When available, we can use cell annotation to annotate each metacell to the most abundant cell category (e.g. cell type) composing the metacell. This also allows us to compute metacell purity. If the annotation considered is the cell type, the purity of a metacell is the proportion of the most abundant cell type within the metacell [ref SuperCell] mc_purity = mc_QC.purity(ad, annotation_label, MC_label = &#39;membership&#39;) mc_purity.head() #&gt; louvain louvain_purity #&gt; membership #&gt; 1.0 CD4 T cells 0.973684 #&gt; 2.0 CD4 T cells 0.975610 #&gt; 3.0 CD4 T cells 0.990476 #&gt; 4.0 CD8 T cells 0.871287 #&gt; 5.0 CD14+ Monocytes 0.764706 # add purity to metadata mc_ad.obs[&#39;purity&#39;] = list(mc_purity[annotation_label + &quot;_purity&quot;]) The compactness of a metacell is the variance of the components within the metacell [ref SEACells] compactness = mc_QC.compactness(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Compactness_PCA&#39;, n_comp=10)[&#39;Compactness_PCA&#39;] # add compactness to metadata mc_ad.obs[&#39;Compactness_PCA&#39;] = list(compactness) The separation of a metacell is the distance to the closest metacell [ref SEACells] separation = mc_QC.separation(ad, &#39;X_pca&#39;, MC_label = &#39;membership&#39;, DO_DC = False, name = &#39;Separation_PCA&#39;, n_comp=10)[&#39;Separation_PCA&#39;] # add separation to metadata mc_ad.obs[&#39;Separation_PCA&#39;] = list(separation) ad.uns[&#39;mc_obs&#39;] = mc_ad.obs mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;purity&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;Compactness_PCA&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) mc_QC.mc_visualize_continuous(ad, key=&#39;X_umap&#39;, group_by_name=&#39;membership&#39;, colour_sc_name=&#39;louvain&#39;, colour_mc_name=&#39;Separation_PCA&#39;, colour_metacells=True, legend_sc=None, legend_mc=&#39;auto&#39;, metacell_size=30) Save output mc_ad.write_h5ad(os.path.join(&#39;./data&#39;, proj_name, f&#39;metacell_{MC_tool}.h5ad&#39;)) "],["downstream-analysis-of-metacells-for-a-discrete-dataset.html", "Chapter 4 Downstream analysis of metacells (for a discrete dataset)", " Chapter 4 Downstream analysis of metacells (for a discrete dataset) Here we use the obtained metacell to run the downstream analysis on them instead of single-cell data. In this analysis, we treat metacell as single cell, neglecting information about their size (i.e., number of containing single cells). If you are interested in sample-weighted analysis, where metacell size is taken into account, see section 4.4. "],["standard-analysis-r.html", "4.1 Standard analysis (R)", " 4.1 Standard analysis (R) Standard analysis includes dimensionality reduction, clustering, differential expression etc using Seurat [ref] framework. Under construction… "],["standard-analysis-Py.html", "4.2 Standard analysis (Python)", " 4.2 Standard analysis (Python) Standard analysis includes dimensionality reduction, clustering, differential expression etc using Scanpy framework. Under construction… 4.2.1 Dimensionality reduction 4.2.2 Clustering 4.2.3 Differential expression analysis "],["advanced-analysis.html", "4.3 Advanced analysis", " 4.3 Advanced analysis 4.3.1 GRN Gene correlation analysis suffers from large dropout rate of single-cell data and at the same time is very time and memory demanding. Metacells simultaneously adress both issues and thus are beneficial for gene co-expression and gene regulation analysis. Here we demonstrate usage of metacells for GRN analysis using SCENIC [ref]. "],["weighted-analysis.html", "4.4 Sample-weighted analysis", " 4.4 Sample-weighted analysis One of the features of metacells are their size, which is a number of single cell it contains. Since metacells aggregate different number of cells, they also carry different amount of information. And thus, to better reproduce single-cell analysis, bigger metacells should have larger impact on the results than smaller metacells. For this, a sample-weighted analysis can be applied. Sample-weighted analysis is impleented in the SuperCell package. "],["command-line-tool-for-mc-construction.html", "Chapter 5 Command line tool for MC construction", " Chapter 5 Command line tool for MC construction Here is a command line tool to construct metacells using either tool (MC2, SuperCell or SEACells) from a provided dataset. "],["comparison-of-metacells-usage-for-a-discrete-and-continuous-data.html", "Chapter 6 Comparison of metacells usage for a discrete and continuous data", " Chapter 6 Comparison of metacells usage for a discrete and continuous data Under construction… "],["continuous-metacells-have-lower-purity.html", "6.1 Continuous metacells have lower purity", " 6.1 Continuous metacells have lower purity Under construction… "],["data-integration-with-metacells.html", "Chapter 7 Data integration with metacells", " Chapter 7 Data integration with metacells Under construction… "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
